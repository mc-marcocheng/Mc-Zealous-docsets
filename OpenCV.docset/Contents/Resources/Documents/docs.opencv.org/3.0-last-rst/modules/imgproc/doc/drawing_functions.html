<html><head><script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/imgproc/doc/drawing_functions.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:17 GMT -->

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <title>Drawing Functions</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css">
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="../../../index.html">
    <link rel="up" title="imgproc. Image Processing" href="imgproc.html">
    <link rel="next" title="ColorMaps in OpenCV" href="colormaps.html">
    <link rel="prev" title="Miscellaneous Image Transformations" href="miscellaneous_transformations.html">
    <link href="../../../../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700" rel="stylesheet" type="text/css">
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <body><div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="colormaps.html" title="ColorMaps in OpenCV" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="miscellaneous_transformations.html" title="Miscellaneous Image Transformations" accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="imgproc.html" accesskey="U">imgproc. Image Processing</a> »</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo2.png" alt="Logo">
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q">
      <input type="submit" value="Go">
      <input type="hidden" name="check_keywords" value="yes">
      <input type="hidden" name="area" value="default">
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Drawing Functions</a><ul>
<li><a class="reference internal" href="#circle">circle</a></li>
<li><a class="reference internal" href="#clipline">clipLine</a></li>
<li><a class="reference internal" href="#ellipse">ellipse</a></li>
<li><a class="reference internal" href="#ellipse2poly">ellipse2Poly</a></li>
<li><a class="reference internal" href="#fillconvexpoly">fillConvexPoly</a></li>
<li><a class="reference internal" href="#fillpoly">fillPoly</a></li>
<li><a class="reference internal" href="#gettextsize">getTextSize</a></li>
<li><a class="reference internal" href="#initfont">InitFont</a></li>
<li><a class="reference internal" href="#line">line</a></li>
<li><a class="reference internal" href="#arrowedline">arrowedLine</a></li>
<li><a class="reference internal" href="#lineiterator">LineIterator</a></li>
<li><a class="reference internal" href="#rectangle">rectangle</a></li>
<li><a class="reference internal" href="#polylines">polylines</a></li>
<li><a class="reference internal" href="#drawcontours">drawContours</a></li>
<li><a class="reference internal" href="#puttext">putText</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="miscellaneous_transformations.html" title="previous chapter">Miscellaneous Image Transformations</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="colormaps.html" title="next chapter">ColorMaps in OpenCV</a></p>
        </div>
      </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="drawing-functions">
<h1>Drawing Functions<a class="headerlink" href="#drawing-functions" title="Permalink to this headline">¶</a></h1>
<p>Drawing functions work with matrices/images of arbitrary depth.
The boundaries of the shapes can be rendered with antialiasing (implemented only for 8-bit images for now).
All the functions include the parameter <tt class="docutils literal"><span class="pre">color</span></tt> that uses an RGB value (that may be constructed
with the <tt class="docutils literal"><span class="pre">Scalar</span></tt>  constructor
) for color
images and brightness for grayscale images. For color images, the channel ordering
is normally <em>Blue, Green, Red</em>.
This is what <a class="reference internal" href="../../highgui/doc/user_interface.html#void imshow(const String&amp; winname, InputArray mat)" title="void imshow(const String&amp; winname, InputArray mat)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">imshow()</span></tt></a>, <a class="reference internal" href="../../imgcodecs/doc/reading_and_writing_images.html#Mat imread(const String&amp; filename, int flags)" title="Mat imread(const String&amp; filename, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">imread()</span></tt></a>, and <a class="reference internal" href="../../imgcodecs/doc/reading_and_writing_images.html#bool imwrite(const String&amp; filename, InputArray img, const vector&lt;int&gt;&amp; params)" title="bool imwrite(const String&amp; filename, InputArray img, const vector&lt;int&gt;&amp; params)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">imwrite()</span></tt></a> expect.
So, if you form a color using the
<tt class="docutils literal"><span class="pre">Scalar</span></tt> constructor, it should look like:</p>
<div class="math">
<p><img src="../../../_images/math/a804c822549a632edd22fd03307335a13f2eceac.png" alt="\texttt{Scalar} (blue \_ component, green \_ component, red \_ component[, alpha \_ component])"></p>
</div><p>If you are using your own image rendering and I/O functions, you can use any channel ordering. The drawing functions process each channel independently and do not depend on the channel order or even on the used color space. The whole image can be converted from BGR to RGB or to a different color space using
<a class="reference internal" href="miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)" title="void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cvtColor()</span></tt></a> .</p>
<p>If a drawn figure is partially or completely outside the image, the drawing functions clip it. Also, many drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means that the coordinates can be passed as fixed-point numbers encoded as integers. The number of fractional bits is specified by the <tt class="docutils literal"><span class="pre">shift</span></tt> parameter and the real point coordinates are calculated as
<img class="math" src="../../../_images/math/ad8e4abc2a8f113077bb71d9ada0fa32d073042b.png" alt="\texttt{Point}(x,y)\rightarrow\texttt{Point2f}(x*2^{-shift},y*2^{-shift})"> . This feature is especially effective when rendering antialiased shapes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The functions do not support alpha-transparency when the target image is 4-channel. In this case, the <tt class="docutils literal"><span class="pre">color[3]</span></tt> is simply copied to the repainted pixels. Thus, if you want to paint semi-transparent shapes, you can paint them in a separate buffer and then blend it with the main image.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example on using variate drawing functions like line, rectangle, ... can be found at opencv_source_code/samples/cpp/drawing.cpp</li>
</ul>
</div>
<div class="section" id="circle">
<h2>circle<a class="headerlink" href="#circle" title="Permalink to this headline">¶</a></h2>
<p>Draws a circle.</p>
<dl class="function">
<dt id="void circle(InputOutputArray img, Point center, int radius, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">circle</tt><big>(</big>InputOutputArray <strong>img</strong>, Point <strong>center</strong>, int <strong>radius</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void circle(InputOutputArray img, Point center, int radius, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Ecircle"></a><dt id="cv2.circle">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">circle</tt><big>(</big>img, center, radius, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.circle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCircle(CvArr* img, CvPoint center, int radius, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCircle</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint <strong>center</strong>, int <strong>radius</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvCircle(CvArr* img, CvPoint center, int radius, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image where the circle is drawn.</li>
<li><strong>center</strong> – Center of the circle.</li>
<li><strong>radius</strong> – Radius of the circle.</li>
<li><strong>color</strong> – Circle color.</li>
<li><strong>thickness</strong> – Thickness of the circle outline, if positive. Negative thickness means that a filled circle is to be drawn.</li>
<li><strong>lineType</strong> – Type of the circle boundary. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the coordinates of the center and in the radius value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">circle</span></tt> draws a simple or filled circle with a given center and radius.</p>
</div>
<div class="section" id="clipline">
<h2>clipLine<a class="headerlink" href="#clipline" title="Permalink to this headline">¶</a></h2>
<p>Clips the line against the image rectangle.</p>
<dl class="function">
<dt id="bool clipLine(Size imgSize, Point&amp; pt1, Point&amp; pt2)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">clipLine</tt><big>(</big>Size <strong>imgSize</strong>, Point&amp; <strong>pt1</strong>, Point&amp; <strong>pt2</strong><big>)</big><a class="headerlink" href="#bool clipLine(Size imgSize, Point&amp; pt1, Point&amp; pt2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="bool clipLine(Rect imgRect, Point&amp; pt1, Point&amp; pt2)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descname">clipLine</tt><big>(</big>Rect <strong>imgRect</strong>, Point&amp; <strong>pt1</strong>, Point&amp; <strong>pt2</strong><big>)</big><a class="headerlink" href="#bool clipLine(Rect imgRect, Point&amp; pt1, Point&amp; pt2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EclipLine"></a><dt id="cv2.clipLine">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">clipLine</tt><big>(</big>imgRect, pt1, pt2<big>)</big> → retval, pt1, pt2<a class="headerlink" href="#cv2.clipLine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvClipLine(CvSize img_size, CvPoint* pt1, CvPoint* pt2)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvClipLine</tt><big>(</big>CvSize <strong>img_size</strong>, CvPoint* <strong>pt1</strong>, CvPoint* <strong>pt2</strong><big>)</big><a class="headerlink" href="#int cvClipLine(CvSize img_size, CvPoint* pt1, CvPoint* pt2)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>imgSize</strong> – Image size. The image rectangle is  <tt class="docutils literal"><span class="pre">Rect(0,</span> <span class="pre">0,</span> <span class="pre">imgSize.width,</span> <span class="pre">imgSize.height)</span></tt> .</li>
<li><strong>imgRect</strong> – Image rectangle.</li>
<li><strong>pt1</strong> – First line point.</li>
<li><strong>pt2</strong> – Second line point.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">clipLine</span></tt> calculate a part of the line segment that is entirely within the specified rectangle.
They return <tt class="docutils literal"><span class="pre">false</span></tt> if the line segment is completely outside the rectangle. Otherwise, they return <tt class="docutils literal"><span class="pre">true</span></tt> .</p>
</div>
<div class="section" id="ellipse">
<h2>ellipse<a class="headerlink" href="#ellipse" title="Permalink to this headline">¶</a></h2>
<p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p>
<dl class="function">
<dt id="void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">ellipse</tt><big>(</big>InputOutputArray <strong>img</strong>, Point <strong>center</strong>, Size <strong>axes</strong>, double <strong>angle</strong>, double <strong>startAngle</strong>, double <strong>endAngle</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void ellipse(InputOutputArray img, const RotatedRect&amp; box, const Scalar&amp; color, int thickness, int lineType)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">ellipse</tt><big>(</big>InputOutputArray <strong>img</strong>, const RotatedRect&amp; <strong>box</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8 <big>)</big><a class="headerlink" href="#void ellipse(InputOutputArray img, const RotatedRect&amp; box, const Scalar&amp; color, int thickness, int lineType)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Eellipse"></a><dt id="cv2.ellipse">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">ellipse</tt><big>(</big>img, center, axes, angle, startAngle, endAngle, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.ellipse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt>
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">ellipse</tt><big>(</big>img, box, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">]</span><span class="optional">]</span><big>)</big> → img</dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvEllipse(CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvEllipse</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint <strong>center</strong>, CvSize <strong>axes</strong>, double <strong>angle</strong>, double <strong>start_angle</strong>, double <strong>end_angle</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvEllipse(CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvEllipseBox(CvArr* img, CvBox2D box, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvEllipseBox</tt><big>(</big>CvArr* <strong>img</strong>, CvBox2D <strong>box</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvEllipseBox(CvArr* img, CvBox2D box, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>center</strong> – Center of the ellipse.</li>
<li><strong>axes</strong> – Half of the size of the ellipse main axes.</li>
<li><strong>angle</strong> – Ellipse rotation angle in degrees.</li>
<li><strong>startAngle</strong> – Starting angle of the elliptic arc in degrees.</li>
<li><strong>endAngle</strong> – Ending angle of the elliptic arc in degrees.</li>
<li><strong>box</strong> – Alternative ellipse representation via  <a class="reference internal" href="../../core/doc/basic_structures.html#RotatedRect" title="class RotatedRect"><tt class="xref ocv ocv-class docutils literal"><span class="pre">RotatedRect</span></tt></a> or <tt class="docutils literal"><span class="pre">CvBox2D</span></tt>. This means that the function draws an ellipse inscribed in the rotated rectangle.</li>
<li><strong>color</strong> – Ellipse color.</li>
<li><strong>thickness</strong> – Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.</li>
<li><strong>lineType</strong> – Type of the ellipse boundary. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the coordinates of the center and values of axes.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The functions <tt class="docutils literal"><span class="pre">ellipse</span></tt> with less parameters draw an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector.
A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using
<a class="reference internal" href="#void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector&lt;Point&gt;&amp; pts)" title="void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector&lt;Point&gt;&amp; pts)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">ellipse2Poly()</span></tt></a> and then render it with
<a class="reference internal" href="#void polylines(Mat&amp; img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void polylines(Mat&amp; img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">polylines()</span></tt></a> or fill it with
<a class="reference internal" href="#void fillPoly(Mat&amp; img, const Point** pts, const int* npts, int ncontours, const Scalar&amp; color, int lineType, int shift, Point offset)" title="void fillPoly(Mat&amp; img, const Point** pts, const int* npts, int ncontours, const Scalar&amp; color, int lineType, int shift, Point offset)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">fillPoly()</span></tt></a> . If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass <tt class="docutils literal"><span class="pre">startAngle=0</span></tt> and <tt class="docutils literal"><span class="pre">endAngle=360</span></tt> . The figure below explains the meaning of the parameters.</p>
<p><strong>Figure 1. Parameters of Elliptic Arc</strong></p>
<img alt="../../../_images/ellipse.png" src="../../../_images/ellipse.png">
</div>
<div class="section" id="ellipse2poly">
<h2>ellipse2Poly<a class="headerlink" href="#ellipse2poly" title="Permalink to this headline">¶</a></h2>
<p>Approximates an elliptic arc with a polyline.</p>
<dl class="function">
<dt id="void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector&lt;Point&gt;&amp; pts)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">ellipse2Poly</tt><big>(</big>Point <strong>center</strong>, Size <strong>axes</strong>, int <strong>angle</strong>, int <strong>arcStart</strong>, int <strong>arcEnd</strong>, int <strong>delta</strong>, vector&lt;Point&gt;&amp; <strong>pts</strong><big>)</big><a class="headerlink" href="#void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector&lt;Point&gt;&amp; pts)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Eellipse2Poly"></a><dt id="cv2.ellipse2Poly">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">ellipse2Poly</tt><big>(</big>center, axes, angle, arcStart, arcEnd, delta<big>)</big> → pts<a class="headerlink" href="#cv2.ellipse2Poly" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>center</strong> – Center of the arc.</li>
<li><strong>axes</strong> – Half of the size of the ellipse main axes. See the  <a class="reference internal" href="#void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">ellipse()</span></tt></a>  for details.</li>
<li><strong>angle</strong> – Rotation angle of the ellipse in degrees. See the  <a class="reference internal" href="#void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">ellipse()</span></tt></a>  for details.</li>
<li><strong>arcStart</strong> – Starting angle of the elliptic arc in degrees.</li>
<li><strong>arcEnd</strong> – Ending angle of the elliptic arc in degrees.</li>
<li><strong>delta</strong> – Angle between the subsequent polyline vertices. It defines the approximation accuracy.</li>
<li><strong>pts</strong> – Output vector of polyline vertices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">ellipse2Poly</span></tt> computes the vertices of a polyline that approximates the specified elliptic arc. It is used by
<a class="reference internal" href="#void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">ellipse()</span></tt></a> .</p>
</div>
<div class="section" id="fillconvexpoly">
<h2>fillConvexPoly<a class="headerlink" href="#fillconvexpoly" title="Permalink to this headline">¶</a></h2>
<p>Fills a convex polygon.</p>
<dl class="function">
<dt id="void fillConvexPoly(Mat&amp; img, const Point* pts, int npts, const Scalar&amp; color, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">fillConvexPoly</tt><big>(</big>Mat&amp; <strong>img</strong>, const Point* <strong>pts</strong>, int <strong>npts</strong>, const Scalar&amp; <strong>color</strong>, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void fillConvexPoly(Mat&amp; img, const Point* pts, int npts, const Scalar&amp; color, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void fillConvexPoly(InputOutputArray img, InputArray points, const Scalar&amp; color, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">fillConvexPoly</tt><big>(</big>InputOutputArray <strong>img</strong>, InputArray <strong>points</strong>, const Scalar&amp; <strong>color</strong>, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void fillConvexPoly(InputOutputArray img, InputArray points, const Scalar&amp; color, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EfillConvexPoly"></a><dt id="cv2.fillConvexPoly">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">fillConvexPoly</tt><big>(</big>img, points, color<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.fillConvexPoly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFillConvexPoly(CvArr* img, const CvPoint* pts, int npts, CvScalar color, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvFillConvexPoly</tt><big>(</big>CvArr* <strong>img</strong>, const CvPoint* <strong>pts</strong>, int <strong>npts</strong>, CvScalar <strong>color</strong>, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvFillConvexPoly(CvArr* img, const CvPoint* pts, int npts, CvScalar color, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pts</strong> – Polygon vertices.</li>
<li><strong>npts</strong> – Number of polygon vertices.</li>
<li><strong>color</strong> – Polygon color.</li>
<li><strong>lineType</strong> – Type of the polygon boundaries. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the vertex coordinates.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">fillConvexPoly</span></tt> draws a filled convex polygon.
This function is much faster than the function <tt class="docutils literal"><span class="pre">fillPoly</span></tt> . It can fill not only convex polygons but any monotonic polygon without self-intersections,
that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal).</p>
</div>
<div class="section" id="fillpoly">
<h2>fillPoly<a class="headerlink" href="#fillpoly" title="Permalink to this headline">¶</a></h2>
<p>Fills the area bounded by one or more polygons.</p>
<dl class="function">
<dt id="void fillPoly(Mat&amp; img, const Point** pts, const int* npts, int ncontours, const Scalar&amp; color, int lineType, int shift, Point offset)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">fillPoly</tt><big>(</big>Mat&amp; <strong>img</strong>, const Point** <strong>pts</strong>, const int* <strong>npts</strong>, int <strong>ncontours</strong>, const Scalar&amp; <strong>color</strong>, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0, Point <strong>offset</strong>=Point() <big>)</big><a class="headerlink" href="#void fillPoly(Mat&amp; img, const Point** pts, const int* npts, int ncontours, const Scalar&amp; color, int lineType, int shift, Point offset)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void fillPoly(InputOutputArray img, InputArrayOfArrays pts, const Scalar&amp; color, int lineType, int shift, Point offset)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">fillPoly</tt><big>(</big>InputOutputArray <strong>img</strong>, InputArrayOfArrays <strong>pts</strong>, const Scalar&amp; <strong>color</strong>, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0, Point <strong>offset</strong>=Point() <big>)</big><a class="headerlink" href="#void fillPoly(InputOutputArray img, InputArrayOfArrays pts, const Scalar&amp; color, int lineType, int shift, Point offset)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EfillPoly"></a><dt id="cv2.fillPoly">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">fillPoly</tt><big>(</big>img, pts, color<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">[</span>, offset<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.fillPoly" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvFillPoly(CvArr* img, CvPoint** pts, const int* npts, int contours, CvScalar color, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvFillPoly</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint** <strong>pts</strong>, const int* <strong>npts</strong>, int <strong>contours</strong>, CvScalar <strong>color</strong>, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvFillPoly(CvArr* img, CvPoint** pts, const int* npts, int contours, CvScalar color, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pts</strong> – Array of polygons where each polygon is represented as an array of points.</li>
<li><strong>npts</strong> – Array of polygon vertex counters.</li>
<li><strong>ncontours</strong> – Number of contours that bind the filled region.</li>
<li><strong>color</strong> – Polygon color.</li>
<li><strong>lineType</strong> – Type of the polygon boundaries. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the vertex coordinates.</li>
<li><strong>offset</strong> – Optional offset of all points of the contours.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">fillPoly</span></tt> fills an area bounded by several polygonal contours. The function can fill complex areas, for example,
areas with holes, contours with self-intersections (some of their parts), and so forth.</p>
</div>
<div class="section" id="gettextsize">
<h2>getTextSize<a class="headerlink" href="#gettextsize" title="Permalink to this headline">¶</a></h2>
<p>Calculates the width and height of a text string.</p>
<dl class="function">
<dt id="Size getTextSize(const String&amp; text, int fontFace, double fontScale, int thickness, int* baseLine)">
<strong>C++:</strong><tt class="descname"> </tt>Size <tt class="descname">getTextSize</tt><big>(</big>const String&amp; <strong>text</strong>, int <strong>fontFace</strong>, double <strong>fontScale</strong>, int <strong>thickness</strong>, int* <strong>baseLine</strong><big>)</big><a class="headerlink" href="#Size getTextSize(const String&amp; text, int fontFace, double fontScale, int thickness, int* baseLine)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EgetTextSize"></a><dt id="cv2.getTextSize">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">getTextSize</tt><big>(</big>text, fontFace, fontScale, thickness<big>)</big> → retval, baseLine<a class="headerlink" href="#cv2.getTextSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvGetTextSize(const char* text_string, const CvFont* font, CvSize* text_size, int* baseline)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvGetTextSize</tt><big>(</big>const char* <strong>text_string</strong>, const CvFont* <strong>font</strong>, CvSize* <strong>text_size</strong>, int* <strong>baseline</strong><big>)</big><a class="headerlink" href="#void cvGetTextSize(const char* text_string, const CvFont* font, CvSize* text_size, int* baseline)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>text</strong> – Input text string.</li>
<li><strong>text_string</strong> – Input text string in C format.</li>
<li><strong>fontFace</strong> – Font to use. See the  <a class="reference internal" href="#void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)" title="void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">putText()</span></tt></a> for details.</li>
<li><strong>fontScale</strong> – Font scale. See the  <a class="reference internal" href="#void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)" title="void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">putText()</span></tt></a>  for details.</li>
<li><strong>thickness</strong> – Thickness of lines used to render the text. See  <a class="reference internal" href="#void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)" title="void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">putText()</span></tt></a>  for details.</li>
<li><strong>baseLine</strong> – Output parameter - y-coordinate of the baseline relative to the bottom-most text point.</li>
<li><strong>baseline</strong> – Output parameter - y-coordinate of the baseline relative to the bottom-most text point.</li>
<li><strong>font</strong> – Font description in terms of old C API.</li>
<li><strong>text_size</strong> – Output parameter - The size of a box that contains the specified text.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">getTextSize</span></tt> calculates and returns the size of a box that contains the specified text.
That is, the following code renders some text, the tight box surrounding it, and the baseline:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="s">"Funny text inside the box"</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fontFace</span> <span class="o">=</span> <span class="n">FONT_HERSHEY_SCRIPT_SIMPLEX</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">fontScale</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">thickness</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">Mat</span> <span class="nf">img</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="kt">int</span> <span class="n">baseline</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">Size</span> <span class="n">textSize</span> <span class="o">=</span> <span class="n">getTextSize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">fontFace</span><span class="p">,</span>
                            <span class="n">fontScale</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">baseline</span><span class="p">);</span>
<span class="n">baseline</span> <span class="o">+=</span> <span class="n">thickness</span><span class="p">;</span>

<span class="c1">// center the text</span>
<span class="n">Point</span> <span class="nf">textOrg</span><span class="p">((</span><span class="n">img</span><span class="p">.</span><span class="n">cols</span> <span class="o">-</span> <span class="n">textSize</span><span class="p">.</span><span class="n">width</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
              <span class="p">(</span><span class="n">img</span><span class="p">.</span><span class="n">rows</span> <span class="o">+</span> <span class="n">textSize</span><span class="p">.</span><span class="n">height</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// draw the box</span>
<span class="n">rectangle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">textOrg</span> <span class="o">+</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">baseline</span><span class="p">),</span>
          <span class="n">textOrg</span> <span class="o">+</span> <span class="n">Point</span><span class="p">(</span><span class="n">textSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="o">-</span><span class="n">textSize</span><span class="p">.</span><span class="n">height</span><span class="p">),</span>
          <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
<span class="c1">// ... and the baseline first</span>
<span class="n">line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">textOrg</span> <span class="o">+</span> <span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">thickness</span><span class="p">),</span>
     <span class="n">textOrg</span> <span class="o">+</span> <span class="n">Point</span><span class="p">(</span><span class="n">textSize</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">thickness</span><span class="p">),</span>
     <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>

<span class="c1">// then put the text itself</span>
<span class="n">putText</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">textOrg</span><span class="p">,</span> <span class="n">fontFace</span><span class="p">,</span> <span class="n">fontScale</span><span class="p">,</span>
        <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span> <span class="n">thickness</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="initfont">
<h2>InitFont<a class="headerlink" href="#initfont" title="Permalink to this headline">¶</a></h2>
<p>Initializes font structure (OpenCV 1.x API).</p>
<dl class="cfunction">
<dt id="void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvInitFont</tt><big>(</big>CvFont* <strong>font</strong>, int <strong>font_face</strong>, double <strong>hscale</strong>, double <strong>vscale</strong>, double <strong>shear</strong>=0, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8 <big>)</big><a class="headerlink" href="#void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>font</strong> – Pointer to the font structure initialized by the function</li>
<li><strong>font_face</strong> – <p>Font name identifier. Only a subset of Hershey fonts  <a class="reference external" href="http://sources.isc.org/utils/misc/hershey-font.txt">http://sources.isc.org/utils/misc/hershey-font.txt</a>  are supported now:</p>
<blockquote>
<div><ul>
<li><strong>CV_FONT_HERSHEY_SIMPLEX</strong> normal size sans-serif font</li>
<li><strong>CV_FONT_HERSHEY_PLAIN</strong> small size sans-serif font</li>
<li><strong>CV_FONT_HERSHEY_DUPLEX</strong> normal size sans-serif font (more complex than    <tt class="docutils literal"><span class="pre">CV_FONT_HERSHEY_SIMPLEX</span></tt> )</li>
<li><strong>CV_FONT_HERSHEY_COMPLEX</strong> normal size serif font</li>
<li><strong>CV_FONT_HERSHEY_TRIPLEX</strong> normal size serif font (more complex than  <tt class="docutils literal"><span class="pre">CV_FONT_HERSHEY_COMPLEX</span></tt> )</li>
<li><strong>CV_FONT_HERSHEY_COMPLEX_SMALL</strong> smaller version of  <tt class="docutils literal"><span class="pre">CV_FONT_HERSHEY_COMPLEX</span></tt></li>
<li><strong>CV_FONT_HERSHEY_SCRIPT_SIMPLEX</strong> hand-writing style font</li>
<li><strong>CV_FONT_HERSHEY_SCRIPT_COMPLEX</strong> more complex variant of  <tt class="docutils literal"><span class="pre">CV_FONT_HERSHEY_SCRIPT_SIMPLEX</span></tt></li>
</ul>
</div></blockquote>
<p>The parameter can be composited from one of the values above and an optional  <tt class="docutils literal"><span class="pre">CV_FONT_ITALIC</span></tt>  flag, which indicates italic or oblique font.</p>
</li>
<li><strong>hscale</strong> – Horizontal scale.  If equal to  <tt class="docutils literal"><span class="pre">1.0f</span></tt> , the characters have the original width depending on the font type. If equal to  <tt class="docutils literal"><span class="pre">0.5f</span></tt> , the characters are of half the original width.</li>
<li><strong>vscale</strong> – Vertical scale. If equal to  <tt class="docutils literal"><span class="pre">1.0f</span></tt> , the characters have the original height depending on the font type. If equal to  <tt class="docutils literal"><span class="pre">0.5f</span></tt> , the characters are of half the original height.</li>
<li><strong>shear</strong> – Approximate tangent of the character slope relative to the vertical line.  A zero value means a non-italic font,  <tt class="docutils literal"><span class="pre">1.0f</span></tt>  means about a 45 degree slope, etc.</li>
<li><strong>thickness</strong> – Thickness of the text strokes</li>
<li><strong>line_type</strong> – Type of the strokes, see  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function initializes the font structure that can be passed to text rendering functions.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)" title="void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">PutText()</span></tt></a></p>
</div>
</div>
<div class="section" id="line">
<span id="id1"></span><h2>line<a class="headerlink" href="#line" title="Permalink to this headline">¶</a></h2>
<p>Draws a line segment connecting two points.</p>
<dl class="function">
<dt id="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">line</tt><big>(</big>InputOutputArray <strong>img</strong>, Point <strong>pt1</strong>, Point <strong>pt2</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Eline"></a><dt id="cv2.line">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">line</tt><big>(</big>img, pt1, pt2, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvLine(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvLine</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint <strong>pt1</strong>, CvPoint <strong>pt2</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvLine(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pt1</strong> – First point of the line segment.</li>
<li><strong>pt2</strong> – Second point of the line segment.</li>
<li><strong>color</strong> – Line color.</li>
<li><strong>thickness</strong> – Line thickness.</li>
<li><strong>lineType</strong> – <p>Type of the line:</p>
<ul>
<li><strong>LINE_8</strong> (or omitted) - 8-connected line.</li>
<li><strong>LINE_4</strong> - 4-connected line.</li>
<li><strong>LINE_AA</strong> - antialiased line.</li>
</ul>
</li>
<li><strong>shift</strong> – Number of fractional bits in the point coordinates.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">line</span></tt> draws the line segment between <tt class="docutils literal"><span class="pre">pt1</span></tt> and <tt class="docutils literal"><span class="pre">pt2</span></tt> points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings.
Antialiased lines are drawn using Gaussian filtering.</p>
</div>
<div class="section" id="arrowedline">
<h2>arrowedLine<a class="headerlink" href="#arrowedline" title="Permalink to this headline">¶</a></h2>
<p>Draws a arrow segment pointing from the first point to the second one.</p>
<dl class="function">
<dt id="void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift, double tipLength)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">arrowedLine</tt><big>(</big>InputOutputArray <strong>img</strong>, Point <strong>pt1</strong>, Point <strong>pt2</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=8, int <strong>shift</strong>=0, double <strong>tipLength</strong>=0.1<big>)</big><a class="headerlink" href="#void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift, double tipLength)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pt1</strong> – The point the arrow starts from.</li>
<li><strong>pt2</strong> – The point the arrow points to.</li>
<li><strong>color</strong> – Line color.</li>
<li><strong>thickness</strong> – Line thickness.</li>
<li><strong>lineType</strong> – <p>Type of the line:</p>
<ul>
<li><strong>8</strong> (or omitted) - 8-connected line.</li>
<li><strong>4</strong> - 4-connected line.</li>
<li><strong>CV_AA</strong> - antialiased line.</li>
</ul>
</li>
<li><strong>shift</strong> – Number of fractional bits in the point coordinates.</li>
<li><strong>tipLength</strong> – The length of the arrow tip in relation to the arrow length</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">arrowedLine</span></tt> draws an arrow between <tt class="docutils literal"><span class="pre">pt1</span></tt> and <tt class="docutils literal"><span class="pre">pt2</span></tt> points in the image. See also <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>.</p>
</div>
<div class="section" id="lineiterator">
<h2>LineIterator<a class="headerlink" href="#lineiterator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="LineIterator">
<em class="property">class </em><tt class="descname">LineIterator</tt><a class="headerlink" href="#LineIterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class for iterating pixels on a raster line.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LineIterator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// creates iterators for the line connecting pt1 and pt2</span>
    <span class="c1">// the line will be clipped on the image boundaries</span>
    <span class="c1">// the line is 8-connected or 4-connected</span>
    <span class="c1">// If leftToRight=true, then the iteration is always done</span>
    <span class="c1">// from the left-most point to the right most,</span>
    <span class="c1">// not to depend on the ordering of pt1 and pt2 parameters</span>
    <span class="n">LineIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">Point</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">Point</span> <span class="n">pt2</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">leftToRight</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span>
    <span class="c1">// returns pointer to the current line pixel</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="k">operator</span> <span class="o">*</span><span class="p">();</span>
    <span class="c1">// move the iterator to the next pixel</span>
    <span class="n">LineIterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span><span class="p">();</span>
    <span class="n">LineIterator</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="n">Point</span> <span class="n">pos</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// internal state of the iterator</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minusDelta</span><span class="p">,</span> <span class="n">plusDelta</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minusStep</span><span class="p">,</span> <span class="n">plusStep</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">LineIterator</span></tt> is used to get each pixel of a raster line. It can be treated as versatile implementation of the Bresenham algorithm where you can stop at each pixel and do some extra processing, for example, grab pixel values along the line or draw a line with an effect (for example, with XOR operation).</p>
<p>The number of pixels along the line is stored in <tt class="docutils literal"><span class="pre">LineIterator::count</span></tt> . The method <tt class="docutils literal"><span class="pre">LineIterator::pos</span></tt> returns the current position in the image</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// grabs pixels along the line (pt1, pt2)</span>
<span class="c1">// from 8-bit 3-channel image to the buffer</span>
<span class="n">LineIterator</span> <span class="nf">it</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">LineIterator</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">count</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">it</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec3b</span><span class="p">)</span><span class="o">*</span><span class="n">it</span><span class="p">;</span>

<span class="c1">// alternative way of iterating through the line</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">it2</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">it2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vec3b</span> <span class="n">val</span> <span class="o">=</span> <span class="n">img</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it2</span><span class="p">.</span><span class="n">pos</span><span class="p">());</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="rectangle">
<h2>rectangle<a class="headerlink" href="#rectangle" title="Permalink to this headline">¶</a></h2>
<p>Draws a simple, thick, or filled up-right rectangle.</p>
<dl class="function">
<dt id="void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">rectangle</tt><big>(</big>InputOutputArray <strong>img</strong>, Point <strong>pt1</strong>, Point <strong>pt2</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void rectangle(Mat&amp; img, Rect rec, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">rectangle</tt><big>(</big>Mat&amp; <strong>img</strong>, Rect <strong>rec</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void rectangle(Mat&amp; img, Rect rec, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Erectangle"></a><dt id="cv2.rectangle">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">rectangle</tt><big>(</big>img, pt1, pt2, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.rectangle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvRectangle(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvRectangle</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint <strong>pt1</strong>, CvPoint <strong>pt2</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvRectangle(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pt1</strong> – Vertex of the rectangle.</li>
<li><strong>pt2</strong> – Vertex of the rectangle opposite to  <tt class="docutils literal"><span class="pre">pt1</span></tt> .</li>
<li><strong>rec</strong> – Alternative specification of the drawn rectangle.</li>
<li><strong>color</strong> – Rectangle color or brightness (grayscale image).</li>
<li><strong>thickness</strong> – Thickness of lines that make up the rectangle. Negative values, like  <tt class="docutils literal"><span class="pre">CV_FILLED</span></tt> , mean that the function has to draw a filled rectangle.</li>
<li><strong>lineType</strong> – Type of the line. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the point coordinates.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">rectangle</span></tt> draws a rectangle outline or a filled rectangle whose two opposite corners are <tt class="docutils literal"><span class="pre">pt1</span></tt> and <tt class="docutils literal"><span class="pre">pt2</span></tt>, or <tt class="docutils literal"><span class="pre">r.tl()</span></tt> and <tt class="docutils literal"><span class="pre">r.br()-Point(1,1)</span></tt>.</p>
</div>
<div class="section" id="polylines">
<h2>polylines<a class="headerlink" href="#polylines" title="Permalink to this headline">¶</a></h2>
<p>Draws several polygonal curves.</p>
<dl class="function">
<dt id="void polylines(Mat&amp; img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">polylines</tt><big>(</big>Mat&amp; <strong>img</strong>, const Point* const* <strong>pts</strong>, const int* <strong>npts</strong>, int <strong>ncontours</strong>, bool <strong>isClosed</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void polylines(Mat&amp; img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">polylines</tt><big>(</big>InputOutputArray <strong>img</strong>, InputArrayOfArrays <strong>pts</strong>, bool <strong>isClosed</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar&amp; color, int thickness, int lineType, int shift)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2Epolylines"></a><dt id="cv2.polylines">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">polylines</tt><big>(</big>img, pts, isClosed, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, shift<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → img<a class="headerlink" href="#cv2.polylines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPolyLine(CvArr* img, CvPoint** pts, const int* npts, int contours, int is_closed, CvScalar color, int thickness, int line_type, int shift)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPolyLine</tt><big>(</big>CvArr* <strong>img</strong>, CvPoint** <strong>pts</strong>, const int* <strong>npts</strong>, int <strong>contours</strong>, int <strong>is_closed</strong>, CvScalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, int <strong>shift</strong>=0 <big>)</big><a class="headerlink" href="#void cvPolyLine(CvArr* img, CvPoint** pts, const int* npts, int contours, int is_closed, CvScalar color, int thickness, int line_type, int shift)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>pts</strong> – Array of polygonal curves.</li>
<li><strong>npts</strong> – Array of polygon vertex counters.</li>
<li><strong>ncontours</strong> – Number of curves.</li>
<li><strong>isClosed</strong> – Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex.</li>
<li><strong>color</strong> – Polyline color.</li>
<li><strong>thickness</strong> – Thickness of the polyline edges.</li>
<li><strong>lineType</strong> – Type of the line segments. See the  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  description.</li>
<li><strong>shift</strong> – Number of fractional bits in the vertex coordinates.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">polylines</span></tt> draws one or more polygonal curves.</p>
</div>
<div class="section" id="drawcontours">
<h2>drawContours<a class="headerlink" href="#drawcontours" title="Permalink to this headline">¶</a></h2>
<p>Draws contours outlines or filled contours.</p>
<dl class="function">
<dt id="void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">drawContours</tt><big>(</big>InputOutputArray <strong>image</strong>, InputArrayOfArrays <strong>contours</strong>, int <strong>contourIdx</strong>, const Scalar&amp; <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, InputArray <strong>hierarchy</strong>=noArray(), int <strong>maxLevel</strong>=INT_MAX, Point <strong>offset</strong>=Point() <big>)</big><a class="headerlink" href="#void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EdrawContours"></a><dt id="cv2.drawContours">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">drawContours</tt><big>(</big>image, contours, contourIdx, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, hierarchy<span class="optional">[</span>, maxLevel<span class="optional">[</span>, offset<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → image<a class="headerlink" href="#cv2.drawContours" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvDrawContours(CvArr * img, CvSeq* contour, CvScalar external_color, CvScalar hole_color, int max_level, int thickness, int line_type, CvPoint offset)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvDrawContours</tt><big>(</big>CvArr* <strong>img</strong>, CvSeq* <strong>contour</strong>, CvScalar <strong>external_color</strong>, CvScalar <strong>hole_color</strong>, int <strong>max_level</strong>, int <strong>thickness</strong>=1, int <strong>line_type</strong>=8, CvPoint <strong>offset</strong>=cvPoint(0,0) <big>)</big><a class="headerlink" href="#void cvDrawContours(CvArr * img, CvSeq* contour, CvScalar external_color, CvScalar hole_color, int max_level, int thickness, int line_type, CvPoint offset)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> – Destination image.</li>
<li><strong>contours</strong> – All the input contours. Each contour is stored as a point vector.</li>
<li><strong>contourIdx</strong> – Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</li>
<li><strong>color</strong> – Color of the contours.</li>
<li><strong>thickness</strong> – Thickness of lines the contours are drawn with. If it is negative (for example,  <tt class="docutils literal"><span class="pre">thickness=CV_FILLED</span></tt> ), the contour interiors are
drawn.</li>
<li><strong>lineType</strong> – Line connectivity. See  <a class="reference internal" href="#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)" title="void line(InputOutputArray img, Point pt1, Point pt2, const Scalar&amp; color, int thickness, int lineType, int shift)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">line()</span></tt></a>  for details.</li>
<li><strong>hierarchy</strong> – Optional information about hierarchy. It is only needed if you want to draw only some of the  contours (see  <tt class="docutils literal"><span class="pre">maxLevel</span></tt> ).</li>
<li><strong>maxLevel</strong> – Maximal level for drawn contours. If it is 0, only
the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is  <tt class="docutils literal"><span class="pre">hierarchy</span></tt>  available.</li>
<li><strong>offset</strong> – Optional contour shift parameter. Shift all the drawn contours by the specified  <img class="math" src="../../../_images/math/986f77d1de9059c061d3213f93eb6827412d66bf.png" alt="\texttt{offset}=(dx,dy)"> .</li>
<li><strong>contour</strong> – Pointer to the first contour.</li>
<li><strong>external_color</strong> – Color of external contours.</li>
<li><strong>hole_color</strong> – Color of internal contours (holes).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function draws contour outlines in the image if
<img class="math" src="../../../_images/math/c266655688ae59ab4b889de55a25a5c3457f1ce2.png" alt="\texttt{thickness} \ge 0"> or fills the area bounded by the contours if
<img class="math" src="../../../_images/math/5b9feca4e2442437d603146f8ba7da28dca53a28.png" alt="\texttt{thickness}&lt;0"> . The example below shows how to retrieve connected components from the binary image and label them:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include "opencv2/imgproc.hpp"</span>
<span class="cp">#include "opencv2/highgui.hpp"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">src</span><span class="p">;</span>
    <span class="c1">// the first command-line parameter must be a filename of the binary</span>
    <span class="c1">// (black-n-white) image</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)).</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">Mat</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>

    <span class="n">src</span> <span class="o">=</span> <span class="n">src</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">namedWindow</span><span class="p">(</span> <span class="s">"Source"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span> <span class="s">"Source"</span><span class="p">,</span> <span class="n">src</span> <span class="p">);</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">contours</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Vec4i</span><span class="o">&gt;</span> <span class="n">hierarchy</span><span class="p">;</span>

    <span class="n">findContours</span><span class="p">(</span> <span class="n">src</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">hierarchy</span><span class="p">,</span>
        <span class="n">RETR_CCOMP</span><span class="p">,</span> <span class="n">CHAIN_APPROX_SIMPLE</span> <span class="p">);</span>

    <span class="c1">// iterate through all the top-level contours,</span>
    <span class="c1">// draw each connected component with its own random color</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">hierarchy</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Scalar</span> <span class="n">color</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span><span class="o">&amp;</span><span class="mi">255</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">&amp;</span><span class="mi">255</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span><span class="o">&amp;</span><span class="mi">255</span> <span class="p">);</span>
        <span class="n">drawContours</span><span class="p">(</span> <span class="n">dst</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">FILLED</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">hierarchy</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">namedWindow</span><span class="p">(</span> <span class="s">"Components"</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">imshow</span><span class="p">(</span> <span class="s">"Components"</span><span class="p">,</span> <span class="n">dst</span> <span class="p">);</span>
    <span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the drawContour functionality can be found at opencv_source_code/samples/cpp/contours2.cpp</li>
<li>An example using drawContours to clean up a background segmentation result at opencv_source_code/samples/cpp/segment_objects.cpp</li>
<li>(Python) An example using the drawContour functionality can be found at opencv_source/samples/python2/contours.py</li>
</ul>
</div>
</div>
<div class="section" id="puttext">
<h2>putText<a class="headerlink" href="#puttext" title="Permalink to this headline">¶</a></h2>
<p>Draws a text string.</p>
<dl class="function">
<dt id="void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">putText</tt><big>(</big>InputOutputArray <strong>img</strong>, const String&amp; <strong>text</strong>, Point <strong>org</strong>, int <strong>fontFace</strong>, double <strong>fontScale</strong>, Scalar <strong>color</strong>, int <strong>thickness</strong>=1, int <strong>lineType</strong>=LINE_8, bool <strong>bottomLeftOrigin</strong>=false <big>)</big><a class="headerlink" href="#void putText(InputOutputArray img, const String&amp; text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EputText"></a><dt id="cv2.putText">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">putText</tt><big>(</big>img, text, org, fontFace, fontScale, color<span class="optional">[</span>, thickness<span class="optional">[</span>, lineType<span class="optional">[</span>, bottomLeftOrigin<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → None<a class="headerlink" href="#cv2.putText" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvPutText</tt><big>(</big>CvArr* <strong>img</strong>, const char* <strong>text</strong>, CvPoint <strong>org</strong>, const CvFont* <strong>font</strong>, CvScalar <strong>color</strong><big>)</big><a class="headerlink" href="#void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> – Image.</li>
<li><strong>text</strong> – Text string to be drawn.</li>
<li><strong>org</strong> – Bottom-left corner of the text string in the image.</li>
<li><strong>font</strong> – <tt class="docutils literal"><span class="pre">CvFont</span></tt> structure initialized using <a class="reference internal" href="#void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)" title="void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)"><tt class="xref ocv ocv-cfunc docutils literal"><span class="pre">InitFont()</span></tt></a>.</li>
<li><strong>fontFace</strong> – Font type. One of  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_SIMPLEX</span></tt>,  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_PLAIN</span></tt>, <tt class="docutils literal"><span class="pre">FONT_HERSHEY_DUPLEX</span></tt>,  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_COMPLEX</span></tt>,  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_TRIPLEX</span></tt>, <tt class="docutils literal"><span class="pre">FONT_HERSHEY_COMPLEX_SMALL</span></tt>,  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_SCRIPT_SIMPLEX</span></tt>, or  <tt class="docutils literal"><span class="pre">FONT_HERSHEY_SCRIPT_COMPLEX</span></tt>,
where each of the font ID’s can be combined with  <tt class="docutils literal"><span class="pre">FONT_ITALIC</span></tt>  to get the slanted letters.</li>
<li><strong>fontScale</strong> – Font scale factor that is multiplied by the font-specific base size.</li>
<li><strong>color</strong> – Text color.</li>
<li><strong>thickness</strong> – Thickness of the lines used to draw a text.</li>
<li><strong>lineType</strong> – Line type. See the  <tt class="docutils literal"><span class="pre">line</span></tt>  for details.</li>
<li><strong>bottomLeftOrigin</strong> – When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function <tt class="docutils literal"><span class="pre">putText</span></tt> renders the specified text string in the image.
Symbols that cannot be rendered using the specified font are
replaced by question marks. See
<a class="reference internal" href="#Size getTextSize(const String&amp; text, int fontFace, double fontScale, int thickness, int* baseLine)" title="Size getTextSize(const String&amp; text, int fontFace, double fontScale, int thickness, int* baseLine)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getTextSize()</span></tt></a> for a text rendering code example.</p>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&amp;A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="colormaps.html" title="ColorMaps in OpenCV">next</a> |</li>
        <li class="right">
          <a href="miscellaneous_transformations.html" title="Miscellaneous Image Transformations">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="imgproc.html">imgproc. Image Processing</a> »</li> 
      </ul>
    </div>
    <div class="footer">
        © Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
      <a href="../../../_sources/modules/imgproc/doc/drawing_functions.txt" rel="nofollow">Show this page source.</a>
    </div>
  

<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/imgproc/doc/drawing_functions.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:17 GMT -->
</body></html>