<html><head><script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/core/doc/basic_structures.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:03 GMT -->

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <title>Basic Structures</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css">
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="../../../index.html">
    <link rel="up" title="core. The Core Functionality" href="core.html">
    <link rel="next" title="Command Line Parser" href="command_line_parser.html">
    <link rel="prev" title="core. The Core Functionality" href="core.html">
    <link href="../../../../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700" rel="stylesheet" type="text/css">
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <body><div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="command_line_parser.html" title="Command Line Parser" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="core.html" title="core. The Core Functionality" accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="core.html" accesskey="U">core. The Core Functionality</a> »</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo2.png" alt="Logo">
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q">
      <input type="submit" value="Go">
      <input type="hidden" name="check_keywords" value="yes">
      <input type="hidden" name="area" value="default">
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Basic Structures</a><ul>
<li><a class="reference internal" href="#datatype">DataType</a></li>
<li><a class="reference internal" href="#point">Point_</a></li>
<li><a class="reference internal" href="#point3">Point3_</a></li>
<li><a class="reference internal" href="#size">Size_</a></li>
<li><a class="reference internal" href="#rect">Rect_</a></li>
<li><a class="reference internal" href="#rotatedrect">RotatedRect</a></li>
<li><a class="reference internal" href="#termcriteria">TermCriteria</a></li>
<li><a class="reference internal" href="#termcriteria-termcriteria">TermCriteria::TermCriteria</a></li>
<li><a class="reference internal" href="#matx">Matx</a></li>
<li><a class="reference internal" href="#vec">Vec</a></li>
<li><a class="reference internal" href="#scalar">Scalar_</a></li>
<li><a class="reference internal" href="#range">Range</a></li>
<li><a class="reference internal" href="#keypoint">KeyPoint</a></li>
<li><a class="reference internal" href="#keypoint-keypoint">KeyPoint::KeyPoint</a></li>
<li><a class="reference internal" href="#keypoint-convert">KeyPoint::convert</a></li>
<li><a class="reference internal" href="#keypoint-overlap">KeyPoint::overlap</a></li>
<li><a class="reference internal" href="#dmatch">DMatch</a></li>
<li><a class="reference internal" href="#ptr">Ptr</a></li>
<li><a class="reference internal" href="#ptr-ptr-null">Ptr::Ptr (null)</a></li>
<li><a class="reference internal" href="#ptr-ptr-assuming-ownership">Ptr::Ptr (assuming ownership)</a></li>
<li><a class="reference internal" href="#ptr-ptr-sharing-ownership">Ptr::Ptr (sharing ownership)</a></li>
<li><a class="reference internal" href="#ptr-ptr">Ptr::~Ptr</a></li>
<li><a class="reference internal" href="#ptr-operator">Ptr::operator =</a></li>
<li><a class="reference internal" href="#ptr-release">Ptr::release</a></li>
<li><a class="reference internal" href="#ptr-reset">Ptr::reset</a></li>
<li><a class="reference internal" href="#ptr-swap">Ptr::swap</a></li>
<li><a class="reference internal" href="#ptr-get">Ptr::get</a></li>
<li><a class="reference internal" href="#ptr-pointer-emulation">Ptr pointer emulation</a></li>
<li><a class="reference internal" href="#ptr-empty">Ptr::empty</a></li>
<li><a class="reference internal" href="#ptr-casts">Ptr casts</a></li>
<li><a class="reference internal" href="#ptr-global-swap">Ptr global swap</a></li>
<li><a class="reference internal" href="#ptr-comparisons">Ptr comparisons</a></li>
<li><a class="reference internal" href="#makeptr">makePtr</a></li>
<li><a class="reference internal" href="#mat">Mat</a></li>
<li><a class="reference internal" href="#matrix-expressions">Matrix Expressions</a></li>
<li><a class="reference internal" href="#mat-mat">Mat::Mat</a></li>
<li><a class="reference internal" href="#id1">Mat::~Mat</a></li>
<li><a class="reference internal" href="#mat-operator">Mat::operator =</a></li>
<li><a class="reference internal" href="#mat-row">Mat::row</a></li>
<li><a class="reference internal" href="#mat-col">Mat::col</a></li>
<li><a class="reference internal" href="#mat-rowrange">Mat::rowRange</a></li>
<li><a class="reference internal" href="#mat-colrange">Mat::colRange</a></li>
<li><a class="reference internal" href="#mat-diag">Mat::diag</a></li>
<li><a class="reference internal" href="#mat-clone">Mat::clone</a></li>
<li><a class="reference internal" href="#mat-copyto">Mat::copyTo</a></li>
<li><a class="reference internal" href="#mat-convertto">Mat::convertTo</a></li>
<li><a class="reference internal" href="#mat-assignto">Mat::assignTo</a></li>
<li><a class="reference internal" href="#mat-setto">Mat::setTo</a></li>
<li><a class="reference internal" href="#mat-reshape">Mat::reshape</a></li>
<li><a class="reference internal" href="#mat-t">Mat::t</a></li>
<li><a class="reference internal" href="#mat-inv">Mat::inv</a></li>
<li><a class="reference internal" href="#mat-mul">Mat::mul</a></li>
<li><a class="reference internal" href="#mat-cross">Mat::cross</a></li>
<li><a class="reference internal" href="#mat-dot">Mat::dot</a></li>
<li><a class="reference internal" href="#mat-zeros">Mat::zeros</a></li>
<li><a class="reference internal" href="#mat-ones">Mat::ones</a></li>
<li><a class="reference internal" href="#mat-eye">Mat::eye</a></li>
<li><a class="reference internal" href="#mat-create">Mat::create</a></li>
<li><a class="reference internal" href="#mat-addref">Mat::addref</a></li>
<li><a class="reference internal" href="#mat-release">Mat::release</a></li>
<li><a class="reference internal" href="#mat-resize">Mat::resize</a></li>
<li><a class="reference internal" href="#mat-reserve">Mat::reserve</a></li>
<li><a class="reference internal" href="#mat-push-back">Mat::push_back</a></li>
<li><a class="reference internal" href="#mat-pop-back">Mat::pop_back</a></li>
<li><a class="reference internal" href="#mat-locateroi">Mat::locateROI</a></li>
<li><a class="reference internal" href="#mat-adjustroi">Mat::adjustROI</a></li>
<li><a class="reference internal" href="#id3">Mat::operator()</a></li>
<li><a class="reference internal" href="#mat-total">Mat::total</a></li>
<li><a class="reference internal" href="#mat-iscontinuous">Mat::isContinuous</a></li>
<li><a class="reference internal" href="#mat-elemsize">Mat::elemSize</a></li>
<li><a class="reference internal" href="#mat-elemsize1">Mat::elemSize1</a></li>
<li><a class="reference internal" href="#mat-type">Mat::type</a></li>
<li><a class="reference internal" href="#mat-depth">Mat::depth</a></li>
<li><a class="reference internal" href="#mat-channels">Mat::channels</a></li>
<li><a class="reference internal" href="#mat-step1">Mat::step1</a></li>
<li><a class="reference internal" href="#mat-size">Mat::size</a></li>
<li><a class="reference internal" href="#mat-empty">Mat::empty</a></li>
<li><a class="reference internal" href="#mat-ptr">Mat::ptr</a></li>
<li><a class="reference internal" href="#mat-at">Mat::at</a></li>
<li><a class="reference internal" href="#mat-begin">Mat::begin</a></li>
<li><a class="reference internal" href="#mat-end">Mat::end</a></li>
<li><a class="reference internal" href="#mat-foreach">Mat::forEach</a></li>
<li><a class="reference internal" href="#id4">Mat_</a></li>
<li><a class="reference internal" href="#inputarray">InputArray</a></li>
<li><a class="reference internal" href="#outputarray">OutputArray</a></li>
<li><a class="reference internal" href="#narymatiterator">NAryMatIterator</a></li>
<li><a class="reference internal" href="#sparsemat">SparseMat</a></li>
<li><a class="reference internal" href="#sparsemat-sparsemat">SparseMat::SparseMat</a></li>
<li><a class="reference internal" href="#id5">SparseMat::~SparseMat</a></li>
<li><a class="reference internal" href="#sparsemat-operator">SparseMat::operator=</a></li>
<li><a class="reference internal" href="#sparsemat-clone">SparseMat::clone</a></li>
<li><a class="reference internal" href="#sparsemat-copyto">SparseMat::copyTo</a></li>
<li><a class="reference internal" href="#sparcemat-convertto">SparceMat::convertTo</a></li>
<li><a class="reference internal" href="#sparsemat-create">SparseMat:create</a></li>
<li><a class="reference internal" href="#sparsemat-clear">SparseMat::clear</a></li>
<li><a class="reference internal" href="#sparsemat-addref">SparseMat::addref</a></li>
<li><a class="reference internal" href="#sparsemat-release">SparseMat::release</a></li>
<li><a class="reference internal" href="#sparsemat-cvsparsemat">SparseMat::CvSparseMat *</a></li>
<li><a class="reference internal" href="#sparsemat-elemsize">SparseMat::elemSize</a></li>
<li><a class="reference internal" href="#sparsemat-elemsize1">SparseMat::elemSize1</a></li>
<li><a class="reference internal" href="#sparsemat-type">SparseMat::type</a></li>
<li><a class="reference internal" href="#sparsemat-depth">SparseMat::depth</a></li>
<li><a class="reference internal" href="#sparsemat-channels">SparseMat::channels</a></li>
<li><a class="reference internal" href="#sparsemat-size">SparseMat::size</a></li>
<li><a class="reference internal" href="#sparsemat-dims">SparseMat::dims</a></li>
<li><a class="reference internal" href="#sparsemat-nzcount">SparseMat::nzcount</a></li>
<li><a class="reference internal" href="#sparsemat-hash">SparseMat::hash</a></li>
<li><a class="reference internal" href="#sparsemat-ptr">SparseMat::ptr</a></li>
<li><a class="reference internal" href="#sparsemat-erase">SparseMat::erase</a></li>
<li><a class="reference internal" href="#id6">SparseMat_</a></li>
<li><a class="reference internal" href="#algorithm">Algorithm</a></li>
<li><a class="reference internal" href="#algorithm-name">Algorithm::name</a></li>
<li><a class="reference internal" href="#algorithm-get">Algorithm::get</a></li>
<li><a class="reference internal" href="#algorithm-set">Algorithm::set</a></li>
<li><a class="reference internal" href="#algorithm-write">Algorithm::write</a></li>
<li><a class="reference internal" href="#algorithm-read">Algorithm::read</a></li>
<li><a class="reference internal" href="#algorithm-getlist">Algorithm::getList</a></li>
<li><a class="reference internal" href="#algorithm-create">Algorithm::create</a></li>
<li><a class="reference internal" href="#creating-own-algorithms">Creating Own Algorithms</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="core.html" title="previous chapter">core. The Core Functionality</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="command_line_parser.html" title="next chapter">Command Line Parser</a></p>
        </div>
      </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-structures">
<h1>Basic Structures<a class="headerlink" href="#basic-structures" title="Permalink to this headline">¶</a></h1>
<div class="section" id="datatype">
<h2>DataType<a class="headerlink" href="#datatype" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DataType">
<em class="property">class </em><tt class="descname">DataType</tt><a class="headerlink" href="#DataType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template “trait” class for OpenCV primitive data types. A primitive OpenCV data type is one of <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, or a tuple of values of one of these types, where all the values in the tuple have the same type. Any primitive type from the list can be defined by an identifier in the form <tt class="docutils literal"><span class="pre">CV_&lt;bit-depth&gt;{U|S|F}C(&lt;number_of_channels&gt;)</span></tt>, for example: <tt class="docutils literal"><span class="pre">uchar</span></tt> ~ <tt class="docutils literal"><span class="pre">CV_8UC1</span></tt>, 3-element floating-point tuple ~ <tt class="docutils literal"><span class="pre">CV_32FC3</span></tt>, and so on. A universal OpenCV structure that is able to store a single instance of such a primitive data type is
<a class="reference internal" href="#Vec" title="class Vec"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Vec</span></tt></a>. Multiple instances of such a type can be stored in a <tt class="docutils literal"><span class="pre">std::vector</span></tt>, <tt class="docutils literal"><span class="pre">Mat</span></tt>, <tt class="docutils literal"><span class="pre">Mat_</span></tt>, <tt class="docutils literal"><span class="pre">SparseMat</span></tt>, <tt class="docutils literal"><span class="pre">SparseMat_</span></tt>, or any other container that is able to store <tt class="docutils literal"><span class="pre">Vec</span></tt> instances.</p>
<p>The <tt class="docutils literal"><span class="pre">DataType</span></tt> class is basically used to provide a description of such primitive data types without adding any fields or methods to the corresponding classes (and it is actually impossible to add anything to primitive C/C++ data types). This technique is known in C++ as class traits. It is not <tt class="docutils literal"><span class="pre">DataType</span></tt> itself that is used but its specialized versions, such as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">class</span> <span class="nc">DataType</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">uchar</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">work_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">uchar</span> <span class="n">channel_type</span><span class="p">;</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">channel_type</span> <span class="o">=</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="sc">'u'</span><span class="p">,</span> <span class="n">type</span> <span class="o">=</span> <span class="n">CV_8U</span> <span class="p">};</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">work_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">channel_type</span><span class="p">;</span>
    <span class="c1">// DataDepth is another helper trait class</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">DataDepth</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">fmt</span><span class="o">=</span><span class="p">(</span><span class="n">channels</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">256</span><span class="o">+</span><span class="n">DataDepth</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">fmt</span><span class="p">,</span>
        <span class="n">type</span><span class="o">=</span><span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span> <span class="p">};</span>
<span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The main purpose of this class is to convert compilation-time type information to an OpenCV-compatible data type identifier, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// allocates a 30x40 floating-point matrix</span>
<span class="n">Mat</span> <span class="nf">A</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">);</span>

<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Mat_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="c1">// the statement below will print 6, 2 /*, that is depth == CV_64F, channels == 2 */</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">channels</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>So, such traits are used to tell OpenCV which data type you are working with, even if such a type is not native to OpenCV. For example, the matrix <tt class="docutils literal"><span class="pre">B</span></tt> initialization above is compiled because OpenCV defines the proper specialized template class <tt class="docutils literal"><span class="pre">DataType&lt;complex&lt;_Tp&gt;</span> <span class="pre">&gt;</span></tt> . This mechanism is also useful (and used in OpenCV this way) for generic algorithms implementations.</p>
</div>
<div class="section" id="point">
<h2>Point_<a class="headerlink" href="#point" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Point_">
<em class="property">class </em><tt class="descname">Point_</tt><a class="headerlink" href="#Point_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Point_</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">// various constructors</span>
    <span class="n">Point_</span><span class="p">();</span>
    <span class="n">Point_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint2D32f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Point_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="n">Point_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to the old-style C structures</span>
    <span class="k">operator</span> <span class="n">CvPoint</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="n">CvPoint2D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product</span>
    <span class="n">_Tp</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="n">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! cross-product</span>
    <span class="kt">double</span> <span class="n">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! checks whether the point is inside the specified rectangle</span>
    <span class="kt">bool</span> <span class="n">inside</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="c1">//&lt; the point coordinates</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 2D points specified by its coordinates
<img class="math" src="../../../_images/math/275d1cfd2234a22c171bcf9ee37dd451fffd5e1b.png" alt="x"> and
<img class="math" src="../../../_images/math/8be61bd3f15e9c74771dd331d4fee2be8dbe30d5.png" alt="y"> .
An instance of the class is interchangeable with C structures, <tt class="docutils literal"><span class="pre">CvPoint</span></tt> and <tt class="docutils literal"><span class="pre">CvPoint2D32f</span></tt> . There is also a cast operator to convert point coordinates to the specified type. The conversion from floating-point coordinates to integer coordinates is done by rounding. Commonly, the conversion uses this
operation for each of the coordinates. Besides the class members listed in the declaration above, the following operations on points are implemented:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">+</span> <span class="n">pt3</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">-</span> <span class="n">pt3</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">+=</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">-=</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">*=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">/=</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span> <span class="c1">// L2 norm</span>
<span class="n">pt1</span> <span class="o">==</span> <span class="n">pt2</span><span class="p">;</span>
<span class="n">pt1</span> <span class="o">!=</span> <span class="n">pt2</span><span class="p">;</span>
</pre></div>
</div>
<p>For your convenience, the following type aliases are defined:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Point2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point2i</span> <span class="n">Point</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Point2d</span><span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Point2f</span> <span class="nf">a</span><span class="p">(</span><span class="mf">0.3f</span><span class="p">,</span> <span class="mf">0.f</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mf">0.f</span><span class="p">,</span> <span class="mf">0.4f</span><span class="p">);</span>
<span class="n">Point</span> <span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="mf">10.f</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="point3">
<h2>Point3_<a class="headerlink" href="#point3" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Point3_">
<em class="property">class </em><tt class="descname">Point3_</tt><a class="headerlink" href="#Point3_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Point3_</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">// various constructors</span>
    <span class="n">Point3_</span><span class="p">();</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_z</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="k">explicit</span> <span class="nf">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvPoint3D32f</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="n">Point3_</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>

    <span class="n">Point3_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">);</span>
    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvPoint...</span>
    <span class="k">operator</span> <span class="n">CvPoint3D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to cv::Vec&lt;&gt;</span>
    <span class="k">operator</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! dot product</span>
    <span class="n">_Tp</span> <span class="n">dot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! dot product computed in double-precision arithmetics</span>
    <span class="kt">double</span> <span class="n">ddot</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! cross product of the 2 3D points</span>
    <span class="n">Point3_</span> <span class="n">cross</span><span class="p">(</span><span class="k">const</span> <span class="n">Point3_</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="c1">//&lt; the point coordinates</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 3D points specified by its coordinates
<img class="math" src="../../../_images/math/275d1cfd2234a22c171bcf9ee37dd451fffd5e1b.png" alt="x">,
<img class="math" src="../../../_images/math/8be61bd3f15e9c74771dd331d4fee2be8dbe30d5.png" alt="y"> and
<img class="math" src="../../../_images/math/14e25445812dd6114e136478c67a95cbbf223228.png" alt="z"> .
An instance of the class is interchangeable with the C structure <tt class="docutils literal"><span class="pre">CvPoint2D32f</span></tt> . Similarly to <tt class="docutils literal"><span class="pre">Point_</span></tt> , the coordinates of 3D points can be converted to another type. The vector arithmetic and comparison operations are also supported.</p>
<p>The following <tt class="docutils literal"><span class="pre">Point3_&lt;&gt;</span></tt> aliases are available:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Point3i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Point3f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Point3d</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="size">
<h2>Size_<a class="headerlink" href="#size" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Size_">
<em class="property">class </em><tt class="descname">Size_</tt><a class="headerlink" href="#Size_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Size_</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! various constructors</span>
    <span class="n">Size_</span><span class="p">();</span>
    <span class="n">Size_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_height</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSize</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSize2D32f</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Size_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">);</span>

    <span class="n">Size_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Size_</span><span class="o">&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="c1">//! the area (width*height)</span>
    <span class="n">_Tp</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion of another data type.</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to the old-style OpenCV types</span>
    <span class="k">operator</span> <span class="n">CvSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="n">CvSize2D32f</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span> <span class="c1">// the width and the height</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for specifying the size of an image or rectangle. The class includes two members called <tt class="docutils literal"><span class="pre">width</span></tt> and <tt class="docutils literal"><span class="pre">height</span></tt>. The structure can be converted to and from the old OpenCV structures
<tt class="docutils literal"><span class="pre">CvSize</span></tt> and <tt class="docutils literal"><span class="pre">CvSize2D32f</span></tt> . The same set of arithmetic and comparison operations as for <tt class="docutils literal"><span class="pre">Point_</span></tt> is available.</p>
<p>OpenCV defines the following <tt class="docutils literal"><span class="pre">Size_&lt;&gt;</span></tt> aliases:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Size2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size2i</span> <span class="n">Size</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">Size2f</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rect">
<h2>Rect_<a class="headerlink" href="#rect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Rect_">
<em class="property">class </em><tt class="descname">Rect_</tt><a class="headerlink" href="#Rect_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Rect_</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">_Tp</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="c1">//! various constructors</span>
    <span class="n">Rect_</span><span class="p">();</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_y</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_width</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">_height</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvRect</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">org</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">Rect_</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt2</span><span class="p">);</span>

    <span class="n">Rect_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">Rect_</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>
    <span class="c1">//! the top-left corner</span>
    <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">tl</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! the bottom-right corner</span>
    <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">br</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! size (width, height) of the rectangle</span>
    <span class="n">Size_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! area (width*height) of the rectangle</span>
    <span class="n">_Tp</span> <span class="n">area</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvRect</span>
    <span class="k">operator</span> <span class="n">CvRect</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! checks whether the rectangle contains the point</span>
    <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">Point_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">_Tp</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span> <span class="c1">//&lt; the top-left corner, as well as width and height of the rectangle</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Template class for 2D rectangles, described by the following parameters:</p>
<ul class="simple">
<li>Coordinates of the top-left corner. This is a default interpretation of <tt class="docutils literal"><span class="pre">Rect_::x</span></tt> and <tt class="docutils literal"><span class="pre">Rect_::y</span></tt> in OpenCV. Though, in your algorithms you may count <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> from the bottom-left corner.</li>
<li>Rectangle width and height.</li>
</ul>
<p>OpenCV typically assumes that the top and left boundary of the rectangle are inclusive, while the right and bottom boundaries are not. For example, the method <tt class="docutils literal"><span class="pre">Rect_::contains</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> if</p>
<div class="math">
<p><img src="../../../_images/math/0bcc5289b0a19435c8979cf0cd750fcb21fc48b7.png" alt="x  \leq pt.x &lt; x+width,
      y  \leq pt.y &lt; y+height"></p>
</div><p>Virtually every loop over an image
ROI in OpenCV (where ROI is specified by <tt class="docutils literal"><span class="pre">Rect_&lt;int&gt;</span></tt> ) is implemented as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">roi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">roi</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">roi</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">roi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">roi</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">roi</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>In addition to the class members, the following operations on rectangles are implemented:</p>
<ul class="simple">
<li><img class="math" src="../../../_images/math/400e9a15c0c2197a2e69e05bf02e3c9c5282eaa6.png" alt="\texttt{rect} = \texttt{rect} \pm \texttt{point}">     (shifting a rectangle by a certain offset)</li>
<li><img class="math" src="../../../_images/math/871857cb8b0391e93cb390210103e7a846d4b5ad.png" alt="\texttt{rect} = \texttt{rect} \pm \texttt{size}">     (expanding or shrinking a rectangle by a certain amount)</li>
<li><tt class="docutils literal"><span class="pre">rect</span> <span class="pre">+=</span> <span class="pre">point,</span> <span class="pre">rect</span> <span class="pre">-=</span> <span class="pre">point,</span> <span class="pre">rect</span> <span class="pre">+=</span> <span class="pre">size,</span> <span class="pre">rect</span> <span class="pre">-=</span> <span class="pre">size</span></tt>     (augmenting operations)</li>
<li><tt class="docutils literal"><span class="pre">rect</span> <span class="pre">=</span> <span class="pre">rect1</span> <span class="pre">&amp;</span> <span class="pre">rect2</span></tt>     (rectangle intersection)</li>
<li><tt class="docutils literal"><span class="pre">rect</span> <span class="pre">=</span> <span class="pre">rect1</span> <span class="pre">|</span> <span class="pre">rect2</span></tt>     (minimum area rectangle containing <tt class="docutils literal"><span class="pre">rect1</span></tt>     and <tt class="docutils literal"><span class="pre">rect2</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">rect</span> <span class="pre">&amp;=</span> <span class="pre">rect1,</span> <span class="pre">rect</span> <span class="pre">|=</span> <span class="pre">rect1</span></tt>     (and the corresponding augmenting operations)</li>
<li><tt class="docutils literal"><span class="pre">rect</span> <span class="pre">==</span> <span class="pre">rect1,</span> <span class="pre">rect</span> <span class="pre">!=</span> <span class="pre">rect1</span></tt>     (rectangle comparison)</li>
</ul>
<p>This is an example how the partial ordering on rectangles can be established (rect1
<img class="math" src="../../../_images/math/37e2ff831976855edf17c4763e3cdce5befc08f2.png" alt="\subseteq"> rect2):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kr">inline</span> <span class="kt">bool</span>
<span class="k">operator</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">r2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&amp;</span> <span class="n">r2</span><span class="p">)</span> <span class="o">==</span> <span class="n">r1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For your convenience, the <tt class="docutils literal"><span class="pre">Rect_&lt;&gt;</span></tt> alias is available:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">Rect_</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Rect</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="rotatedrect">
<h2>RotatedRect<a class="headerlink" href="#rotatedrect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="RotatedRect">
<em class="property">class </em><tt class="descname">RotatedRect</tt><a class="headerlink" href="#RotatedRect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">RotatedRect</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//! various constructors</span>
    <span class="n">RotatedRect</span><span class="p">();</span>
    <span class="n">RotatedRect</span><span class="p">(</span><span class="k">const</span> <span class="n">Point2f</span><span class="o">&amp;</span> <span class="n">center</span><span class="p">,</span> <span class="k">const</span> <span class="n">Size2f</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">,</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">);</span>
    <span class="n">RotatedRect</span><span class="p">(</span><span class="k">const</span> <span class="n">CvBox2D</span><span class="o">&amp;</span> <span class="n">box</span><span class="p">);</span>
    <span class="n">RotatedRect</span><span class="p">(</span><span class="k">const</span> <span class="n">Point2f</span><span class="o">&amp;</span> <span class="n">point1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point2f</span><span class="o">&amp;</span> <span class="n">point2</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point2f</span><span class="o">&amp;</span> <span class="n">point3</span><span class="p">);</span>

    <span class="c1">//! returns 4 vertices of the rectangle</span>
    <span class="kt">void</span> <span class="n">points</span><span class="p">(</span><span class="n">Point2f</span> <span class="n">pts</span><span class="p">[])</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! returns the minimal up-right rectangle containing the rotated rectangle</span>
    <span class="n">Rect</span> <span class="n">boundingRect</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//! conversion to the old-style CvBox2D structure</span>
    <span class="k">operator</span> <span class="n">CvBox2D</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">Point2f</span> <span class="n">center</span><span class="p">;</span> <span class="c1">//&lt; the rectangle mass center</span>
    <span class="n">Size2f</span> <span class="n">size</span><span class="p">;</span>    <span class="c1">//&lt; width and height of the rectangle</span>
    <span class="kt">float</span> <span class="n">angle</span><span class="p">;</span>    <span class="c1">//&lt; the rotation angle. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class represents rotated (i.e. not up-right) rectangles on a plane. Each rectangle is specified by the center point (mass center), length of each side (represented by cv::Size2f structure) and the rotation angle in degrees.</p>
<blockquote>
<div><dl class="function">
<dt id="RotatedRect::RotatedRect()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RotatedRect::</tt><tt class="descname">RotatedRect</tt><big>(</big><big>)</big><a class="headerlink" href="#RotatedRect::RotatedRect()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="RotatedRect::RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RotatedRect::</tt><tt class="descname">RotatedRect</tt><big>(</big>const Point2f&amp; <strong>center</strong>, const Size2f&amp; <strong>size</strong>, float <strong>angle</strong><big>)</big><a class="headerlink" href="#RotatedRect::RotatedRect(const Point2f&amp; center, const Size2f&amp; size, float angle)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>center</strong> – The rectangle mass center.</li>
<li><strong>size</strong> – Width and height of the rectangle.</li>
<li><strong>angle</strong> – The rotation angle in a clockwise direction. When the angle is 0, 90, 180, 270 etc., the rectangle becomes an up-right rectangle.</li>
<li><strong>box</strong> – The rotated rectangle parameters as the obsolete CvBox2D structure.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RotatedRect::RotatedRect(const Point2f&amp; point1, const Point2f&amp; point2, const Point2f&amp; point3)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">RotatedRect::</tt><tt class="descname">RotatedRect</tt><big>(</big>const Point2f&amp; <strong>point1</strong>, const Point2f&amp; <strong>point2</strong>, const Point2f&amp; <strong>point3</strong><big>)</big><a class="headerlink" href="#RotatedRect::RotatedRect(const Point2f&amp; point1, const Point2f&amp; point2, const Point2f&amp; point3)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>point1</strong> – </li>
<li><strong>point2</strong> – </li>
<li><strong>point3</strong> – Any 3 end points of the RotatedRect. They must be given in order (either clockwise or anticlockwise).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="void RotatedRect::points(Point2f pts[]) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">RotatedRect::</tt><tt class="descname">points</tt><big>(</big>Point2f <strong>pts</strong>[]<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void RotatedRect::points(Point2f pts[]) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Rect RotatedRect::boundingRect() const">
<strong>C++:</strong><tt class="descname"> </tt>Rect <tt class="descclassname">RotatedRect::</tt><tt class="descname">boundingRect</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Rect RotatedRect::boundingRect() const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pts</strong> – The points array for storing rectangle vertices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div></blockquote>
<p>The sample below demonstrates how to use RotatedRect:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">image</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">RotatedRect</span> <span class="n">rRect</span> <span class="o">=</span> <span class="n">RotatedRect</span><span class="p">(</span><span class="n">Point2f</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">Size2f</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">),</span> <span class="mi">30</span><span class="p">);</span>

<span class="n">Point2f</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">rRect</span><span class="p">.</span><span class="n">points</span><span class="p">(</span><span class="n">vertices</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">line</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">vertices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">],</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">Rect</span> <span class="n">brect</span> <span class="o">=</span> <span class="n">rRect</span><span class="p">.</span><span class="n">boundingRect</span><span class="p">();</span>
<span class="n">rectangle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">brect</span><span class="p">,</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="n">imshow</span><span class="p">(</span><span class="s">"rectangles"</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
<span class="n">waitKey</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<img alt="../../../_images/rotatedrect.png" src="../../../_images/rotatedrect.png">
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../video/doc/motion_analysis_and_object_tracking.html#RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">CamShift()</span></tt></a> ,
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect fitEllipse(InputArray points)" title="RotatedRect fitEllipse(InputArray points)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">fitEllipse()</span></tt></a> ,
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect minAreaRect(InputArray points)" title="RotatedRect minAreaRect(InputArray points)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">minAreaRect()</span></tt></a> ,
<a class="reference internal" href="old_basic_structures.html#CvBox2D" title="struct CvBox2D"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvBox2D</span></tt></a></p>
</div>
</div>
<div class="section" id="termcriteria">
<h2>TermCriteria<a class="headerlink" href="#termcriteria" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="TermCriteria">
<em class="property">class </em><tt class="descname">TermCriteria</tt><a class="headerlink" href="#TermCriteria" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">TermCriteria</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">COUNT</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="c1">//!&lt; the maximum number of iterations or elements to compute</span>
        <span class="n">MAX_ITER</span><span class="o">=</span><span class="n">COUNT</span><span class="p">,</span> <span class="c1">//!&lt; ditto</span>
        <span class="n">EPS</span><span class="o">=</span><span class="mi">2</span> <span class="c1">//!&lt; the desired accuracy or change in parameters at which the iterative algorithm stops</span>
    <span class="p">};</span>

    <span class="c1">//! default constructor</span>
    <span class="n">TermCriteria</span><span class="p">();</span>
    <span class="c1">//! full constructor</span>
    <span class="n">TermCriteria</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxCount</span><span class="p">,</span> <span class="kt">double</span> <span class="n">epsilon</span><span class="p">);</span>
    <span class="c1">//! conversion from CvTermCriteria</span>
    <span class="n">TermCriteria</span><span class="p">(</span><span class="k">const</span> <span class="n">CvTermCriteria</span><span class="o">&amp;</span> <span class="n">criteria</span><span class="p">);</span>
    <span class="c1">//! conversion to CvTermCriteria</span>
    <span class="k">operator</span> <span class="n">CvTermCriteria</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">type</span><span class="p">;</span> <span class="c1">//!&lt; the type of termination criteria: COUNT, EPS or COUNT + EPS</span>
    <span class="kt">int</span> <span class="n">maxCount</span><span class="p">;</span> <span class="c1">// the maximum number of iterations/elements</span>
    <span class="kt">double</span> <span class="n">epsilon</span><span class="p">;</span> <span class="c1">// the desired accuracy</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class defining termination criteria for iterative algorithms. You can initialize it by default constructor and then override any parameters, or the structure may be fully initialized using the advanced variant of the constructor.</p>
</div>
<div class="section" id="termcriteria-termcriteria">
<h2>TermCriteria::TermCriteria<a class="headerlink" href="#termcriteria-termcriteria" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="TermCriteria::TermCriteria()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">TermCriteria::</tt><tt class="descname">TermCriteria</tt><big>(</big><big>)</big><a class="headerlink" href="#TermCriteria::TermCriteria()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TermCriteria::TermCriteria(int type, int maxCount, double epsilon)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">TermCriteria::</tt><tt class="descname">TermCriteria</tt><big>(</big>int <strong>type</strong>, int <strong>maxCount</strong>, double <strong>epsilon</strong><big>)</big><a class="headerlink" href="#TermCriteria::TermCriteria(int type, int maxCount, double epsilon)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>type</strong> – The type of termination criteria: <tt class="docutils literal"><span class="pre">TermCriteria::COUNT</span></tt>, <tt class="docutils literal"><span class="pre">TermCriteria::EPS</span></tt> or <tt class="docutils literal"><span class="pre">TermCriteria::COUNT</span></tt> + <tt class="docutils literal"><span class="pre">TermCriteria::EPS</span></tt>.</li>
<li><strong>maxCount</strong> – The maximum number of iterations or elements to compute.</li>
<li><strong>epsilon</strong> – The desired accuracy or change in parameters at which the iterative algorithm stops.</li>
<li><strong>criteria</strong> – Termination criteria in the deprecated <tt class="docutils literal"><span class="pre">CvTermCriteria</span></tt> format.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="matx">
<h2>Matx<a class="headerlink" href="#matx" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Matx">
<em class="property">class </em><tt class="descname">Matx</tt><a class="headerlink" href="#Matx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for small matrices whose type and size are known at compilation time:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Matx</span> <span class="p">{...};</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx12d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx16d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx21d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">Matx61d</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Matx22d</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Matx66d</span><span class="p">;</span>
</pre></div>
</div>
<p>If you need a more flexible type, use <a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> . The elements of the matrix <tt class="docutils literal"><span class="pre">M</span></tt> are accessible using the <tt class="docutils literal"><span class="pre">M(i,j)</span></tt> notation. Most of the common matrix operations (see also
<a class="reference internal" href="#matrixexpressions"><em>Matrix Expressions</em></a> ) are available. To do an operation on <tt class="docutils literal"><span class="pre">Matx</span></tt> that is not implemented, you can easily convert the matrix to
<tt class="docutils literal"><span class="pre">Mat</span></tt> and backwards.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Matx33f</span> <span class="nf">m</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
          <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
          <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="n">Mat</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">t</span><span class="p">()))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Vec">
<em class="property">class </em><tt class="descname">Vec</tt><a class="headerlink" href="#Vec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for short numerical vectors, a partial case of <a class="reference internal" href="#Matx" title="class Matx"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Matx</span></tt></a>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Vec</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Matx</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="p">{...};</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3b</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4b</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3s</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">short</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4s</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3i</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4i</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4f</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6f</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Vec2d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">Vec3d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Vec4d</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">Vec6d</span><span class="p">;</span>
</pre></div>
</div>
<p>It is possible to convert <tt class="docutils literal"><span class="pre">Vec&lt;T,2&gt;</span></tt> to/from <tt class="docutils literal"><span class="pre">Point_</span></tt>, <tt class="docutils literal"><span class="pre">Vec&lt;T,3&gt;</span></tt> to/from <tt class="docutils literal"><span class="pre">Point3_</span></tt> , and <tt class="docutils literal"><span class="pre">Vec&lt;T,4&gt;</span></tt> to <a class="reference internal" href="old_basic_structures.html#CvScalar" title="struct CvScalar"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvScalar</span></tt></a> or <a class="reference internal" href="#Scalar_" title="class Scalar_"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Scalar_</span></tt></a>. Use <tt class="docutils literal"><span class="pre">operator[]</span></tt> to access the elements of <tt class="docutils literal"><span class="pre">Vec</span></tt>.</p>
<p>All the expected vector operations are also implemented:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">+</span> <span class="pre">v3</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">-</span> <span class="pre">v3</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">v2</span> <span class="pre">*</span> <span class="pre">scale</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">scale</span> <span class="pre">*</span> <span class="pre">v2</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">=</span> <span class="pre">-v2</span></tt></li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">+=</span> <span class="pre">v2</span></tt> and other augmenting operations</li>
<li><tt class="docutils literal"><span class="pre">v1</span> <span class="pre">==</span> <span class="pre">v2,</span> <span class="pre">v1</span> <span class="pre">!=</span> <span class="pre">v2</span></tt></li>
<li><tt class="docutils literal"><span class="pre">norm(v1)</span></tt>  (euclidean norm)</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">Vec</span></tt> class is commonly used to describe pixel types of multi-channel arrays. See <a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> for details.</p>
</div>
<div class="section" id="scalar">
<h2>Scalar_<a class="headerlink" href="#scalar" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Scalar_">
<em class="property">class </em><tt class="descname">Scalar_</tt><a class="headerlink" href="#Scalar_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for a 4-element vector derived from Vec.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Scalar_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//! various constructors</span>
    <span class="n">Scalar_</span><span class="p">();</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v1</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">_Tp</span> <span class="n">v3</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvScalar</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">Scalar_</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span>

    <span class="c1">//! returns a scalar with all elements set to v0</span>
    <span class="k">static</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">all</span><span class="p">(</span><span class="n">_Tp</span> <span class="n">v0</span><span class="p">);</span>
    <span class="c1">//! conversion to the old-style CvScalar</span>
    <span class="k">operator</span> <span class="n">CvScalar</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! conversion to another data type</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span> <span class="k">operator</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">//! per-element product</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">mul</span><span class="p">(</span><span class="k">const</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// returns (v0, -v1, -v2, -v3)</span>
    <span class="n">Scalar_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">conj</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// returns true iff v1 == v2 == v3 == 0</span>
    <span class="kt">bool</span> <span class="n">isReal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">Scalar_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">Scalar</span><span class="p">;</span>
</pre></div>
</div>
<p>Being derived from <tt class="docutils literal"><span class="pre">Vec&lt;_Tp,</span> <span class="pre">4&gt;</span></tt> , <tt class="docutils literal"><span class="pre">Scalar_</span></tt> and <tt class="docutils literal"><span class="pre">Scalar</span></tt> can be used just as typical 4-element vectors. In addition, they can be converted to/from <tt class="docutils literal"><span class="pre">CvScalar</span></tt> . The type <tt class="docutils literal"><span class="pre">Scalar</span></tt> is widely used in OpenCV to pass pixel values.</p>
</div>
<div class="section" id="range">
<h2>Range<a class="headerlink" href="#range" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Range">
<em class="property">class </em><tt class="descname">Range</tt><a class="headerlink" href="#Range" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class specifying a continuous subsequence (slice) of a sequence.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Range</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Range</span><span class="p">();</span>
    <span class="n">Range</span><span class="p">(</span><span class="kt">int</span> <span class="n">_start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_end</span><span class="p">);</span>
    <span class="n">Range</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSlice</span><span class="o">&amp;</span> <span class="n">slice</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Range</span> <span class="nf">all</span><span class="p">();</span>
    <span class="k">operator</span> <span class="n">CvSlice</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class is used to specify a row or a column span in a matrix (
<a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> ) and for many other purposes. <tt class="docutils literal"><span class="pre">Range(a,b)</span></tt> is basically the same as <tt class="docutils literal"><span class="pre">a:b</span></tt> in Matlab or <tt class="docutils literal"><span class="pre">a..b</span></tt> in Python. As in Python, <tt class="docutils literal"><span class="pre">start</span></tt> is an inclusive left boundary of the range and <tt class="docutils literal"><span class="pre">end</span></tt> is an exclusive right boundary of the range. Such a half-opened interval is usually denoted as
<img class="math" src="../../../_images/math/0a4e6a7a6a4ecef0aac03ae92bff26a7b07f152d.png" alt="[start,end)"> .</p>
<p>The static method <tt class="docutils literal"><span class="pre">Range::all()</span></tt> returns a special variable that means “the whole sequence” or “the whole range”, just like ” <tt class="docutils literal"><span class="pre">:</span></tt> ” in Matlab or ” <tt class="docutils literal"><span class="pre">...</span></tt> ” in Python. All the methods and functions in OpenCV that take <tt class="docutils literal"><span class="pre">Range</span></tt> support this special <tt class="docutils literal"><span class="pre">Range::all()</span></tt> value. But, of course, in case of your own custom processing, you will probably have to check and handle it explicitly:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">my_function</span><span class="p">(...,</span> <span class="k">const</span> <span class="n">Range</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="p">....)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// process all the data</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// process [r.start, r.end)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="keypoint">
<h2>KeyPoint<a class="headerlink" href="#keypoint" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="KeyPoint">
<em class="property">class </em><tt class="descname">KeyPoint</tt><a class="headerlink" href="#KeyPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Data structure for salient point detectors.</p>
<dl class="member">
<dt id="Point2f pt">
Point2f <tt class="descname">pt</tt><a class="headerlink" href="#Point2f pt" title="Permalink to this definition">¶</a></dt>
<dd><p>coordinates of the keypoint</p>
</dd></dl>

<dl class="member">
<dt id="float size">
float <tt class="descname">size</tt><a class="headerlink" href="#float size" title="Permalink to this definition">¶</a></dt>
<dd><p>diameter of the meaningful keypoint neighborhood</p>
</dd></dl>

<dl class="member">
<dt id="float angle">
float <tt class="descname">angle</tt><a class="headerlink" href="#float angle" title="Permalink to this definition">¶</a></dt>
<dd><p>computed orientation of the keypoint (-1 if not applicable). Its possible values are in a range [0,360) degrees. It is measured relative to image coordinate system (y-axis is directed downward), ie in clockwise.</p>
</dd></dl>

<dl class="member">
<dt id="float response">
float <tt class="descname">response</tt><a class="headerlink" href="#float response" title="Permalink to this definition">¶</a></dt>
<dd><p>the response by which the most strong keypoints have been selected. Can be used for further sorting or subsampling</p>
</dd></dl>

<dl class="member">
<dt id="int octave">
int <tt class="descname">octave</tt><a class="headerlink" href="#int octave" title="Permalink to this definition">¶</a></dt>
<dd><p>octave (pyramid layer) from which the keypoint has been extracted</p>
</dd></dl>

<dl class="member">
<dt id="int class_id">
int <tt class="descname">class_id</tt><a class="headerlink" href="#int class_id" title="Permalink to this definition">¶</a></dt>
<dd><p>object id that can be used to clustered keypoints by an object they belong to</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="keypoint-keypoint">
<h2>KeyPoint::KeyPoint<a class="headerlink" href="#keypoint-keypoint" title="Permalink to this headline">¶</a></h2>
<p>The keypoint constructors</p>
<dl class="function">
<dt id="KeyPoint::KeyPoint()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">KeyPoint::</tt><tt class="descname">KeyPoint</tt><big>(</big><big>)</big><a class="headerlink" href="#KeyPoint::KeyPoint()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">KeyPoint::</tt><tt class="descname">KeyPoint</tt><big>(</big>Point2f <strong>_pt</strong>, float <strong>_size</strong>, float <strong>_angle</strong>=-1, float <strong>_response</strong>=0, int <strong>_octave</strong>=0, int <strong>_class_id</strong>=-1<big>)</big><a class="headerlink" href="#KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">KeyPoint::</tt><tt class="descname">KeyPoint</tt><big>(</big>float <strong>x</strong>, float <strong>y</strong>, float <strong>_size</strong>, float <strong>_angle</strong>=-1, float <strong>_response</strong>=0, int <strong>_octave</strong>=0, int <strong>_class_id</strong>=-1<big>)</big><a class="headerlink" href="#KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKeyPoint"></a><dt id="cv2.KeyPoint">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">KeyPoint</tt><big>(</big><span class="optional">[</span>x, y, _size<span class="optional">[</span>, _angle<span class="optional">[</span>, _response<span class="optional">[</span>, _octave<span class="optional">[</span>, _class_id<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → &lt;KeyPoint object&gt;<a class="headerlink" href="#cv2.KeyPoint" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – x-coordinate of the keypoint</li>
<li><strong>y</strong> – y-coordinate of the keypoint</li>
<li><strong>_pt</strong> – x &amp; y coordinates of the keypoint</li>
<li><strong>_size</strong> – keypoint diameter</li>
<li><strong>_angle</strong> – keypoint orientation</li>
<li><strong>_response</strong> – keypoint detector response on the keypoint (that is, strength of the keypoint)</li>
<li><strong>_octave</strong> – pyramid octave in which the keypoint has been detected</li>
<li><strong>_class_id</strong> – object id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="keypoint-convert">
<h2>KeyPoint::convert<a class="headerlink" href="#keypoint-convert" title="Permalink to this headline">¶</a></h2>
<p>This method converts vector of keypoints to vector of points or the reverse, where each keypoint is assigned the same size and the same orientation.</p>
<dl class="function">
<dt id="void KeyPoint::convert(const std::vector&lt;KeyPoint&gt;&amp; keypoints, std::vector&lt;Point2f&gt;&amp; points2f, const std::vector&lt;int&gt;&amp; keypointIndexes)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">KeyPoint::</tt><tt class="descname">convert</tt><big>(</big>const std::vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, std::vector&lt;Point2f&gt;&amp; <strong>points2f</strong>, const std::vector&lt;int&gt;&amp; <strong>keypointIndexes</strong>=std::vector&lt;int&gt;()<big>)</big><a class="headerlink" href="#void KeyPoint::convert(const std::vector&lt;KeyPoint&gt;&amp; keypoints, std::vector&lt;Point2f&gt;&amp; points2f, const std::vector&lt;int&gt;&amp; keypointIndexes)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void KeyPoint::convert(const std::vector&lt;Point2f&gt;&amp; points2f, std::vector&lt;KeyPoint&gt;&amp; keypoints, float size, float response, int octave, int class_id)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">KeyPoint::</tt><tt class="descname">convert</tt><big>(</big>const std::vector&lt;Point2f&gt;&amp; <strong>points2f</strong>, std::vector&lt;KeyPoint&gt;&amp; <strong>keypoints</strong>, float <strong>size</strong>=1, float <strong>response</strong>=1, int <strong>octave</strong>=0, int <strong>class_id</strong>=-1<big>)</big><a class="headerlink" href="#void KeyPoint::convert(const std::vector&lt;Point2f&gt;&amp; points2f, std::vector&lt;KeyPoint&gt;&amp; keypoints, float size, float response, int octave, int class_id)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKeyPoint%5Fconvert"></a><dt id="cv2.KeyPoint_convert">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">KeyPoint_convert</tt><big>(</big>keypoints<span class="optional">[</span>, keypointIndexes<span class="optional">]</span><big>)</big> → points2f<a class="headerlink" href="#cv2.KeyPoint_convert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<dt>
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">KeyPoint_convert</tt><big>(</big>points2f<span class="optional">[</span>, size<span class="optional">[</span>, response<span class="optional">[</span>, octave<span class="optional">[</span>, class_id<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → keypoints</dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>keypoints</strong> – Keypoints obtained from any feature detection algorithm like SIFT/SURF/ORB</li>
<li><strong>points2f</strong> – Array of (x,y) coordinates of each keypoint</li>
<li><strong>keypointIndexes</strong> – Array of indexes of keypoints to be converted to points. (Acts like a mask to convert only specified keypoints)</li>
<li><strong>_size</strong> – keypoint diameter</li>
<li><strong>_response</strong> – keypoint detector response on the keypoint (that is, strength of the keypoint)</li>
<li><strong>_octave</strong> – pyramid octave in which the keypoint has been detected</li>
<li><strong>_class_id</strong> – object id</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="keypoint-overlap">
<h2>KeyPoint::overlap<a class="headerlink" href="#keypoint-overlap" title="Permalink to this headline">¶</a></h2>
<p>This method computes overlap for pair of keypoints. Overlap is the ratio between area of keypoint regions’ intersection and area of keypoint regions’ union (considering keypoint region as circle). If they don’t overlap, we get zero. If they coincide at same location with same size, we get 1.</p>
<dl class="function">
<dt id="float KeyPoint::overlap(const KeyPoint&amp; kp1, const KeyPoint&amp; kp2)">
<strong>C++:</strong><tt class="descname"> </tt>float <tt class="descclassname">KeyPoint::</tt><tt class="descname">overlap</tt><big>(</big>const KeyPoint&amp; <strong>kp1</strong>, const KeyPoint&amp; <strong>kp2</strong><big>)</big><a class="headerlink" href="#float KeyPoint::overlap(const KeyPoint&amp; kp1, const KeyPoint&amp; kp2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKeyPoint%5Foverlap"></a><dt id="cv2.KeyPoint_overlap">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">KeyPoint_overlap</tt><big>(</big>kp1, kp2<big>)</big> → retval<a class="headerlink" href="#cv2.KeyPoint_overlap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>kp1</strong> – First keypoint</li>
<li><strong>kp2</strong> – Second keypoint</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="dmatch">
<h2>DMatch<a class="headerlink" href="#dmatch" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="DMatch">
<em class="property">class </em><tt class="descname">DMatch</tt><a class="headerlink" href="#DMatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Class for matching keypoint descriptors: query descriptor index,
train descriptor index, train image index, and distance between descriptors.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DMatch</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">DMatch</span><span class="p">()</span> <span class="o">:</span> <span class="n">queryIdx</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">trainIdx</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">imgIdx</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
               <span class="n">distance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span> <span class="p">{}</span>
    <span class="n">DMatch</span><span class="p">(</span> <span class="kt">int</span> <span class="n">_queryIdx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_trainIdx</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_distance</span> <span class="p">)</span> <span class="o">:</span>
            <span class="n">queryIdx</span><span class="p">(</span><span class="n">_queryIdx</span><span class="p">),</span> <span class="n">trainIdx</span><span class="p">(</span><span class="n">_trainIdx</span><span class="p">),</span> <span class="n">imgIdx</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">distance</span><span class="p">(</span><span class="n">_distance</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">DMatch</span><span class="p">(</span> <span class="kt">int</span> <span class="n">_queryIdx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_trainIdx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_imgIdx</span><span class="p">,</span> <span class="kt">float</span> <span class="n">_distance</span> <span class="p">)</span> <span class="o">:</span>
            <span class="n">queryIdx</span><span class="p">(</span><span class="n">_queryIdx</span><span class="p">),</span> <span class="n">trainIdx</span><span class="p">(</span><span class="n">_trainIdx</span><span class="p">),</span> <span class="n">imgIdx</span><span class="p">(</span><span class="n">_imgIdx</span><span class="p">),</span>
            <span class="n">distance</span><span class="p">(</span><span class="n">_distance</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">queryIdx</span><span class="p">;</span> <span class="c1">// query descriptor index</span>
    <span class="kt">int</span> <span class="n">trainIdx</span><span class="p">;</span> <span class="c1">// train descriptor index</span>
    <span class="kt">int</span> <span class="n">imgIdx</span><span class="p">;</span>   <span class="c1">// train image index</span>

    <span class="kt">float</span> <span class="n">distance</span><span class="p">;</span>

    <span class="c1">// less is better</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="k">const</span> <span class="n">DMatch</span> <span class="o">&amp;</span><span class="n">m</span> <span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="ptr">
<h2>Ptr<a class="headerlink" href="#ptr" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Ptr">
<em class="property">class </em><tt class="descname">Ptr</tt><a class="headerlink" href="#Ptr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template class for smart pointers with shared ownership.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Ptr</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">element_type</span><span class="p">;</span>

    <span class="n">Ptr</span><span class="p">();</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="k">explicit</span> <span class="n">Ptr</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">D</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>

    <span class="o">~</span><span class="n">Ptr</span><span class="p">();</span>

    <span class="n">Ptr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">release</span><span class="p">();</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">reset</span><span class="p">(</span><span class="n">Y</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">D</span> <span class="n">d</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">);</span>

    <span class="n">T</span><span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">T</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">operator</span> <span class="n">T</span><span class="o">*</span> <span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="n">staticCast</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="n">constCast</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="n">dynamicCast</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A <tt class="docutils literal"><span class="pre">Ptr&lt;T&gt;</span></tt> pretends to be a pointer to an object of type T.
Unlike an ordinary pointer, however, the object will be automatically
cleaned up once all <tt class="docutils literal"><span class="pre">Ptr</span></tt> instances pointing to it are destroyed.</p>
<p><tt class="docutils literal"><span class="pre">Ptr</span></tt> is similar to <tt class="docutils literal"><span class="pre">boost::shared_ptr</span></tt> that is part of the Boost library
(<a class="reference external" href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm</a>)
and <tt class="docutils literal"><span class="pre">std::shared_ptr</span></tt> from the <a class="reference external" href="http://en.wikipedia.org/wiki/C++11">C++11</a> standard.</p>
<p>This class provides the following advantages:</p>
<ul class="simple">
<li>Default constructor, copy constructor, and assignment operator for an arbitrary C++ class
or C structure. For some objects, like files, windows, mutexes, sockets, and others, a copy
constructor or an assignment operator are difficult to define. For some other objects, like
complex classifiers in OpenCV, copy constructors are absent and not easy to implement. Finally,
some of complex OpenCV and your own data structures may be written in C.
However, copy constructors and default constructors can simplify programming a lot. Besides,
they are often required (for example, by STL containers). By using a <tt class="docutils literal"><span class="pre">Ptr</span></tt> to such an
object instead of the object itself, you automatically get all of the necessary
constructors and the assignment operator.</li>
<li><em>O(1)</em> complexity of the above-mentioned operations. While some structures, like <tt class="docutils literal"><span class="pre">std::vector</span></tt>,
provide a copy constructor and an assignment operator, the operations may take a considerable
amount of time if the data structures are large. But if the structures are put into a <tt class="docutils literal"><span class="pre">Ptr</span></tt>,
the overhead is small and independent of the data size.</li>
<li>Automatic and customizable cleanup, even for C structures. See the example below with <tt class="docutils literal"><span class="pre">FILE*</span></tt>.</li>
<li>Heterogeneous collections of objects. The standard STL and most other C++ and OpenCV containers
can store only objects of the same type and the same size. The classical solution to store objects
of different types in the same container is to store pointers to the base class (<tt class="docutils literal"><span class="pre">Base*</span></tt>)
instead but then you lose the automatic memory management. Again, by using <tt class="docutils literal"><span class="pre">Ptr&lt;Base&gt;</span></tt>
instead of raw pointers, you can solve the problem.</li>
</ul>
<p>A <tt class="docutils literal"><span class="pre">Ptr</span></tt> is said to <em>own</em> a pointer - that is, for each <tt class="docutils literal"><span class="pre">Ptr</span></tt> there is a pointer that will be deleted
once all <tt class="docutils literal"><span class="pre">Ptr</span></tt> instances that own it are destroyed. The owned pointer may be null, in which case nothing is deleted.
Each <tt class="docutils literal"><span class="pre">Ptr</span></tt> also <em>stores</em> a pointer. The stored pointer is the pointer the <tt class="docutils literal"><span class="pre">Ptr</span></tt> pretends to be;
that is, the one you get when you use <a class="reference internal" href="#T* Ptr::get() const" title="T* Ptr::get() const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Ptr::get()</span></tt></a> or the conversion to <tt class="docutils literal"><span class="pre">T*</span></tt>. It’s usually
the same as the owned pointer, but if you use casts or the general shared-ownership constructor, the two may diverge:
the <tt class="docutils literal"><span class="pre">Ptr</span></tt> will still own the original pointer, but will itself point to something else.</p>
<p>The owned pointer is treated as a black box. The only thing <tt class="docutils literal"><span class="pre">Ptr</span></tt> needs to know about it is how to
delete it. This knowledge is encapsulated in the <em>deleter</em> - an auxiliary object that is associated
with the owned pointer and shared between all <tt class="docutils literal"><span class="pre">Ptr</span></tt> instances that own it. The default deleter is
an instance of <tt class="docutils literal"><span class="pre">DefaultDeleter</span></tt>, which uses the standard C++ <tt class="docutils literal"><span class="pre">delete</span></tt> operator; as such it
will work with any pointer allocated with the standard <tt class="docutils literal"><span class="pre">new</span></tt> operator.</p>
<p>However, if the pointer must be deleted in a different way, you must specify a custom deleter upon
<tt class="docutils literal"><span class="pre">Ptr</span></tt> construction. A deleter is simply a callable object that accepts the pointer as its sole argument.
For example, if you want to wrap <tt class="docutils literal"><span class="pre">FILE</span></tt>, you may do so as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">fopen</span><span class="p">(</span><span class="s">"myfile.txt"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">),</span> <span class="n">fclose</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="k">throw</span> <span class="p">...;</span>
<span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">....);</span>
<span class="p">...</span>
<span class="c1">// the file will be closed automatically by f's destructor.</span>
</pre></div>
</div>
<p>Alternatively, if you want all pointers of a particular type to be deleted the same way,
you can specialize <tt class="docutils literal"><span class="pre">DefaultDeleter&lt;T&gt;::operator()</span></tt> for that type, like this:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">cv</span> <span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span> <span class="kt">void</span> <span class="n">DefaultDeleter</span><span class="o">&lt;</span><span class="kt">FILE</span><span class="o">&gt;::</span><span class="k">operator</span> <span class="p">()(</span><span class="kt">FILE</span> <span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For convenience, the following types from the OpenCV C API already have such a specialization
that calls the appropriate release function:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CvCapture</span></tt></li>
<li><a class="reference internal" href="old_xml_yaml_persistence.html#CvFileStorage" title="struct CvFileStorage"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvFileStorage</span></tt></a></li>
<li><tt class="docutils literal"><span class="pre">CvHaarClassifierCascade</span></tt></li>
<li><a class="reference internal" href="old_basic_structures.html#CvMat" title="struct CvMat"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvMat</span></tt></a></li>
<li><a class="reference internal" href="old_basic_structures.html#CvMatND" title="struct CvMatND"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvMatND</span></tt></a></li>
<li><a class="reference internal" href="dynamic_structures.html#CvMemStorage" title="struct CvMemStorage"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvMemStorage</span></tt></a></li>
<li><a class="reference internal" href="old_basic_structures.html#CvSparseMat" title="struct CvSparseMat"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">CvSparseMat</span></tt></a></li>
<li><tt class="docutils literal"><span class="pre">CvVideoWriter</span></tt></li>
<li><a class="reference internal" href="old_basic_structures.html#IplImage" title="struct IplImage"><tt class="xref ocv ocv-struct docutils literal"><span class="pre">IplImage</span></tt></a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The shared ownership mechanism is implemented with reference counting. As such,
cyclic ownership (e.g. when object <tt class="docutils literal"><span class="pre">a</span></tt> contains a <tt class="docutils literal"><span class="pre">Ptr</span></tt> to object <tt class="docutils literal"><span class="pre">b</span></tt>, which
contains a <tt class="docutils literal"><span class="pre">Ptr</span></tt> to object <tt class="docutils literal"><span class="pre">a</span></tt>) will lead to all involved objects never being
cleaned up. Avoid such situations.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is safe to concurrently read (but not write) a <tt class="docutils literal"><span class="pre">Ptr</span></tt> instance from multiple threads
and therefore it is normally safe to use it in multi-threaded applications.
The same is true for <a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> and other C++ OpenCV classes that use internal
reference counts.</p>
</div>
</div>
<div class="section" id="ptr-ptr-null">
<h2>Ptr::Ptr (null)<a class="headerlink" href="#ptr-ptr-null" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Ptr::Ptr()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Ptr::</tt><tt class="descname">Ptr</tt><big>(</big><big>)</big><a class="headerlink" href="#Ptr::Ptr()" title="Permalink to this definition">¶</a></dt>
<dd><p>The default constructor creates a null <tt class="docutils literal"><span class="pre">Ptr</span></tt> - one that owns and stores a null pointer.</p>
</dd></dl>

</div>
<div class="section" id="ptr-ptr-assuming-ownership">
<h2>Ptr::Ptr (assuming ownership)<a class="headerlink" href="#ptr-ptr-assuming-ownership" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr::Ptr(Y* p)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descname">template&lt;typename Y&gt; Ptr::Ptr</tt><big>(</big>Y* <strong>p</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y&gt; Ptr::Ptr(Y* p)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y, typename D&gt; Ptr::Ptr(Y* p, D d)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descname">template&lt;typename Y, typename D&gt; Ptr::Ptr</tt><big>(</big>Y* <strong>p</strong>, D <strong>d</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y, typename D&gt; Ptr::Ptr(Y* p, D d)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> – Deleter to use for the owned pointer.</li>
<li><strong>p</strong> – Pointer to own.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If <tt class="docutils literal"><span class="pre">p</span></tt> is null, these are equivalent to the default constructor.</p>
<p>Otherwise, these constructors assume ownership of <tt class="docutils literal"><span class="pre">p</span></tt> - that is, the created <tt class="docutils literal"><span class="pre">Ptr</span></tt> owns
and stores <tt class="docutils literal"><span class="pre">p</span></tt> and assumes it is the sole owner of it. Don’t use them if <tt class="docutils literal"><span class="pre">p</span></tt> is already
owned by another <tt class="docutils literal"><span class="pre">Ptr</span></tt>, or else <tt class="docutils literal"><span class="pre">p</span></tt> will get deleted twice.</p>
<p>With the first constructor, <tt class="docutils literal"><span class="pre">DefaultDeleter&lt;Y&gt;()</span></tt> becomes the associated deleter (so <tt class="docutils literal"><span class="pre">p</span></tt>
will eventually be deleted with the standard <tt class="docutils literal"><span class="pre">delete</span></tt> operator). <tt class="docutils literal"><span class="pre">Y</span></tt> must be a complete
type at the point of invocation.</p>
<p>With the second constructor, <tt class="docutils literal"><span class="pre">d</span></tt> becomes the associated deleter.</p>
<p><tt class="docutils literal"><span class="pre">Y*</span></tt> must be convertible to <tt class="docutils literal"><span class="pre">T*</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is often easier to use <a class="reference internal" href="#template&lt;typename T&gt; Ptr&lt;T&gt; makePtr()" title="template&lt;typename T&gt; Ptr&lt;T&gt; makePtr()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">makePtr()</span></tt></a> instead.</p>
</div>
</dd></dl>

</div>
<div class="section" id="ptr-ptr-sharing-ownership">
<h2>Ptr::Ptr (sharing ownership)<a class="headerlink" href="#ptr-ptr-sharing-ownership" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Ptr::Ptr(const Ptr&amp; o)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Ptr::</tt><tt class="descname">Ptr</tt><big>(</big>const Ptr&amp; <strong>o</strong><big>)</big><a class="headerlink" href="#Ptr::Ptr(const Ptr&amp; o)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr::Ptr(const Ptr&lt;Y&gt;&amp; o)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descname">template&lt;typename Y&gt; Ptr::Ptr</tt><big>(</big>const Ptr&lt;Y&gt;&amp; <strong>o</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y&gt; Ptr::Ptr(const Ptr&lt;Y&gt;&amp; o)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr::Ptr(const Ptr&lt;Y&gt;&amp; o, T* p)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descname">template&lt;typename Y&gt; Ptr::Ptr</tt><big>(</big>const Ptr&lt;Y&gt;&amp; <strong>o</strong>, T* <strong>p</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y&gt; Ptr::Ptr(const Ptr&lt;Y&gt;&amp; o, T* p)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>o</strong> – <tt class="docutils literal"><span class="pre">Ptr</span></tt> to share ownership with.</li>
<li><strong>p</strong> – Pointer to store.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>These constructors create a <tt class="docutils literal"><span class="pre">Ptr</span></tt> that shares ownership with another <tt class="docutils literal"><span class="pre">Ptr</span></tt> - that is,
own the same pointer as <tt class="docutils literal"><span class="pre">o</span></tt>.</p>
<p>With the first two, the same pointer is stored, as well; for the second, <tt class="docutils literal"><span class="pre">Y*</span></tt> must be convertible to <tt class="docutils literal"><span class="pre">T*</span></tt>.</p>
<p>With the third, <tt class="docutils literal"><span class="pre">p</span></tt> is stored, and <tt class="docutils literal"><span class="pre">Y</span></tt> may be any type. This constructor allows to have completely
unrelated owned and stored pointers, and should be used with care to avoid confusion. A relatively
benign use is to create a non-owning <tt class="docutils literal"><span class="pre">Ptr</span></tt>, like this:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">ptr</span> <span class="o">=</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">dont_delete_me</span><span class="p">);</span> <span class="c1">// owns nothing; will not delete the pointer.</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ptr-ptr">
<h2>Ptr::~Ptr<a class="headerlink" href="#ptr-ptr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Ptr::~Ptr()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Ptr::</tt><tt class="descname">~Ptr</tt><big>(</big><big>)</big><a class="headerlink" href="#Ptr::~Ptr()" title="Permalink to this definition">¶</a></dt>
<dd><p>The destructor is equivalent to calling <a class="reference internal" href="#void Ptr::release()" title="void Ptr::release()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Ptr::release()</span></tt></a>.</p>
</dd></dl>

</div>
<div class="section" id="ptr-operator">
<h2>Ptr::operator =<a class="headerlink" href="#ptr-operator" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="Ptr&amp; Ptr::operator = (const Ptr&amp; o)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&amp; <tt class="descclassname">Ptr::</tt><tt class="descname">operator=</tt><big>(</big>const Ptr&amp; <strong>o</strong><big>)</big><a class="headerlink" href="#Ptr&amp; Ptr::operator = (const Ptr&amp; o)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr&amp; Ptr::operator = (const Ptr&lt;Y&gt;&amp; o)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y&gt; Ptr&amp; <tt class="descclassname">Ptr::</tt><tt class="descname">operator=</tt><big>(</big>const Ptr&lt;Y&gt;&amp; <strong>o</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y&gt; Ptr&amp; Ptr::operator = (const Ptr&lt;Y&gt;&amp; o)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>o</strong> – <tt class="docutils literal"><span class="pre">Ptr</span></tt> to share ownership with.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Assignment replaces the current <tt class="docutils literal"><span class="pre">Ptr</span></tt> instance with one that owns and stores same
pointers as <tt class="docutils literal"><span class="pre">o</span></tt> and then destroys the old instance.</p>
</dd></dl>

</div>
<div class="section" id="ptr-release">
<h2>Ptr::release<a class="headerlink" href="#ptr-release" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="void Ptr::release()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Ptr::</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#void Ptr::release()" title="Permalink to this definition">¶</a></dt>
<dd><p>If no other <tt class="docutils literal"><span class="pre">Ptr</span></tt> instance owns the owned pointer, deletes it with the associated deleter.
Then sets both the owned and the stored pointers to <tt class="docutils literal"><span class="pre">NULL</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="ptr-reset">
<h2>Ptr::reset<a class="headerlink" href="#ptr-reset" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename Y&gt; void Ptr::reset(Y* p)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y&gt; void <tt class="descclassname">Ptr::</tt><tt class="descname">reset</tt><big>(</big>Y* <strong>p</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y&gt; void Ptr::reset(Y* p)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y, typename D&gt; void Ptr::reset(Y* p, D d)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y, typename D&gt; void <tt class="descclassname">Ptr::</tt><tt class="descname">reset</tt><big>(</big>Y* <strong>p</strong>, D <strong>d</strong><big>)</big><a class="headerlink" href="#template&lt;typename Y, typename D&gt; void Ptr::reset(Y* p, D d)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> – Deleter to use for the owned pointer.</li>
<li><strong>p</strong> – Pointer to own.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">ptr.reset(...)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">ptr</span> <span class="pre">=</span> <span class="pre">Ptr&lt;T&gt;(...)</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="ptr-swap">
<h2>Ptr::swap<a class="headerlink" href="#ptr-swap" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="void Ptr::swap(Ptr&amp; o)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Ptr::</tt><tt class="descname">swap</tt><big>(</big>Ptr&amp; <strong>o</strong><big>)</big><a class="headerlink" href="#void Ptr::swap(Ptr&amp; o)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>o</strong> – <tt class="docutils literal"><span class="pre">Ptr</span></tt> to swap with.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Swaps the owned and stored pointers (and deleters, if any) of this and <tt class="docutils literal"><span class="pre">o</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="ptr-get">
<h2>Ptr::get<a class="headerlink" href="#ptr-get" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="T* Ptr::get() const">
<strong>C++:</strong><tt class="descname"> </tt>T* <tt class="descclassname">Ptr::</tt><tt class="descname">get</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#T* Ptr::get() const" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the stored pointer.</p>
</dd></dl>

</div>
<div class="section" id="ptr-pointer-emulation">
<h2>Ptr pointer emulation<a class="headerlink" href="#ptr-pointer-emulation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="T&amp; Ptr::operator * () const">
<strong>C++:</strong><tt class="descname"> </tt>T&amp; <tt class="descclassname">Ptr::</tt><tt class="descname">operator*</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#T&amp; Ptr::operator * () const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="T* Ptr::operator -&gt; () const">
<strong>C++:</strong><tt class="descname"> </tt>T* <tt class="descclassname">Ptr::</tt><tt class="descname">operator-&gt;</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#T* Ptr::operator -&gt; () const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Ptr::operator T* () const">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Ptr::</tt><tt class="descname">operator</tt> T*<big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Ptr::operator T* () const" title="Permalink to this definition">¶</a></dt>
<dd><p>These operators are what allows <tt class="docutils literal"><span class="pre">Ptr</span></tt> to pretend to be a pointer.</p>
<p>If <tt class="docutils literal"><span class="pre">ptr</span></tt> is a <tt class="docutils literal"><span class="pre">Ptr&lt;T&gt;</span></tt>, then <tt class="docutils literal"><span class="pre">*ptr</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">*ptr.get()</span></tt>
and <tt class="docutils literal"><span class="pre">ptr-&gt;foo</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">ptr.get()-&gt;foo</span></tt>. In addition, <tt class="docutils literal"><span class="pre">ptr</span></tt>
is implicitly convertible to <tt class="docutils literal"><span class="pre">T*</span></tt>, and such conversion is equivalent to
<tt class="docutils literal"><span class="pre">ptr.get()</span></tt>. As a corollary, <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(ptr)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(ptr.get())</span></tt>.
In other words, a <tt class="docutils literal"><span class="pre">Ptr</span></tt> behaves as if it was its own stored pointer.</p>
</dd></dl>

</div>
<div class="section" id="ptr-empty">
<h2>Ptr::empty<a class="headerlink" href="#ptr-empty" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="bool Ptr::empty() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">Ptr::</tt><tt class="descname">empty</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool Ptr::empty() const" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">ptr.empty()</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">!ptr.get()</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="ptr-casts">
<h2>Ptr casts<a class="headerlink" href="#ptr-casts" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::staticCast() const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y&gt; Ptr&lt;Y&gt; <tt class="descclassname">Ptr::</tt><tt class="descname">staticCast</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::staticCast() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::constCast() const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y&gt; Ptr&lt;Y&gt; <tt class="descclassname">Ptr::</tt><tt class="descname">constCast</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::constCast() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::dynamicCast() const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename Y&gt; Ptr&lt;Y&gt; <tt class="descclassname">Ptr::</tt><tt class="descname">dynamicCast</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename Y&gt; Ptr&lt;Y&gt; Ptr::dynamicCast() const" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">ptr</span></tt> is a <tt class="docutils literal"><span class="pre">Ptr</span></tt>, then <tt class="docutils literal"><span class="pre">ptr.fooCast&lt;Y&gt;()</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">Ptr&lt;Y&gt;(ptr,</span> <span class="pre">foo_cast&lt;Y&gt;(ptr.get()))</span></tt>. That is, these functions create
a new <tt class="docutils literal"><span class="pre">Ptr</span></tt> with the same owned pointer and a cast stored pointer.</p>
</dd></dl>

</div>
<div class="section" id="ptr-global-swap">
<h2>Ptr global swap<a class="headerlink" href="#ptr-global-swap" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename T&gt; void swap(Ptr&lt;T&gt;&amp; ptr1, Ptr&lt;T&gt;&amp; ptr2)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; void <tt class="descname">swap</tt><big>(</big>Ptr&lt;T&gt;&amp; <strong>ptr1</strong>, Ptr&lt;T&gt;&amp; <strong>ptr2</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; void swap(Ptr&lt;T&gt;&amp; ptr1, Ptr&lt;T&gt;&amp; ptr2)" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalent to <tt class="docutils literal"><span class="pre">ptr1.swap(ptr2)</span></tt>. Provided to help write generic algorithms.</p>
</dd></dl>

</div>
<div class="section" id="ptr-comparisons">
<h2>Ptr comparisons<a class="headerlink" href="#ptr-comparisons" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename T&gt; bool operator == (const Ptr&lt;T&gt;&amp; ptr1, const Ptr&lt;T&gt;&amp; ptr2)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; bool <tt class="descname">operator==</tt><big>(</big>const Ptr&lt;T&gt;&amp; <strong>ptr1</strong>, const Ptr&lt;T&gt;&amp; <strong>ptr2</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; bool operator == (const Ptr&lt;T&gt;&amp; ptr1, const Ptr&lt;T&gt;&amp; ptr2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; bool operator != (const Ptr&lt;T&gt;&amp; ptr1, const Ptr&lt;T&gt;&amp; ptr2)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; bool <tt class="descname">operator!=</tt><big>(</big>const Ptr&lt;T&gt;&amp; <strong>ptr1</strong>, const Ptr&lt;T&gt;&amp; <strong>ptr2</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; bool operator != (const Ptr&lt;T&gt;&amp; ptr1, const Ptr&lt;T&gt;&amp; ptr2)" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <tt class="docutils literal"><span class="pre">ptr1.get()</span></tt> and <tt class="docutils literal"><span class="pre">ptr2.get()</span></tt> are equal and not equal, respectively.</p>
</dd></dl>

</div>
<div class="section" id="makeptr">
<h2>makePtr<a class="headerlink" href="#makeptr" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="template&lt;typename T&gt; Ptr&lt;T&gt; makePtr()">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; Ptr&lt;T&gt; <tt class="descname">makePtr</tt><big>(</big><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; Ptr&lt;T&gt; makePtr()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, typename A1&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T, typename A1&gt; Ptr&lt;T&gt; <tt class="descname">makePtr</tt><big>(</big>const A1&amp; <strong>a1</strong><big>)</big><a class="headerlink" href="#template&lt;typename T, typename A1&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, typename A1, typename A2&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1, const A2&amp; a2)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T, typename A1, typename A2&gt; Ptr&lt;T&gt; <tt class="descname">makePtr</tt><big>(</big>const A1&amp; <strong>a1</strong>, const A2&amp; <strong>a2</strong><big>)</big><a class="headerlink" href="#template&lt;typename T, typename A1, typename A2&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1, const A2&amp; a2)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, typename A1, typename A2, typename A3&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T, typename A1, typename A2, typename A3&gt; Ptr&lt;T&gt; <tt class="descname">makePtr</tt><big>(</big>const A1&amp; <strong>a1</strong>, const A2&amp; <strong>a2</strong>, const A3&amp; <strong>a3</strong><big>)</big><a class="headerlink" href="#template&lt;typename T, typename A1, typename A2, typename A3&gt; Ptr&lt;T&gt; makePtr(const A1&amp; a1, const A2&amp; a2, const A3&amp; a3)" title="Permalink to this definition">¶</a></dt>
<dd><p>(and so on...)</p>
<p><tt class="docutils literal"><span class="pre">makePtr&lt;T&gt;(...)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">Ptr&lt;T&gt;(new</span> <span class="pre">T(...))</span></tt>. It is shorter than the latter, and
it’s marginally safer than using a constructor or <a class="reference internal" href="#template&lt;typename Y&gt; void Ptr::reset(Y* p)" title="template&lt;typename Y&gt; void Ptr::reset(Y* p)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Ptr::reset()</span></tt></a>, since it ensures that
the owned pointer is new and thus not owned by any other <tt class="docutils literal"><span class="pre">Ptr</span></tt> instance.</p>
<p>Unfortunately, perfect forwarding is impossible to implement in C++03, and so <tt class="docutils literal"><span class="pre">makePtr</span></tt> is limited
to constructors of <tt class="docutils literal"><span class="pre">T</span></tt> that have up to 10 arguments, none of which are non-const references.</p>
</dd></dl>

</div>
<div class="section" id="mat">
<h2>Mat<a class="headerlink" href="#mat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Mat">
<em class="property">class </em><tt class="descname">Mat</tt><a class="headerlink" href="#Mat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>OpenCV C++ n-dimensional dense array class</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ... a lot of methods ...</span>
    <span class="p">...</span>

    <span class="cm">/*! includes several bit-fields:</span>
<span class="cm">         - the magic signature</span>
<span class="cm">         - continuity flag</span>
<span class="cm">         - depth</span>
<span class="cm">         - number of channels</span>
<span class="cm">     */</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//! the array dimensionality, &gt;= 2</span>
    <span class="kt">int</span> <span class="n">dims</span><span class="p">;</span>
    <span class="c1">//! the number of rows and columns or (-1, -1) when the array has more than 2 dimensions</span>
    <span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">;</span>
    <span class="c1">//! pointer to the data</span>
    <span class="n">uchar</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>

    <span class="c1">//! pointer to the reference counter;</span>
    <span class="c1">// when array points to user-allocated data, the pointer is NULL</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">refcount</span><span class="p">;</span>

    <span class="c1">// other members</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">Mat</span></tt> represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms may be better stored in a <tt class="docutils literal"><span class="pre">SparseMat</span></tt> ). The data layout of the array
<img class="math" src="../../../_images/math/336950fdbecc1771997c5eb48994a4b7056f3b81.png" alt="M"> is defined by the array <tt class="docutils literal"><span class="pre">M.step[]</span></tt>, so that the address of element
<img class="math" src="../../../_images/math/c0d5a8ad7b449b96f27970b6fc676b5f57e5e4d7.png" alt="(i_0,...,i_{M.dims-1})">, where
<img class="math" src="../../../_images/math/0a2f9d643bf7d178dd17f0205812cb00370fc812.png" alt="0\leq i_k&lt;M.size[k]">, is computed as:</p>
<div class="math">
<p><img src="../../../_images/math/02e09c666c056a455711d9780308622713b19564.png" alt="addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}"></p>
</div><p>In case of a 2-dimensional array, the above formula is reduced to:</p>
<div class="math">
<p><img src="../../../_images/math/17192416401bd8aab16de64c8467641e39f972c7.png" alt="addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j"></p>
</div><p>Note that <tt class="docutils literal"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]</span></tt> (in fact, <tt class="docutils literal"><span class="pre">M.step[i]</span> <span class="pre">&gt;=</span> <span class="pre">M.step[i+1]*M.size[i+1]</span></tt> ). This means that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane, and so on. <tt class="docutils literal"><span class="pre">M.step[M.dims-1]</span></tt> is minimal and always equal to the element size <tt class="docutils literal"><span class="pre">M.elemSize()</span></tt> .</p>
<p>So, the data layout in <tt class="docutils literal"><span class="pre">Mat</span></tt> is fully compatible with <tt class="docutils literal"><span class="pre">CvMat</span></tt>, <tt class="docutils literal"><span class="pre">IplImage</span></tt>, and <tt class="docutils literal"><span class="pre">CvMatND</span></tt> types from OpenCV 1.x. It is also compatible with the majority of dense array types from the standard toolkits and SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others, that is, with any array that uses <em>steps</em> (or <em>strides</em>) to compute the position of a pixel. Due to this compatibility, it is possible to make a <tt class="docutils literal"><span class="pre">Mat</span></tt> header for user-allocated data and process it in-place using OpenCV functions.</p>
<p>There are many different ways to create a <tt class="docutils literal"><span class="pre">Mat</span></tt> object. The most popular options are listed below:</p>
<ul>
<li><p class="first">Use the <tt class="docutils literal"><span class="pre">create(nrows,</span> <span class="pre">ncols,</span> <span class="pre">type)</span></tt>   method or the similar <tt class="docutils literal"><span class="pre">Mat(nrows,</span> <span class="pre">ncols,</span> <span class="pre">type[,</span> <span class="pre">fillValue])</span></tt>     constructor. A new array of the specified size and type is allocated. <tt class="docutils literal"><span class="pre">type</span></tt>     has the same meaning as in the <tt class="docutils literal"><span class="pre">cvCreateMat</span></tt>     method.
For example, <tt class="docutils literal"><span class="pre">CV_8UC1</span></tt>     means a 8-bit single-channel array, <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt>     means a 2-channel (complex) floating-point array, and so on.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// make a 7x7 complex matrix filled with 1+3j.</span>
<span class="n">Mat</span> <span class="nf">M</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">CV_32FC2</span><span class="p">,</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// and now turn M to a 100x60 15-channel 8-bit matrix.</span>
<span class="c1">// The old content will be deallocated</span>
<span class="n">M</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="n">CV_8UC</span><span class="p">(</span><span class="mi">15</span><span class="p">));</span>
</pre></div>
</div>
<p>As noted in the introduction to this chapter, <tt class="docutils literal"><span class="pre">create()</span></tt> allocates only  a new array when the shape or type of the current array are different from the specified ones.</p>
</li>
<li><p class="first">Create a multi-dimensional array:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 100x100x100 8-bit array</span>
<span class="kt">int</span> <span class="n">sz</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
<span class="n">Mat</span> <span class="nf">bigCube</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>It passes the number of dimensions =1 to the <tt class="docutils literal"><span class="pre">Mat</span></tt> constructor but the created array will be 2-dimensional with the number of columns set to 1. So, <tt class="docutils literal"><span class="pre">Mat::dims</span></tt>     is always &gt;= 2 (can also be 0 when the array is empty).</p>
</li>
<li><p class="first">Use a copy constructor or assignment operator where there can be an array or expression on the right side (see below). As noted in the introduction, the array assignment is an O(1) operation because it only copies the header and increases the reference counter. The <tt class="docutils literal"><span class="pre">Mat::clone()</span></tt>     method can be used to get a full (deep) copy of the array when you need it.</p>
</li>
<li><p class="first">Construct a header for a part of another array. It can be a single row, single column, several rows, several columns, rectangular region in the array (called a <em>minor</em> in algebra) or a diagonal. Such operations are also O(1) because the new header references the same data. You can actually modify a part of the array using this feature, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// add the 5-th row, multiplied by 3 to the 3rd row</span>
<span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span>

<span class="c1">// now copy the 7-th column to the 1-st column</span>
<span class="c1">// M.col(1) = M.col(7); // this will not work</span>
<span class="n">Mat</span> <span class="n">M1</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">7</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">M1</span><span class="p">);</span>

<span class="c1">// create a new 320x240 image</span>
<span class="n">Mat</span> <span class="nf">img</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">240</span><span class="p">),</span><span class="n">CV_8UC3</span><span class="p">);</span>
<span class="c1">// select a ROI</span>
<span class="n">Mat</span> <span class="nf">roi</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
<span class="c1">// fill the ROI with (0,255,0) (which is green in RGB space);</span>
<span class="c1">// the original 320x240 image will be modified</span>
<span class="n">roi</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Due to the additional <tt class="docutils literal"><span class="pre">datastart</span></tt> and <tt class="docutils literal"><span class="pre">dataend</span></tt> members, it is possible to compute a relative sub-array position in the main <em>container</em> array using <tt class="docutils literal"><span class="pre">locateROI()</span></tt>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">CV_32S</span><span class="p">);</span>
<span class="c1">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span>
<span class="n">Mat</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">(),</span> <span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="c1">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span>
<span class="c1">// that is, C ~ A(Range(5, 9), Range(1, 3))</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">Range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">());</span>
<span class="n">Size</span> <span class="n">size</span><span class="p">;</span> <span class="n">Point</span> <span class="n">ofs</span><span class="p">;</span>
<span class="n">C</span><span class="p">.</span><span class="n">locateROI</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
<span class="c1">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span>
</pre></div>
</div>
<p>As in case of whole matrices, if you need a deep copy, use the <tt class="docutils literal"><span class="pre">clone()</span></tt> method of the extracted sub-matrices.</p>
</li>
<li><p class="first">Make a header for user-allocated data. It can be useful to do the following:</p>
<ol class="arabic">
<li><p class="first">Process “foreign” data using OpenCV (for example, when you implement a DirectShow* filter or a processing module for <tt class="docutils literal"><span class="pre">gstreamer</span></tt>, and so on). For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">process_video_frame</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span>
                         <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">step</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mat</span> <span class="n">img</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">,</span> <span class="n">pixels</span><span class="p">,</span> <span class="n">step</span><span class="p">);</span>
    <span class="n">GaussianBlur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">Size</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Quickly initialize small matrices and/or get a super-fast element access.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">},</span> <span class="p">{</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">},</span> <span class="p">{</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">}};</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">,</span> <span class="n">m</span><span class="p">).</span><span class="n">inv</span><span class="p">();</span>
</pre></div>
</div>
</li>
</ol>
<p>Partial yet very common cases of this <em>user-allocated data</em> case are conversions from <tt class="docutils literal"><span class="pre">CvMat</span></tt> and <tt class="docutils literal"><span class="pre">IplImage</span></tt> to <tt class="docutils literal"><span class="pre">Mat</span></tt>. For this purpose, there are special constructors taking pointers to <tt class="docutils literal"><span class="pre">CvMat</span></tt>     or <tt class="docutils literal"><span class="pre">IplImage</span></tt> and the optional flag indicating whether to copy the data or not.</p>
<blockquote>
<div><p>Backward conversion from <tt class="docutils literal"><span class="pre">Mat</span></tt> to <tt class="docutils literal"><span class="pre">CvMat</span></tt> or <tt class="docutils literal"><span class="pre">IplImage</span></tt> is provided via cast operators <tt class="docutils literal"><span class="pre">Mat::operator</span> <span class="pre">CvMat()</span> <span class="pre">const</span></tt> and <tt class="docutils literal"><span class="pre">Mat::operator</span> <span class="pre">IplImage()</span></tt>. The operators do NOT copy the data.</p>
</div></blockquote>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">IplImage</span><span class="o">*</span> <span class="n">img</span> <span class="o">=</span> <span class="n">cvLoadImage</span><span class="p">(</span><span class="s">"greatwave.jpg"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="nf">mtx</span><span class="p">(</span><span class="n">img</span><span class="p">);</span> <span class="c1">// convert IplImage* -&gt; Mat</span>
<span class="n">CvMat</span> <span class="n">oldmat</span> <span class="o">=</span> <span class="n">mtx</span><span class="p">;</span> <span class="c1">// convert Mat -&gt; CvMat</span>
<span class="n">CV_Assert</span><span class="p">(</span><span class="n">oldmat</span><span class="p">.</span><span class="n">cols</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="n">oldmat</span><span class="p">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">&amp;&amp;</span>
    <span class="n">oldmat</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">==</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span><span class="n">img</span><span class="o">-&gt;</span><span class="n">imageData</span> <span class="o">&amp;&amp;</span> <span class="n">oldmat</span><span class="p">.</span><span class="n">step</span> <span class="o">==</span> <span class="n">img</span><span class="o">-&gt;</span><span class="n">widthStep</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Use MATLAB-style array initializers, <tt class="docutils literal"><span class="pre">zeros(),</span> <span class="pre">ones(),</span> <span class="pre">eye()</span></tt>, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a double-precision identity martix and add it to M.</span>
<span class="n">M</span> <span class="o">+=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Use a comma-separated initializer:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 3x3 double-precision identity matrix</span>
<span class="n">Mat</span> <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>With this approach, you first call a constructor of the <a class="reference internal" href="#Mat_" title="class Mat_"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat_</span></tt></a>  class with the proper parameters, and then you just put <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt>     operator followed by comma-separated values that can be constants, variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation errors.</p>
</li>
</ul>
<p>Once the array is created, it is automatically managed via a reference-counting mechanism. If the array header is built on top of user-allocated data, you should handle the data by yourself.
The array data is deallocated when no one points to it. If you want to release the data pointed by a array header before the array destructor is called, use <tt class="docutils literal"><span class="pre">Mat::release()</span></tt> .</p>
<p>The next important thing to learn about the array class is element access. This manual already described how to compute an address of each array element. Normally, you are not required to use the formula directly in the code. If you know the array element type (which can be retrieved using the method <tt class="docutils literal"><span class="pre">Mat::type()</span></tt> ), you can access the element
<img class="math" src="../../../_images/math/07c5e1d5bb944623924cbae88bd5261eb9930011.png" alt="M_{ij}"> of a 2-dimensional array as:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">M</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
</pre></div>
</div>
<p>assuming that M is a double-precision floating-point array. There are several variants of the method <tt class="docutils literal"><span class="pre">at</span></tt> for a different number of dimensions.</p>
<p>If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to the row first, and then just use the plain C operator <tt class="docutils literal"><span class="pre">[]</span></tt> :</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute sum of positive matrix elements</span>
<span class="c1">// (assuming that M isa double-precision matrix)</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Some operations, like the one above, do not actually depend on the array shape. They just process elements of an array one by one (or elements from multiple arrays that have the same coordinates, for example, array addition). Such operations are called <em>element-wise</em>. It makes sense to check whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If yes, process them as a long single row:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute the sum of positive matrix elements, optimized variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">cols</span> <span class="o">*=</span> <span class="n">rows</span><span class="p">;</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">Mi</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Mi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is smaller, which is especially noticeable in case of small matrices.</p>
<p>Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute sum of positive matrix elements, iterator-based variant</span>
<span class="kt">double</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it_end</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">,</span> <span class="mf">0.</span><span class="p">);</span>
</pre></div>
</div>
<p>The matrix iterators are random-access iterators, so they can be passed to any STL algorithm, including <tt class="docutils literal"><span class="pre">std::sort()</span></tt> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example demonstrating the serial out capabilities of cv::Mat can be found at opencv_source_code/samples/cpp/cout_mat.cpp</li>
</ul>
</div>
</div>
<div class="section" id="matrix-expressions">
<span id="matrixexpressions"></span><h2>Matrix Expressions<a class="headerlink" href="#matrix-expressions" title="Permalink to this headline">¶</a></h2>
<p>This is a list of implemented matrix operations that can be combined in arbitrary complex expressions
(here <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt> stand for matrices ( <tt class="docutils literal"><span class="pre">Mat</span></tt> ), <tt class="docutils literal"><span class="pre">s</span></tt> for a scalar ( <tt class="docutils literal"><span class="pre">Scalar</span></tt> ),
<tt class="docutils literal"><span class="pre">alpha</span></tt> for a real-valued scalar ( <tt class="docutils literal"><span class="pre">double</span></tt> )):</p>
<ul>
<li><p class="first">Addition, subtraction, negation:
<tt class="docutils literal"><span class="pre">A+B,</span> <span class="pre">A-B,</span> <span class="pre">A+s,</span> <span class="pre">A-s,</span> <span class="pre">s+A,</span> <span class="pre">s-A,</span> <span class="pre">-A</span></tt></p>
</li>
<li><p class="first">Scaling:
<tt class="docutils literal"><span class="pre">A*alpha</span></tt></p>
</li>
<li><p class="first">Per-element multiplication and division:
<tt class="docutils literal"><span class="pre">A.mul(B),</span> <span class="pre">A/B,</span> <span class="pre">alpha/A</span></tt></p>
</li>
<li><p class="first">Matrix multiplication:
<tt class="docutils literal"><span class="pre">A*B</span></tt></p>
</li>
<li><p class="first">Transposition:
<tt class="docutils literal"><span class="pre">A.t()</span></tt> (means <tt class="docutils literal"><span class="pre">A</span></tt><sup>T</sup>)</p>
</li>
<li><p class="first">Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:</p>
<p><tt class="docutils literal"><span class="pre">A.inv([method])</span></tt> (~ <tt class="docutils literal"><span class="pre">A</span></tt><sup>-1</sup>) <tt class="docutils literal"><span class="pre">,</span>&nbsp;&nbsp; <span class="pre">A.inv([method])*B</span></tt> (~ <tt class="docutils literal"><span class="pre">X:</span> <span class="pre">AX=B</span></tt>)</p>
</li>
<li><p class="first">Comparison:
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">cmpop</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">cmpop</span> <span class="pre">alpha,</span> <span class="pre">alpha</span> <span class="pre">cmpop</span> <span class="pre">A</span></tt>, where <tt class="docutils literal"><span class="pre">cmpop</span></tt> is one of <tt class="docutils literal"><span class="pre">:</span>&nbsp; <span class="pre">&gt;,</span> <span class="pre">&gt;=,</span> <span class="pre">==,</span> <span class="pre">!=,</span> <span class="pre">&lt;=,</span> <span class="pre">&lt;</span></tt>. The result of comparison is an 8-bit single channel mask whose elements are set to 255 (if the particular element or pair of elements satisfy the condition) or 0.</p>
</li>
<li><p class="first">Bitwise logical operations: <tt class="docutils literal"><span class="pre">A</span> <span class="pre">logicop</span> <span class="pre">B,</span> <span class="pre">A</span> <span class="pre">logicop</span> <span class="pre">s,</span> <span class="pre">s</span> <span class="pre">logicop</span> <span class="pre">A,</span> <span class="pre">~A</span></tt>, where <tt class="docutils literal"><span class="pre">logicop</span></tt> is one of <tt class="docutils literal"><span class="pre">:</span>&nbsp; <span class="pre">&amp;,</span> <span class="pre">|,</span> <span class="pre">^</span></tt>.</p>
</li>
<li><p class="first">Element-wise minimum and maximum:
<tt class="docutils literal"><span class="pre">min(A,</span> <span class="pre">B),</span> <span class="pre">min(A,</span> <span class="pre">alpha),</span> <span class="pre">max(A,</span> <span class="pre">B),</span> <span class="pre">max(A,</span> <span class="pre">alpha)</span></tt></p>
</li>
<li><p class="first">Element-wise absolute value:
<tt class="docutils literal"><span class="pre">abs(A)</span></tt></p>
</li>
<li><p class="first">Cross-product, dot-product:
<tt class="docutils literal"><span class="pre">A.cross(B)</span></tt>
<tt class="docutils literal"><span class="pre">A.dot(B)</span></tt></p>
</li>
<li><p class="first">Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as <tt class="docutils literal"><span class="pre">norm</span></tt>, <tt class="docutils literal"><span class="pre">mean</span></tt>, <tt class="docutils literal"><span class="pre">sum</span></tt>, <tt class="docutils literal"><span class="pre">countNonZero</span></tt>, <tt class="docutils literal"><span class="pre">trace</span></tt>, <tt class="docutils literal"><span class="pre">determinant</span></tt>, <tt class="docutils literal"><span class="pre">repeat</span></tt>, and others.</p>
</li>
<li><p class="first">Matrix initializers ( <tt class="docutils literal"><span class="pre">Mat::eye(),</span> <span class="pre">Mat::zeros(),</span> <span class="pre">Mat::ones()</span></tt> ), matrix comma-separated initializers, matrix constructors and operators that extract sub-matrices (see <a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> description).</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Mat_&lt;destination_type&gt;()</span></tt> constructors to cast the result to the proper type.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Comma-separated initializers and probably some other operations may require additional explicit <tt class="docutils literal"><span class="pre">Mat()</span></tt> or <tt class="docutils literal"><span class="pre">Mat_&lt;T&gt;()</span></tt> constructor calls to resolve a possible ambiguity.</p>
</div>
<p>Here are examples of matrix expressions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// compute pseudo-inverse of A, equivalent to A.inv(DECOMP_SVD)</span>
<span class="n">SVD</span> <span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">pinvA</span> <span class="o">=</span> <span class="n">svd</span><span class="p">.</span><span class="n">vt</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">Mat</span><span class="o">::</span><span class="n">diag</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">svd</span><span class="p">.</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="n">svd</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>

<span class="c1">// compute the new vector of parameters in the Levenberg-Marquardt algorithm</span>
<span class="n">x</span> <span class="o">-=</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="n">lambda</span><span class="o">*</span><span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span><span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">())).</span><span class="n">inv</span><span class="p">(</span><span class="n">DECOMP_CHOLESKY</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">err</span><span class="p">);</span>

<span class="c1">// sharpen image using "unsharp mask" algorithm</span>
<span class="n">Mat</span> <span class="n">blurred</span><span class="p">;</span> <span class="kt">double</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">GaussianBlur</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">blurred</span><span class="p">,</span> <span class="n">Size</span><span class="p">(),</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">lowConstrastMask</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">img</span> <span class="o">-</span> <span class="n">blurred</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">sharpened</span> <span class="o">=</span> <span class="n">img</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">amount</span><span class="p">)</span> <span class="o">+</span> <span class="n">blurred</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">amount</span><span class="p">);</span>
<span class="n">img</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">sharpened</span><span class="p">,</span> <span class="n">lowContrastMask</span><span class="p">);</span>
</pre></div>
</div>
<p>Below is the formal description of the <tt class="docutils literal"><span class="pre">Mat</span></tt> methods.</p>
</div>
<div class="section" id="mat-mat">
<h2>Mat::Mat<a class="headerlink" href="#mat-mat" title="Permalink to this headline">¶</a></h2>
<p>Various Mat constructors</p>
<dl class="function">
<dt id="Mat::Mat()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big><big>)</big><a class="headerlink" href="#Mat::Mat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#Mat::Mat(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type, const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><big>)</big><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type, const Scalar&amp; s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type, const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><big>)</big><a class="headerlink" href="#Mat::Mat(Size size, int type, const Scalar&amp; s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#Mat::Mat(const Mat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int rows, int cols, int type, void* data, size_t step)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong>, void* <strong>data</strong>, size_t <strong>step</strong>=AUTO_STEP<big>)</big><a class="headerlink" href="#Mat::Mat(int rows, int cols, int type, void* data, size_t step)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(Size size, int type, void* data, size_t step)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong>, void* <strong>data</strong>, size_t <strong>step</strong>=AUTO_STEP<big>)</big><a class="headerlink" href="#Mat::Mat(Size size, int type, void* data, size_t step)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Range&amp; rowRange, const Range&amp; colRange)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Mat&amp; <strong>m</strong>, const Range&amp; <strong>rowRange</strong>, const Range&amp; <strong>colRange</strong>=Range::all() <big>)</big><a class="headerlink" href="#Mat::Mat(const Mat&amp; m, const Range&amp; rowRange, const Range&amp; colRange)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Rect&amp; roi)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Mat&amp; <strong>m</strong>, const Rect&amp; <strong>roi</strong><big>)</big><a class="headerlink" href="#Mat::Mat(const Mat&amp; m, const Rect&amp; roi)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, int n&gt; explicit Mat::Mat(const Vec&lt;T, n&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T, int n&gt; explicit <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Vec&lt;T, n&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=true<big>)</big><a class="headerlink" href="#template&lt;typename T, int n&gt; explicit Mat::Mat(const Vec&lt;T, n&gt;&amp; vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T, int m, int n&gt; explicit Mat::Mat(const Matx&lt;T, m, n&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T, int m, int n&gt; explicit <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Matx&lt;T, m, n&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=true<big>)</big><a class="headerlink" href="#template&lt;typename T, int m, int n&gt; explicit Mat::Mat(const Matx&lt;T, m, n&gt;&amp; vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; explicit Mat::Mat(const vector&lt;T&gt;&amp; vec, bool copyData)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; explicit <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const vector&lt;T&gt;&amp; <strong>vec</strong>, bool <strong>copyData</strong>=false<big>)</big><a class="headerlink" href="#template&lt;typename T&gt; explicit Mat::Mat(const vector&lt;T&gt;&amp; vec, bool copyData)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type, const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong>, const Scalar&amp; <strong>s</strong><big>)</big><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type, const Scalar&amp; s)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong>, void* <strong>data</strong>, const size_t* <strong>steps</strong>=0<big>)</big><a class="headerlink" href="#Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat::Mat(const Mat&amp; m, const Range* ranges)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">Mat</tt><big>(</big>const Mat&amp; <strong>m</strong>, const Range* <strong>ranges</strong><big>)</big><a class="headerlink" href="#Mat::Mat(const Mat&amp; m, const Range* ranges)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> – Array dimensionality.</li>
<li><strong>rows</strong> – Number of rows in a 2D array.</li>
<li><strong>cols</strong> – Number of columns in a 2D array.</li>
<li><strong>roi</strong> – Region of interest.</li>
<li><strong>size</strong> – 2D array size:  <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt> . In the  <tt class="docutils literal"><span class="pre">Size()</span></tt>  constructor, the number of rows and the number of columns go in the reverse order.</li>
<li><strong>sizes</strong> – Array of integers specifying an n-dimensional array shape.</li>
<li><strong>type</strong> – Array type. Use  <tt class="docutils literal"><span class="pre">CV_8UC1,</span> <span class="pre">...,</span> <span class="pre">CV_64FC4</span></tt>  to create 1-4 channel matrices, or  <tt class="docutils literal"><span class="pre">CV_8UC(n),</span> <span class="pre">...,</span> <span class="pre">CV_64FC(n)</span></tt>  to create multi-channel (up to  <tt class="docutils literal"><span class="pre">CV_CN_MAX</span></tt>  channels) matrices.</li>
<li><strong>s</strong> – An optional value to initialize each matrix element with. To set all the matrix elements to the particular value after the construction, use the assignment operator  <tt class="docutils literal"><span class="pre">Mat::operator=(const</span> <span class="pre">Scalar&amp;</span> <span class="pre">value)</span></tt> .</li>
<li><strong>data</strong> – Pointer to the user data. Matrix constructors that take  <tt class="docutils literal"><span class="pre">data</span></tt>  and  <tt class="docutils literal"><span class="pre">step</span></tt>  parameters do not allocate matrix data. Instead, they just initialize the matrix header that points to the specified data, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it.</li>
<li><strong>step</strong> – Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to  <tt class="docutils literal"><span class="pre">AUTO_STEP</span></tt> ), no padding is assumed and the actual step is calculated as  <tt class="docutils literal"><span class="pre">cols*elemSize()</span></tt> . See  <a class="reference internal" href="#size_t Mat::elemSize() const" title="size_t Mat::elemSize() const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::elemSize()</span></tt></a> .</li>
<li><strong>steps</strong> – Array of  <tt class="docutils literal"><span class="pre">ndims-1</span></tt>  steps in case of a multi-dimensional array (the last step is always set to the element size). If not specified, the matrix is assumed to be continuous.</li>
<li><strong>m</strong> – Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied by these constructors. Instead, the header pointing to  <tt class="docutils literal"><span class="pre">m</span></tt>  data or its sub-array is constructed and associated with it. The reference counter, if any, is incremented. So, when you modify the matrix formed using such a constructor, you also modify the corresponding elements of  <tt class="docutils literal"><span class="pre">m</span></tt> . If you want to have an independent copy of the sub-array, use  <tt class="docutils literal"><span class="pre">Mat::clone()</span></tt> .</li>
<li><strong>img</strong> – Pointer to the old-style  <tt class="docutils literal"><span class="pre">IplImage</span></tt>  image structure. By default, the data is shared between the original image and the new matrix. But when  <tt class="docutils literal"><span class="pre">copyData</span></tt>  is set, the full copy of the image data is created.</li>
<li><strong>vec</strong> – STL vector whose elements form the matrix. The matrix has a single column and the number of rows equal to the number of vector elements. Type of the matrix matches the type of vector elements. The constructor can handle arbitrary types, for which there is a properly declared  <a class="reference internal" href="#DataType" title="class DataType"><tt class="xref ocv ocv-class docutils literal"><span class="pre">DataType</span></tt></a> . This means that the vector elements must be primitive numbers or uni-type numerical tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is explicit. Since STL vectors are not automatically converted to  <tt class="docutils literal"><span class="pre">Mat</span></tt>  instances, you should write  <tt class="docutils literal"><span class="pre">Mat(vec)</span></tt>  explicitly. Unless you copy the data into the matrix ( <tt class="docutils literal"><span class="pre">copyData=true</span></tt> ), no new elements will be added to the vector because it can potentially yield vector data reallocation, and, thus, the matrix data pointer will be invalid.</li>
<li><strong>copyData</strong> – Flag to specify whether the underlying data of the STL vector or the old-style  <tt class="docutils literal"><span class="pre">CvMat</span></tt>  or  <tt class="docutils literal"><span class="pre">IplImage</span></tt>  should be copied to (<tt class="docutils literal"><span class="pre">true</span></tt>) or shared with (<tt class="docutils literal"><span class="pre">false</span></tt>) the newly constructed matrix. When the data is copied, the allocated buffer is managed using  <tt class="docutils literal"><span class="pre">Mat</span></tt> reference counting mechanism. While the data is shared, the reference counter is NULL, and you should not deallocate the data until the matrix is not destructed.</li>
<li><strong>rowRange</strong> – Range of the  <tt class="docutils literal"><span class="pre">m</span></tt> rows to take. As usual, the range start is inclusive and the range end is exclusive. Use  <tt class="docutils literal"><span class="pre">Range::all()</span></tt>  to take all the rows.</li>
<li><strong>colRange</strong> – Range of the  <tt class="docutils literal"><span class="pre">m</span></tt> columns to take. Use  <tt class="docutils literal"><span class="pre">Range::all()</span></tt>  to take all the columns.</li>
<li><strong>ranges</strong> – Array of selected ranges of  <tt class="docutils literal"><span class="pre">m</span></tt>  along each dimensionality.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These are various constructors that form a matrix. As noted in the <a class="reference internal" href="intro.html#automaticallocation"><em>Automatic Allocation of the Output Data</em></a>,
often the default constructor is enough, and the proper matrix will be allocated by an OpenCV function. The constructed matrix can further be assigned to another matrix or matrix expression or can be allocated with
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> . In the former case, the old content is de-referenced.</p>
</div>
<div class="section" id="id1">
<h2>Mat::~Mat<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The Mat destructor.</p>
<dl class="function">
<dt id="Mat::~Mat()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">Mat::</tt><tt class="descname">~Mat</tt><big>(</big><big>)</big><a class="headerlink" href="#Mat::~Mat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The matrix destructor calls <a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></tt></a> .</p>
</div>
<div class="section" id="mat-operator">
<h2>Mat::operator =<a class="headerlink" href="#mat-operator" title="Permalink to this headline">¶</a></h2>
<p>Provides matrix assignment operators.</p>
<dl class="function">
<dt id="Mat&amp; Mat::operator = (const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt>Mat&amp; <tt class="descclassname">Mat::</tt><tt class="descname">operator=</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#Mat&amp; Mat::operator = (const Mat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat&amp; Mat::operator =(const MatExpr&amp; expr)">
<strong>C++:</strong><tt class="descname"> </tt>Mat&amp; <tt class="descclassname">Mat::</tt><tt class="descname">operator=</tt><big>(</big>const MatExpr&amp; <strong>expr</strong><big>)</big><a class="headerlink" href="#Mat&amp; Mat::operator =(const MatExpr&amp; expr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat&amp; Mat::operator = (const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt>Mat&amp; <tt class="descclassname">Mat::</tt><tt class="descname">operator=</tt><big>(</big>const Scalar&amp; <strong>s</strong><big>)</big><a class="headerlink" href="#Mat&amp; Mat::operator = (const Scalar&amp; s)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that no data is copied but the data is shared and the reference counter, if any, is incremented. Before assigning new data, the old data is de-referenced via  <a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></tt></a> .</li>
<li><strong>expr</strong> – Assigned matrix expression object. As opposite to the first form of the assignment operation, the second form can reuse already allocated matrix if it has the right size and type to fit the matrix expression result. It is automatically handled by the real function that the matrix expressions is expanded to. For example,  <tt class="docutils literal"><span class="pre">C=A+B</span></tt>  is expanded to  <tt class="docutils literal"><span class="pre">add(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></tt>, and  <tt class="xref py py-func docutils literal"><span class="pre">add()</span></tt>  takes care of automatic  <tt class="docutils literal"><span class="pre">C</span></tt>  reallocation.</li>
<li><strong>s</strong> – Scalar assigned to each matrix element. The matrix size or type is not changed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>These are available assignment operators. Since they all are very different, make sure to read the operator parameters description.</p>
</div>
<div class="section" id="mat-row">
<h2>Mat::row<a class="headerlink" href="#mat-row" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified matrix row.</p>
<dl class="function">
<dt id="Mat Mat::row(int y) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">row</tt><big>(</big>int <strong>y</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::row(int y) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>y</strong> – A 0-based row index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix row and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. Here is the example of one of the classical basic matrix processing operations, <tt class="docutils literal"><span class="pre">axpy</span></tt>, used by LU and many other algorithms:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">matrix_axpy</span><span class="p">(</span><span class="n">Mat</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpha</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In the current implementation, the following code does not work as expected:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="c1">// will not work</span>
</pre></div>
</div>
<p>This happens because <tt class="docutils literal"><span class="pre">A.row(i)</span></tt> forms a temporary header that is further assigned to another header. Remember that each of these operations is O(1), that is, no data is copied. Thus, the above assignment is not true if you may have expected the j-th row to be copied to the i-th row. To achieve that, you should either turn this simple assignment into an expression or use the <a class="reference internal" href="#void Mat::copyTo(OutputArray m) const" title="void Mat::copyTo(OutputArray m) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::copyTo()</span></tt></a> method:</p>
<div class="last highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="p">...</span>
<span class="c1">// works, but looks a bit obscure.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// this is a bit longer, but the recommended method.</span>
<span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">copyTo</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mat-col">
<h2>Mat::col<a class="headerlink" href="#mat-col" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified matrix column.</p>
<dl class="function">
<dt id="Mat Mat::col(int x) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">col</tt><big>(</big>int <strong>x</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::col(int x) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> – A 0-based column index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix column and returns it. This is an O(1) operation, regardless of the matrix size. The underlying data of the new matrix is shared with the original matrix. See also the
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a> description.</p>
</div>
<div class="section" id="mat-rowrange">
<h2>Mat::rowRange<a class="headerlink" href="#mat-rowrange" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified row span.</p>
<dl class="function">
<dt id="Mat Mat::rowRange(int startrow, int endrow) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">rowRange</tt><big>(</big>int <strong>startrow</strong>, int <strong>endrow</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::rowRange(const Range&amp; r) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">rowRange</tt><big>(</big>const Range&amp; <strong>r</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::rowRange(const Range&amp; r) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>startrow</strong> – An inclusive 0-based start index of the row span.</li>
<li><strong>endrow</strong> – An exclusive 0-based ending index of the row span.</li>
<li><strong>r</strong> – <a class="reference internal" href="#Range" title="class Range"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Range</span></tt></a> structure containing both the start and the end indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified row span of the matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-colrange">
<h2>Mat::colRange<a class="headerlink" href="#mat-colrange" title="Permalink to this headline">¶</a></h2>
<p>Creates a matrix header for the specified column span.</p>
<dl class="function">
<dt id="Mat Mat::colRange(int startcol, int endcol) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">colRange</tt><big>(</big>int <strong>startcol</strong>, int <strong>endcol</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::colRange(const Range&amp; r) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">colRange</tt><big>(</big>const Range&amp; <strong>r</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::colRange(const Range&amp; r) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>startcol</strong> – An inclusive 0-based start index of the column span.</li>
<li><strong>endcol</strong> – An exclusive 0-based ending index of the column span.</li>
<li><strong>r</strong> – <a class="reference internal" href="#Range" title="class Range"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Range</span></tt></a>  structure containing both the start and the end indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified column span of the matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-diag">
<h2>Mat::diag<a class="headerlink" href="#mat-diag" title="Permalink to this headline">¶</a></h2>
<p>Extracts a diagonal from a matrix, or creates a diagonal matrix.</p>
<dl class="function">
<dt id="Mat Mat::diag(int d) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">diag</tt><big>(</big>int <strong>d</strong>=0 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::diag(int d) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static Mat Mat::diag(const Mat&amp; d)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> Mat <tt class="descclassname">Mat::</tt><tt class="descname">diag</tt><big>(</big>const Mat&amp; <strong>d</strong><big>)</big><a class="headerlink" href="#static Mat Mat::diag(const Mat&amp; d)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>d</strong> – <p>Single-column matrix that forms a diagonal matrix or index of the diagonal, with the following values:</p>
<ul>
<li><strong>d=0</strong> is the main diagonal.</li>
<li><strong>d&gt;0</strong> is a diagonal from the lower half. For example,  <tt class="docutils literal"><span class="pre">d=1</span></tt>  means the diagonal is set immediately below the main one.</li>
<li><strong>d&lt;0</strong> is a diagonal from the upper half. For example,  <tt class="docutils literal"><span class="pre">d=1</span></tt>  means the diagonal is set immediately above the main one.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new header for the specified matrix diagonal. The new matrix is represented as a single-column matrix. Similarly to
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a> and
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a> , this is an O(1) operation.</p>
</div>
<div class="section" id="mat-clone">
<h2>Mat::clone<a class="headerlink" href="#mat-clone" title="Permalink to this headline">¶</a></h2>
<p>Creates a full copy of the array and the underlying data.</p>
<dl class="function">
<dt id="Mat Mat::clone() const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">clone</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::clone() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method creates a full copy of the array. The original <tt class="docutils literal"><span class="pre">step[]</span></tt> is not taken into account. So, the array copy is a continuous array occupying <tt class="docutils literal"><span class="pre">total()*elemSize()</span></tt> bytes.</p>
</div>
<div class="section" id="mat-copyto">
<h2>Mat::copyTo<a class="headerlink" href="#mat-copyto" title="Permalink to this headline">¶</a></h2>
<p>Copies the matrix to another one.</p>
<dl class="function">
<dt id="void Mat::copyTo(OutputArray m) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">copyTo</tt><big>(</big>OutputArray <strong>m</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Mat::copyTo(OutputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::copyTo(OutputArray m, InputArray mask) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">copyTo</tt><big>(</big>OutputArray <strong>m</strong>, InputArray <strong>mask</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Mat::copyTo(OutputArray m, InputArray mask) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</li>
<li><strong>mask</strong> – Operation mask. Its non-zero elements indicate which matrix elements need to be copied.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method copies the matrix data to another matrix. Before copying the data, the method invokes</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">m</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">());</span>
</pre></div>
</div>
<p>so that the destination matrix is reallocated if needed. While <tt class="docutils literal"><span class="pre">m.copyTo(m);</span></tt> works flawlessly, the function does not handle the case of a partial overlap between the source and the destination matrices.</p>
<p>When the operation mask is specified, if the <tt class="docutils literal"><span class="pre">Mat::create</span></tt> call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.</p>
</div>
<div class="section" id="mat-convertto">
<span id="id2"></span><h2>Mat::convertTo<a class="headerlink" href="#mat-convertto" title="Permalink to this headline">¶</a></h2>
<p>Converts an array to another data type with optional scaling.</p>
<dl class="function">
<dt id="void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">convertTo</tt><big>(</big>OutputArray <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – output matrix; if it does not have a proper size or type before the operation, it is reallocated.</li>
<li><strong>rtype</strong> – desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if <tt class="docutils literal"><span class="pre">rtype</span></tt>  is negative, the output matrix will have the same type as the input.</li>
<li><strong>alpha</strong> – optional scale factor.</li>
<li><strong>beta</strong> – optional delta added to the scaled values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method converts source pixel values to the target data type. <tt class="docutils literal"><span class="pre">saturate_cast&lt;&gt;</span></tt> is applied at the end to avoid possible overflows:</p>
<div class="math">
<p><img src="../../../_images/math/7aea83a3c27c88e825297d11ed9b4b0f16ca3b08.png" alt="m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )"></p>
</div></div>
<div class="section" id="mat-assignto">
<h2>Mat::assignTo<a class="headerlink" href="#mat-assignto" title="Permalink to this headline">¶</a></h2>
<p>Provides a functional form of <tt class="docutils literal"><span class="pre">convertTo</span></tt>.</p>
<dl class="function">
<dt id="void Mat::assignTo(Mat&amp; m, int type) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">assignTo</tt><big>(</big>Mat&amp; <strong>m</strong>, int <strong>type</strong>=-1 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Mat::assignTo(Mat&amp; m, int type) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Destination array.</li>
<li><strong>type</strong> – Desired destination array depth (or -1 if it should be the same as the source type).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This is an internally used method called by the
<a class="reference internal" href="#matrixexpressions"><em>Matrix Expressions</em></a> engine.</p>
</div>
<div class="section" id="mat-setto">
<h2>Mat::setTo<a class="headerlink" href="#mat-setto" title="Permalink to this headline">¶</a></h2>
<p>Sets all or some of the array elements to the specified value.</p>
<dl class="function">
<dt id="Mat&amp; Mat::setTo(InputArray value, InputArray mask)">
<strong>C++:</strong><tt class="descname"> </tt>Mat&amp; <tt class="descclassname">Mat::</tt><tt class="descname">setTo</tt><big>(</big>InputArray <strong>value</strong>, InputArray <strong>mask</strong>=noArray() <big>)</big><a class="headerlink" href="#Mat&amp; Mat::setTo(InputArray value, InputArray mask)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> – Assigned scalar converted to the actual array type.</li>
<li><strong>mask</strong> – Operation mask of the same size as  <tt class="docutils literal"><span class="pre">*this</span></tt>. This is an advanced variant of the <tt class="docutils literal"><span class="pre">Mat::operator=(const</span> <span class="pre">Scalar&amp;</span> <span class="pre">s)</span></tt> operator.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="mat-reshape">
<h2>Mat::reshape<a class="headerlink" href="#mat-reshape" title="Permalink to this headline">¶</a></h2>
<p>Changes the shape and/or the number of channels of a 2D matrix without copying the data.</p>
<dl class="function">
<dt id="Mat Mat::reshape(int cn, int rows) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">reshape</tt><big>(</big>int <strong>cn</strong>, int <strong>rows</strong>=0<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::reshape(int cn, int rows) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cn</strong> – New number of channels. If the parameter is 0, the number of channels remains the same.</li>
<li><strong>rows</strong> – New number of rows. If the parameter is 0, the number of rows remains the same.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method makes a new matrix header for <tt class="docutils literal"><span class="pre">*this</span></tt> elements. The new matrix may have a different size and/or different number of channels. Any combination is possible if:</p>
<ul class="simple">
<li>No extra elements are included into the new matrix and no elements are excluded. Consequently, the product <tt class="docutils literal"><span class="pre">rows*cols*channels()</span></tt>     must stay the same after the transformation.</li>
<li>No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of rows, or the operation changes the indices of elements row  in some other way, the matrix must be continuous. See
<a class="reference internal" href="#bool Mat::isContinuous() const" title="bool Mat::isContinuous() const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::isContinuous()</span></tt></a> .</li>
</ul>
<p>For example, if there is a set of 3D points stored as an STL vector, and you want to represent the points as a <tt class="docutils literal"><span class="pre">3xN</span></tt> matrix, do the following:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point3f</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">...</span>

<span class="n">Mat</span> <span class="n">pointMat</span> <span class="o">=</span> <span class="n">Mat</span><span class="p">(</span><span class="n">vec</span><span class="p">).</span> <span class="c1">// convert vector to Mat, O(1) operation</span>
                  <span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span> <span class="c1">// make Nx3 1-channel matrix out of Nx1 3-channel.</span>
                              <span class="c1">// Also, an O(1) operation</span>
                     <span class="n">t</span><span class="p">();</span> <span class="c1">// finally, transpose the Nx3 matrix.</span>
                          <span class="c1">// This involves copying all the elements</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-t">
<h2>Mat::t<a class="headerlink" href="#mat-t" title="Permalink to this headline">¶</a></h2>
<p>Transposes a matrix.</p>
<dl class="function">
<dt id="MatExpr Mat::t() const">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">t</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#MatExpr Mat::t() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method performs matrix transposition by means of matrix expressions. It does not perform the actual transposition but returns a temporary matrix transposition object that can be further used as a part of more complex matrix expressions or can be assigned to a matrix:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A1</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">A</span><span class="p">.</span><span class="n">type</span><span class="p">())</span><span class="o">*</span><span class="n">lambda</span><span class="p">;</span>
<span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A1</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span><span class="n">A1</span><span class="p">;</span> <span class="c1">// compute (A + lambda*I)^t * (A + lamda*I)</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-inv">
<h2>Mat::inv<a class="headerlink" href="#mat-inv" title="Permalink to this headline">¶</a></h2>
<p>Inverses a matrix.</p>
<dl class="function">
<dt id="MatExpr Mat::inv(int method) const">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">inv</tt><big>(</big>int <strong>method</strong>=DECOMP_LU<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#MatExpr Mat::inv(int method) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> – <p>Matrix inversion method. Possible values are the following:</p>
<ul>
<li><strong>DECOMP_LU</strong> is the LU decomposition. The matrix must be non-singular.</li>
<li><strong>DECOMP_CHOLESKY</strong> is the Cholesky  <img class="math" src="../../../_images/math/754e16c98cd94dd29be8a3ca818de83fcc0dd0b8.png" alt="LL^T">  decomposition for symmetrical positively defined matrices only. This type is about twice faster than LU on big matrices.</li>
<li><strong>DECOMP_SVD</strong> is the SVD decomposition. If the matrix is singular or even non-square, the pseudo inversion is computed.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method performs a matrix inversion by means of matrix expressions. This means that a temporary matrix inversion object is returned by the method and can be used further as a part of more complex matrix expressions or can be assigned to a matrix.</p>
</div>
<div class="section" id="mat-mul">
<h2>Mat::mul<a class="headerlink" href="#mat-mul" title="Permalink to this headline">¶</a></h2>
<p>Performs an element-wise multiplication or division of the two matrices.</p>
<dl class="function">
<dt id="MatExpr Mat::mul(InputArray m, double scale) const">
<strong>C++:</strong><tt class="descname"> </tt>MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">mul</tt><big>(</big>InputArray <strong>m</strong>, double <strong>scale</strong>=1<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#MatExpr Mat::mul(InputArray m, double scale) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Another array of the same type and the same size as <tt class="docutils literal"><span class="pre">*this</span></tt>, or a matrix expression.</li>
<li><strong>scale</strong> – Optional scale factor.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a temporary object encoding per-element array multiplication, with optional scale. Note that this is not a matrix multiplication that corresponds to a simpler “*” operator.</p>
<p>Example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">5</span><span class="o">/</span><span class="n">B</span><span class="p">);</span> <span class="c1">// equivalent to divide(A, B, C, 5)</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-cross">
<h2>Mat::cross<a class="headerlink" href="#mat-cross" title="Permalink to this headline">¶</a></h2>
<p>Computes a cross-product of two 3-element vectors.</p>
<dl class="function">
<dt id="Mat Mat::cross(InputArray m) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">cross</tt><big>(</big>InputArray <strong>m</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::cross(InputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Another cross-product operand.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method computes a cross-product of two 3-element vectors. The vectors must be 3-element floating-point vectors of the same shape and size. The result is another 3-element vector of the same shape and type as operands.</p>
</div>
<div class="section" id="mat-dot">
<h2>Mat::dot<a class="headerlink" href="#mat-dot" title="Permalink to this headline">¶</a></h2>
<p>Computes a dot-product of two vectors.</p>
<dl class="function">
<dt id="double Mat::dot(InputArray m) const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">Mat::</tt><tt class="descname">dot</tt><big>(</big>InputArray <strong>m</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double Mat::dot(InputArray m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – another dot-product operand.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method computes a dot-product of two matrices. If the matrices are not single-column or single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D vectors. The vectors must have the same size and type. If the matrices have more than one channel, the dot products from all the channels are summed together.</p>
</div>
<div class="section" id="mat-zeros">
<h2>Mat::zeros<a class="headerlink" href="#mat-zeros" title="Permalink to this headline">¶</a></h2>
<p>Returns a zero array of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::zeros(int rows, int cols, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">zeros</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::zeros(Size size, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">zeros</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::zeros(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::zeros(int ndims, const int* sz, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">zeros</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sz</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::zeros(int ndims, const int* sz, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> – Array dimensionality.</li>
<li><strong>rows</strong> – Number of rows.</li>
<li><strong>cols</strong> – Number of columns.</li>
<li><strong>size</strong> – Alternative to the matrix size specification <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt>  .</li>
<li><strong>sz</strong> – Array of integers specifying the array shape.</li>
<li><strong>type</strong> – Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant array as a function parameter, part of a matrix expression, or as a matrix initializer.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span><span class="p">;</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
</pre></div>
</div>
<p>In the example above, a new matrix is allocated only if <tt class="docutils literal"><span class="pre">A</span></tt> is not a 3x3 floating-point matrix. Otherwise, the existing matrix <tt class="docutils literal"><span class="pre">A</span></tt> is filled with zeros.</p>
</div>
<div class="section" id="mat-ones">
<h2>Mat::ones<a class="headerlink" href="#mat-ones" title="Permalink to this headline">¶</a></h2>
<p>Returns an array of all 1’s of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::ones(int rows, int cols, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">ones</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::ones(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::ones(Size size, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">ones</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::ones(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::ones(int ndims, const int* sz, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">ones</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sz</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::ones(int ndims, const int* sz, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> – Array dimensionality.</li>
<li><strong>rows</strong> – Number of rows.</li>
<li><strong>cols</strong> – Number of columns.</li>
<li><strong>size</strong> – Alternative to the matrix size specification  <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt>  .</li>
<li><strong>sz</strong> – Array of integers specifying the array shape.</li>
<li><strong>type</strong> – Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style 1’s array initializer, similarly to
<a class="reference internal" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="static MatExpr Mat::zeros(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::zeros()</span></tt></a>. Note that using this method you can initialize an array with an arbitrary value, using the following Matlab idiom:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_8U</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">;</span> <span class="c1">// make 100x100 matrix filled with 3.</span>
</pre></div>
</div>
<p>The above operation does not form a 100x100 matrix of 1’s and then multiply it by 3. Instead, it just remembers the scale factor (3 in this case) and use it when actually invoking the matrix initializer.</p>
</div>
<div class="section" id="mat-eye">
<h2>Mat::eye<a class="headerlink" href="#mat-eye" title="Permalink to this headline">¶</a></h2>
<p>Returns an identity matrix of the specified size and type.</p>
<dl class="function">
<dt id="static MatExpr Mat::eye(int rows, int cols, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">eye</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::eye(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="static MatExpr Mat::eye(Size size, int type)">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> MatExpr <tt class="descclassname">Mat::</tt><tt class="descname">eye</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#static MatExpr Mat::eye(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rows</strong> – Number of rows.</li>
<li><strong>cols</strong> – Number of columns.</li>
<li><strong>size</strong> – Alternative matrix size specification as  <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt> .</li>
<li><strong>type</strong> – Created matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns a Matlab-style identity matrix initializer, similarly to
<a class="reference internal" href="#static MatExpr Mat::zeros(int rows, int cols, int type)" title="static MatExpr Mat::zeros(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::zeros()</span></tt></a>. Similarly to
<a class="reference internal" href="#static MatExpr Mat::ones(int rows, int cols, int type)" title="static MatExpr Mat::ones(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::ones()</span></tt></a>, you can use a scale operation to create a scaled identity matrix efficiently:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// make a 4x4 diagonal matrix with 0.1's on the diagonal.</span>
<span class="n">Mat</span> <span class="n">A</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-create">
<h2>Mat::create<a class="headerlink" href="#mat-create" title="Permalink to this headline">¶</a></h2>
<p>Allocates new array data if needed.</p>
<dl class="function">
<dt id="void Mat::create(int rows, int cols, int type)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">create</tt><big>(</big>int <strong>rows</strong>, int <strong>cols</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#void Mat::create(int rows, int cols, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::create(Size size, int type)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">create</tt><big>(</big>Size <strong>size</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#void Mat::create(Size size, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::create(int ndims, const int* sizes, int type)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">create</tt><big>(</big>int <strong>ndims</strong>, const int* <strong>sizes</strong>, int <strong>type</strong><big>)</big><a class="headerlink" href="#void Mat::create(int ndims, const int* sizes, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ndims</strong> – New array dimensionality.</li>
<li><strong>rows</strong> – New number of rows.</li>
<li><strong>cols</strong> – New number of columns.</li>
<li><strong>size</strong> – Alternative new matrix size specification:  <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt></li>
<li><strong>sizes</strong> – Array of integers specifying a new array shape.</li>
<li><strong>type</strong> – New matrix type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This is one of the key <tt class="docutils literal"><span class="pre">Mat</span></tt> methods. Most new-style OpenCV functions and methods that produce arrays call this method for each output array. The method uses the following algorithm:</p>
<ol class="arabic simple">
<li>If the current array shape and the type match the new ones, return immediately. Otherwise, de-reference the previous data by calling
<a class="reference internal" href="#void Mat::release()" title="void Mat::release()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::release()</span></tt></a>.</li>
<li>Initialize the new header.</li>
<li>Allocate the new data of <tt class="docutils literal"><span class="pre">total()*elemSize()</span></tt>     bytes.</li>
<li>Allocate the new, associated with the data, reference counter and set it to 1.</li>
</ol>
<p>Such a scheme makes the memory management robust and efficient at the same time and helps avoid extra typing for you. This means that usually there is no need to explicitly allocate output arrays. That is, instead of writing:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">depth</span><span class="p">());</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
</pre></div>
</div>
<p>you can simply write:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">color</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">Mat</span> <span class="n">gray</span><span class="p">;</span>
<span class="n">cvtColor</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">gray</span><span class="p">,</span> <span class="n">COLOR_BGR2GRAY</span><span class="p">);</span>
</pre></div>
</div>
<p>because <tt class="docutils literal"><span class="pre">cvtColor</span></tt> , as well as the most of OpenCV functions, calls <tt class="docutils literal"><span class="pre">Mat::create()</span></tt> for the output array internally.</p>
</div>
<div class="section" id="mat-addref">
<h2>Mat::addref<a class="headerlink" href="#mat-addref" title="Permalink to this headline">¶</a></h2>
<p>Increments the reference counter.</p>
<dl class="function">
<dt id="void Mat::addref()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">addref</tt><big>(</big><big>)</big><a class="headerlink" href="#void Mat::addref()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method increments the reference counter associated with the matrix data. If the matrix header points to an external data set (see
<a class="reference internal" href="#Mat::Mat()" title="Mat::Mat()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::Mat()</span></tt></a> ), the reference counter is NULL, and the method has no effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It is called implicitly by the matrix assignment operator. The reference counter increment is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
</div>
<div class="section" id="mat-release">
<h2>Mat::release<a class="headerlink" href="#mat-release" title="Permalink to this headline">¶</a></h2>
<p>Decrements the reference counter and deallocates the matrix if needed.</p>
<dl class="function">
<dt id="void Mat::release()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#void Mat::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method decrements the reference counter associated with the matrix data. When the reference counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers are set to NULL’s. If the matrix header points to an external data set (see
<a class="reference internal" href="#Mat::Mat()" title="Mat::Mat()"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::Mat()</span></tt></a> ), the reference counter is NULL, and the method has no effect in this case.</p>
<p>This method can be called manually to force the matrix data deallocation. But since this method is automatically called in the destructor, or by any other method that changes the data pointer, it is usually not needed. The reference counter decrement and check for 0 is an atomic operation on the platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in different threads.</p>
</div>
<div class="section" id="mat-resize">
<h2>Mat::resize<a class="headerlink" href="#mat-resize" title="Permalink to this headline">¶</a></h2>
<p>Changes the number of matrix rows.</p>
<dl class="function">
<dt id="void Mat::resize(size_t sz)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">resize</tt><big>(</big>size_t <strong>sz</strong><big>)</big><a class="headerlink" href="#void Mat::resize(size_t sz)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::resize(size_t sz, const Scalar&amp; s)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">resize</tt><big>(</big>size_t <strong>sz</strong>, const Scalar&amp; <strong>s</strong><big>)</big><a class="headerlink" href="#void Mat::resize(size_t sz, const Scalar&amp; s)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sz</strong> – New number of rows.</li>
<li><strong>s</strong> – Value assigned to the newly added elements.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods change the number of matrix rows. If the matrix is reallocated, the first <tt class="docutils literal"><span class="pre">min(Mat::rows,</span> <span class="pre">sz)</span></tt> rows are preserved. The methods emulate the corresponding methods of the STL vector class.</p>
</div>
<div class="section" id="mat-reserve">
<h2>Mat::reserve<a class="headerlink" href="#mat-reserve" title="Permalink to this headline">¶</a></h2>
<p>Reserves space for the certain number of rows.</p>
<dl class="function">
<dt id="void Mat::reserve(size_t sz)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">reserve</tt><big>(</big>size_t <strong>sz</strong><big>)</big><a class="headerlink" href="#void Mat::reserve(size_t sz)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sz</strong> – Number of rows.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method reserves space for <tt class="docutils literal"><span class="pre">sz</span></tt> rows. If the matrix already has enough space to store <tt class="docutils literal"><span class="pre">sz</span></tt> rows, nothing happens. If the matrix is reallocated, the first <tt class="docutils literal"><span class="pre">Mat::rows</span></tt> rows are preserved. The method emulates the corresponding method of the STL vector class.</p>
</div>
<div class="section" id="mat-push-back">
<h2>Mat::push_back<a class="headerlink" href="#mat-push-back" title="Permalink to this headline">¶</a></h2>
<p>Adds elements to the bottom of the matrix.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; void Mat::push_back(const T&amp; elem)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; void <tt class="descclassname">Mat::</tt><tt class="descname">push_back</tt><big>(</big>const T&amp; <strong>elem</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; void Mat::push_back(const T&amp; elem)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Mat::push_back(const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">push_back</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#void Mat::push_back(const Mat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>elem</strong> – Added element(s).</li>
<li><strong>m</strong> – Added line(s).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods add one or more elements to the bottom of the matrix. They emulate the corresponding method of the STL vector class. When <tt class="docutils literal"><span class="pre">elem</span></tt> is <tt class="docutils literal"><span class="pre">Mat</span></tt> , its type and the number of columns must be the same as in the container matrix.</p>
</div>
<div class="section" id="mat-pop-back">
<h2>Mat::pop_back<a class="headerlink" href="#mat-pop-back" title="Permalink to this headline">¶</a></h2>
<p>Removes elements from the bottom of the matrix.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; void Mat::pop_back(size_t nelems)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; void <tt class="descclassname">Mat::</tt><tt class="descname">pop_back</tt><big>(</big>size_t <strong>nelems</strong>=1<big>)</big><a class="headerlink" href="#template&lt;typename T&gt; void Mat::pop_back(size_t nelems)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nelems</strong> – Number of removed rows. If it is greater than the total number of rows, an exception is thrown.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method removes one or more rows from the bottom of the matrix.</p>
</div>
<div class="section" id="mat-locateroi">
<h2>Mat::locateROI<a class="headerlink" href="#mat-locateroi" title="Permalink to this headline">¶</a></h2>
<p>Locates the matrix header within a parent matrix.</p>
<dl class="function">
<dt id="void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Mat::</tt><tt class="descname">locateROI</tt><big>(</big>Size&amp; <strong>wholeSize</strong>, Point&amp; <strong>ofs</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>wholeSize</strong> – Output parameter that contains the size of the whole matrix containing <tt class="docutils literal"><span class="pre">*this</span></tt> as a part.</li>
<li><strong>ofs</strong> – Output parameter that contains an offset of  <tt class="docutils literal"><span class="pre">*this</span></tt>  inside the whole matrix.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>After you extracted a submatrix from a matrix using
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Mat Mat::rowRange(int startrow, int endrow) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::rowRange()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Mat Mat::colRange(int startcol, int endcol) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::colRange()</span></tt></a> , and others, the resultant submatrix points just to the part of the original big matrix. However, each submatrix contains information (represented by <tt class="docutils literal"><span class="pre">datastart</span></tt> and <tt class="docutils literal"><span class="pre">dataend</span></tt> fields) that helps reconstruct the original matrix size and the position of the extracted submatrix within the original matrix. The method <tt class="docutils literal"><span class="pre">locateROI</span></tt> does exactly that.</p>
</div>
<div class="section" id="mat-adjustroi">
<h2>Mat::adjustROI<a class="headerlink" href="#mat-adjustroi" title="Permalink to this headline">¶</a></h2>
<p>Adjusts a submatrix size and position within the parent matrix.</p>
<dl class="function">
<dt id="Mat&amp; Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)">
<strong>C++:</strong><tt class="descname"> </tt>Mat&amp; <tt class="descclassname">Mat::</tt><tt class="descname">adjustROI</tt><big>(</big>int <strong>dtop</strong>, int <strong>dbottom</strong>, int <strong>dleft</strong>, int <strong>dright</strong><big>)</big><a class="headerlink" href="#Mat&amp; Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dtop</strong> – Shift of the top submatrix boundary upwards.</li>
<li><strong>dbottom</strong> – Shift of the bottom submatrix boundary downwards.</li>
<li><strong>dleft</strong> – Shift of the left submatrix boundary to the left.</li>
<li><strong>dright</strong> – Shift of the right submatrix boundary to the right.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method is complimentary to
<a class="reference internal" href="#void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const" title="void Mat::locateROI(Size&amp; wholeSize, Point&amp; ofs) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::locateROI()</span></tt></a> . The typical use of these functions is to determine the submatrix position within the parent matrix and then shift the position somehow. Typically, it can be required for filtering operations when pixels outside of the ROI should be taken into account. When all the method parameters are positive, the ROI needs to grow in all directions by the specified amount, for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">A</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the filtering with the 5x5 kernel.</p>
<p><tt class="docutils literal"><span class="pre">adjustROI</span></tt> forces the adjusted ROI to be inside of the parent matrix that is boundaries of the adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix <tt class="docutils literal"><span class="pre">A</span></tt> is located in the first row of a parent matrix and you called <tt class="docutils literal"><span class="pre">A.adjustROI(2,</span> <span class="pre">2,</span> <span class="pre">2,</span> <span class="pre">2)</span></tt> then <tt class="docutils literal"><span class="pre">A</span></tt> will not be increased in the upward direction.</p>
<p>The function is used internally by the OpenCV filtering functions, like
<a class="reference internal" href="../../imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)" title="void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">filter2D()</span></tt></a> , morphological operations, and so on.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="operations_on_arrays.html#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)" title="void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar&amp; value)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">copyMakeBorder()</span></tt></a></p>
</div>
</div>
<div class="section" id="id3">
<h2>Mat::operator()<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Extracts a rectangular submatrix.</p>
<dl class="function">
<dt id="Mat Mat::operator()(Range rowRange, Range colRange) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">operator()</tt><big>(</big>Range <strong>rowRange</strong>, Range <strong>colRange</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::operator()(Range rowRange, Range colRange) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::operator()(const Rect&amp; roi) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">operator()</tt><big>(</big>const Rect&amp; <strong>roi</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::operator()(const Rect&amp; roi) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="Mat Mat::operator()(const Range* ranges) const">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descclassname">Mat::</tt><tt class="descname">operator()</tt><big>(</big>const Range* <strong>ranges</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Mat Mat::operator()(const Range* ranges) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rowRange</strong> – Start and end row of the extracted submatrix. The upper boundary is not included. To select all the rows, use <tt class="docutils literal"><span class="pre">Range::all()</span></tt>.</li>
<li><strong>colRange</strong> – Start and end column of the extracted submatrix. The upper boundary is not included. To select all the columns, use  <tt class="docutils literal"><span class="pre">Range::all()</span></tt>.</li>
<li><strong>roi</strong> – Extracted submatrix specified as a rectangle.</li>
<li><strong>ranges</strong> – Array of selected ranges along each array dimension.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The operators make a new header for the specified sub-array of <tt class="docutils literal"><span class="pre">*this</span></tt> . They are the most generalized forms of
<a class="reference internal" href="#Mat Mat::row(int y) const" title="Mat Mat::row(int y) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::row()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::rowRange(int startrow, int endrow) const" title="Mat Mat::rowRange(int startrow, int endrow) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::rowRange()</span></tt></a>, and
<a class="reference internal" href="#Mat Mat::colRange(int startcol, int endcol) const" title="Mat Mat::colRange(int startcol, int endcol) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::colRange()</span></tt></a> . For example, <tt class="docutils literal"><span class="pre">A(Range(0,</span> <span class="pre">10),</span> <span class="pre">Range::all())</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">A.rowRange(0,</span> <span class="pre">10)</span></tt> . Similarly to all of the above, the operators are O(1) operations, that is, no matrix data is copied.</p>
</div>
<div class="section" id="mat-total">
<h2>Mat::total<a class="headerlink" href="#mat-total" title="Permalink to this headline">¶</a></h2>
<p>Returns the total number of array elements.</p>
<dl class="function">
<dt id="size_t Mat::total() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">Mat::</tt><tt class="descname">total</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t Mat::total() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of array elements (a number of pixels if the array represents an image).</p>
</div>
<div class="section" id="mat-iscontinuous">
<h2>Mat::isContinuous<a class="headerlink" href="#mat-iscontinuous" title="Permalink to this headline">¶</a></h2>
<p>Reports whether the matrix is continuous or not.</p>
<dl class="function">
<dt id="bool Mat::isContinuous() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">Mat::</tt><tt class="descname">isContinuous</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool Mat::isContinuous() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns <tt class="docutils literal"><span class="pre">true</span></tt> if the matrix elements are stored continuously without gaps at the end of each row. Otherwise, it returns <tt class="docutils literal"><span class="pre">false</span></tt>. Obviously, <tt class="docutils literal"><span class="pre">1x1</span></tt> or <tt class="docutils literal"><span class="pre">1xN</span></tt> matrices are always continuous. Matrices created with
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> are always continuous. But if you extract a part of the matrix using
<a class="reference internal" href="#Mat Mat::col(int x) const" title="Mat Mat::col(int x) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::col()</span></tt></a>,
<a class="reference internal" href="#Mat Mat::diag(int d) const" title="Mat Mat::diag(int d) const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::diag()</span></tt></a> , and so on, or constructed a matrix header for externally allocated data, such matrices may no longer have this property.</p>
<p>The continuity flag is stored as a bit in the <tt class="docutils literal"><span class="pre">Mat::flags</span></tt> field and is computed automatically when you construct a matrix header. Thus, the continuity check is a very fast operation, though theoretically it could be done as follows:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// alternative implementation of Mat::isContinuous()</span>
<span class="kt">bool</span> <span class="nf">myCheckMatContinuity</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//return (m.flags &amp; Mat::CONTINUOUS_FLAG) != 0;</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">m</span><span class="p">.</span><span class="n">step</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="o">*</span><span class="n">m</span><span class="p">.</span><span class="n">elemSize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The method is used in quite a few of OpenCV functions. The point is that element-wise operations (such as arithmetic and logical operations, math functions, alpha blending, color space transformations, and others) do not depend on the image geometry. Thus, if all the input and output arrays are continuous, the functions can process them as very long single-row vectors. The example below illustrates how an alpha-blending function can be implemented.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_MAKETYPE</span><span class="p">(</span><span class="n">DataType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">depth</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="c1">// here is the idiom: check the arrays for continuity and,</span>
    <span class="c1">// if this is the case,</span>
    <span class="c1">// treat the arrays as 1D vectors</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">src2</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">dst</span><span class="p">.</span><span class="n">isContinuous</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// when the arrays are continuous,</span>
        <span class="c1">// the outer loop is executed only once</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">dptr</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="mi">4</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">ptr2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">);</span>
            <span class="n">dptr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This approach, while being very simple, can boost the performance of a simple element-operation by 10-20 percents, especially if the image is rather small and the operation is quite simple.</p>
<p>Another OpenCV idiom in this function, a call of
<a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> for the destination array, that allocates the destination array unless it already has the proper size and type. And while the newly allocated arrays are always continuous, you still need to check the destination array because <a class="reference internal" href="#void Mat::create(int rows, int cols, int type)" title="void Mat::create(int rows, int cols, int type)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::create()</span></tt></a> does not always allocate a new matrix.</p>
</div>
<div class="section" id="mat-elemsize">
<h2>Mat::elemSize<a class="headerlink" href="#mat-elemsize" title="Permalink to this headline">¶</a></h2>
<p>Returns  the matrix element size in bytes.</p>
<dl class="function">
<dt id="size_t Mat::elemSize() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">Mat::</tt><tt class="descname">elemSize</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t Mat::elemSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the matrix element size in bytes. For example, if the matrix type is <tt class="docutils literal"><span class="pre">CV_16SC3</span></tt> , the method returns <tt class="docutils literal"><span class="pre">3*sizeof(short)</span></tt> or 6.</p>
</div>
<div class="section" id="mat-elemsize1">
<h2>Mat::elemSize1<a class="headerlink" href="#mat-elemsize1" title="Permalink to this headline">¶</a></h2>
<p>Returns the size of each matrix element channel in bytes.</p>
<dl class="function">
<dt id="size_t Mat::elemSize1() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">Mat::</tt><tt class="descname">elemSize1</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t Mat::elemSize1() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the matrix element channel size in bytes, that is, it ignores the number of channels. For example, if the matrix type is <tt class="docutils literal"><span class="pre">CV_16SC3</span></tt> , the method returns <tt class="docutils literal"><span class="pre">sizeof(short)</span></tt> or 2.</p>
</div>
<div class="section" id="mat-type">
<h2>Mat::type<a class="headerlink" href="#mat-type" title="Permalink to this headline">¶</a></h2>
<p>Returns the type of a matrix element.</p>
<dl class="function">
<dt id="int Mat::type() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">Mat::</tt><tt class="descname">type</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int Mat::type() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix element type. This is an identifier compatible with the <tt class="docutils literal"><span class="pre">CvMat</span></tt> type system, like <tt class="docutils literal"><span class="pre">CV_16SC3</span></tt> or 16-bit signed 3-channel array, and so on.</p>
</div>
<div class="section" id="mat-depth">
<h2>Mat::depth<a class="headerlink" href="#mat-depth" title="Permalink to this headline">¶</a></h2>
<p>Returns the depth of a matrix element.</p>
<dl class="function">
<dt id="int Mat::depth() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">Mat::</tt><tt class="descname">depth</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int Mat::depth() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed element array, the method returns <tt class="docutils literal"><span class="pre">CV_16S</span></tt> . A complete list of matrix types contains the following values:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CV_8U</span></tt>     - 8-bit unsigned integers ( <tt class="docutils literal"><span class="pre">0..255</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_8S</span></tt>     - 8-bit signed integers ( <tt class="docutils literal"><span class="pre">-128..127</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_16U</span></tt>     - 16-bit unsigned integers ( <tt class="docutils literal"><span class="pre">0..65535</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_16S</span></tt>     - 16-bit signed integers ( <tt class="docutils literal"><span class="pre">-32768..32767</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_32S</span></tt>     - 32-bit signed integers ( <tt class="docutils literal"><span class="pre">-2147483648..2147483647</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_32F</span></tt>     - 32-bit floating-point numbers ( <tt class="docutils literal"><span class="pre">-FLT_MAX..FLT_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_64F</span></tt>     - 64-bit floating-point numbers ( <tt class="docutils literal"><span class="pre">-DBL_MAX..DBL_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></tt>     )</li>
</ul>
</div>
<div class="section" id="mat-channels">
<h2>Mat::channels<a class="headerlink" href="#mat-channels" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of matrix channels.</p>
<dl class="function">
<dt id="int Mat::channels() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">Mat::</tt><tt class="descname">channels</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int Mat::channels() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of matrix channels.</p>
</div>
<div class="section" id="mat-step1">
<h2>Mat::step1<a class="headerlink" href="#mat-step1" title="Permalink to this headline">¶</a></h2>
<p>Returns a normalized step.</p>
<dl class="function">
<dt id="size_t Mat::step1(int i) const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">Mat::</tt><tt class="descname">step1</tt><big>(</big>int <strong>i</strong>=0 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t Mat::step1(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix step divided by
<a class="reference internal" href="#size_t Mat::elemSize1() const" title="size_t Mat::elemSize1() const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::elemSize1()</span></tt></a> . It can be useful to quickly access an arbitrary matrix element.</p>
</div>
<div class="section" id="mat-size">
<h2>Mat::size<a class="headerlink" href="#mat-size" title="Permalink to this headline">¶</a></h2>
<p>Returns a matrix size.</p>
<dl class="function">
<dt id="Size Mat::size() const">
<strong>C++:</strong><tt class="descname"> </tt>Size <tt class="descclassname">Mat::</tt><tt class="descname">size</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#Size Mat::size() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a matrix size: <tt class="docutils literal"><span class="pre">Size(cols,</span> <span class="pre">rows)</span></tt> . When the matrix is more than 2-dimensional, the returned size is (-1, -1).</p>
</div>
<div class="section" id="mat-empty">
<h2>Mat::empty<a class="headerlink" href="#mat-empty" title="Permalink to this headline">¶</a></h2>
<p>Returns <tt class="docutils literal"><span class="pre">true</span></tt> if the array has no elements.</p>
<dl class="function">
<dt id="bool Mat::empty() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">Mat::</tt><tt class="descname">empty</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool Mat::empty() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">Mat::total()</span></tt> is 0 or if <tt class="docutils literal"><span class="pre">Mat::data</span></tt> is NULL. Because of <tt class="docutils literal"><span class="pre">pop_back()</span></tt> and <tt class="docutils literal"><span class="pre">resize()</span></tt> methods <tt class="docutils literal"><span class="pre">M.total()</span> <span class="pre">==</span> <span class="pre">0</span></tt> does not imply that <tt class="docutils literal"><span class="pre">M.data</span> <span class="pre">==</span> <span class="pre">NULL</span></tt> .</p>
</div>
<div class="section" id="mat-ptr">
<h2>Mat::ptr<a class="headerlink" href="#mat-ptr" title="Permalink to this headline">¶</a></h2>
<p>Returns a pointer to the specified matrix row.</p>
<dl class="function">
<dt id="uchar* Mat::ptr(int i0)">
<strong>C++:</strong><tt class="descname"> </tt>uchar* <tt class="descclassname">Mat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>=0<big>)</big><a class="headerlink" href="#uchar* Mat::ptr(int i0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="const uchar* Mat::ptr(int i0) const">
<strong>C++:</strong><tt class="descname"> </tt>const uchar* <tt class="descclassname">Mat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>=0<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#const uchar* Mat::ptr(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; _Tp* Mat::ptr(int i0)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; _Tp* <tt class="descclassname">Mat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>=0<big>)</big><a class="headerlink" href="#template&lt;typename _Tp&gt; _Tp* Mat::ptr(int i0)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; const _Tp* Mat::ptr(int i0) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; const _Tp* <tt class="descclassname">Mat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>=0<big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename _Tp&gt; const _Tp* Mat::ptr(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> – A 0-based row index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The methods return <tt class="docutils literal"><span class="pre">uchar*</span></tt> or typed pointer to the specified matrix row. See the sample in
<a class="reference internal" href="#bool Mat::isContinuous() const" title="bool Mat::isContinuous() const"><tt class="xref ocv ocv-func docutils literal"><span class="pre">Mat::isContinuous()</span></tt></a> to know how to use these methods.</p>
</div>
<div class="section" id="mat-at">
<h2>Mat::at<a class="headerlink" href="#mat-at" title="Permalink to this headline">¶</a></h2>
<p>Returns a reference to the specified array element.</p>
<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; T&amp; Mat::at(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; const T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; const T&amp; Mat::at(int i) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i, int j)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong>, int <strong>j</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; T&amp; Mat::at(int i, int j)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i, int j) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; const T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong>, int <strong>j</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; const T&amp; Mat::at(int i, int j) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(Point pt)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>Point <strong>pt</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; T&amp; Mat::at(Point pt)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(Point pt) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; const T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>Point <strong>pt</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; const T&amp; Mat::at(Point pt) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(int i, int j, int k)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong>, int <strong>j</strong>, int <strong>k</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; T&amp; Mat::at(int i, int j, int k)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(int i, int j, int k) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; const T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>int <strong>i</strong>, int <strong>j</strong>, int <strong>k</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; const T&amp; Mat::at(int i, int j, int k) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; T&amp; Mat::at(const int* idx)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>const int* <strong>idx</strong><big>)</big><a class="headerlink" href="#template&lt;typename T&gt; T&amp; Mat::at(const int* idx)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename T&gt; const T&amp; Mat::at(const int* idx) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename T&gt; const T&amp; <tt class="descclassname">Mat::</tt><tt class="descname">at</tt><big>(</big>const int* <strong>idx</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename T&gt; const T&amp; Mat::at(const int* idx) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> – Index along the dimension 0</li>
<li><strong>j</strong> – Index along the dimension 1</li>
<li><strong>k</strong> – Index along the dimension 2</li>
<li><strong>pt</strong> – Element position specified as  <tt class="docutils literal"><span class="pre">Point(j,i)</span></tt> .</li>
<li><strong>idx</strong> – Array of  <tt class="docutils literal"><span class="pre">Mat::dims</span></tt>  indices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The template methods return a reference to the specified array element. For the sake of higher performance, the index range checks are only performed in the Debug configuration.</p>
<p>Note that the variants with a single index (i) can be used to access elements of single-row or single-column 2-dimensional arrays. That is, if, for example, <tt class="docutils literal"><span class="pre">A</span></tt> is a <tt class="docutils literal"><span class="pre">1</span> <span class="pre">x</span> <span class="pre">N</span></tt> floating-point matrix and <tt class="docutils literal"><span class="pre">B</span></tt> is an <tt class="docutils literal"><span class="pre">M</span> <span class="pre">x</span> <span class="pre">1</span></tt> integer matrix, you can simply write <tt class="docutils literal"><span class="pre">A.at&lt;float&gt;(k+4)</span></tt> and <tt class="docutils literal"><span class="pre">B.at&lt;int&gt;(2*i+1)</span></tt> instead of <tt class="docutils literal"><span class="pre">A.at&lt;float&gt;(0,k+4)</span></tt> and <tt class="docutils literal"><span class="pre">B.at&lt;int&gt;(2*i+1,0)</span></tt> , respectively.</p>
<p>The example below initializes a Hilbert matrix:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">H</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">CV_64F</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">H</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">H</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-begin">
<h2>Mat::begin<a class="headerlink" href="#mat-begin" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix iterator and sets it to the first matrix element.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::begin()">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; <tt class="descclassname">Mat::</tt><tt class="descname">begin</tt><big>(</big><big>)</big><a class="headerlink" href="#template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::begin()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::begin() const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; <tt class="descclassname">Mat::</tt><tt class="descname">begin</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::begin() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very similar to the use of bi-directional STL iterators. In the example below, the alpha blending function is rewritten using the matrix iterators:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">alphaBlendRGBA</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">src2</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">VT</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">float</span> <span class="n">alpha_scale</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span>
                <span class="n">inv_scale</span> <span class="o">=</span> <span class="mf">1.f</span><span class="o">/</span><span class="n">alpha_scale</span><span class="p">;</span>

    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">DataType</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;&amp;</span>
               <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">src2</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">Size</span> <span class="n">size</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">src1</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>

    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it1</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">it1_end</span> <span class="o">=</span> <span class="n">src1</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">it2</span> <span class="o">=</span> <span class="n">src2</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MatIterator_</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span> <span class="n">dst_it</span> <span class="o">=</span> <span class="n">dst</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">VT</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it1</span> <span class="o">!=</span> <span class="n">it1_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it1</span><span class="p">,</span> <span class="o">++</span><span class="n">it2</span><span class="p">,</span> <span class="o">++</span><span class="n">dst_it</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">VT</span> <span class="n">pix1</span> <span class="o">=</span> <span class="o">*</span><span class="n">it1</span><span class="p">,</span> <span class="n">pix2</span> <span class="o">=</span> <span class="o">*</span><span class="n">it2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">alpha</span> <span class="o">=</span> <span class="n">pix1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">inv_scale</span><span class="p">;</span>
        <span class="o">*</span><span class="n">dst_it</span> <span class="o">=</span> <span class="n">VT</span><span class="p">(</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">pix2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">beta</span><span class="p">),</span>
                     <span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">beta</span><span class="p">))</span><span class="o">*</span><span class="n">alpha_scale</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mat-end">
<h2>Mat::end<a class="headerlink" href="#mat-end" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix iterator and sets it to the after-last matrix element.</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::end()">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; <tt class="descclassname">Mat::</tt><tt class="descname">end</tt><big>(</big><big>)</big><a class="headerlink" href="#template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; Mat::end()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::end() const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; <tt class="descclassname">Mat::</tt><tt class="descname">end</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; Mat::end() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The methods return the matrix read-only or read-write iterators, set to the point following the last matrix element.</p>
</div>
<div class="section" id="mat-foreach">
<h2>Mat::forEach<a class="headerlink" href="#mat-foreach" title="Permalink to this headline">¶</a></h2>
<p>Invoke with arguments functor, and runs the functor over all matrix element.</p>
<dl class="function">
<dt id="template&lt;typename _Tp, typename Functor&gt; void Mat::forEach(Functor operation)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp, typename Functor&gt; void <tt class="descclassname">Mat::</tt><tt class="descname">forEach</tt><big>(</big>Functor <strong>operation</strong><big>)</big><a class="headerlink" href="#template&lt;typename _Tp, typename Functor&gt; void Mat::forEach(Functor operation)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="template&lt;typename _Tp, typename Functor&gt; void Mat::forEach(Functor operation) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp, typename Functor&gt; void <tt class="descclassname">Mat::</tt><tt class="descname">forEach</tt><big>(</big>Functor <strong>operation</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename _Tp, typename Functor&gt; void Mat::forEach(Functor operation) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The methos runs operation in parallel. Operation is passed by arguments. Operation have to be a function pointer, a function object or a lambda(C++11).</p>
<p>All of below operation is equal. Put 0xFF to first channel of all matrix elements.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="nf">image</span><span class="p">(</span><span class="mi">1920</span><span class="p">,</span> <span class="mi">1080</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">Pixel</span><span class="p">;</span>

<span class="c1">// first. raw pointer access.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Pixel</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Pixel</span><span class="o">*</span> <span class="n">ptr_end</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">ptr_end</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="c1">// Using MatIterator. (Simple but there are a Iterator's overhead)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">image</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// Parallel execution with function object.</span>
<span class="k">struct</span> <span class="n">Operator</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()(</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="n">pixel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">image</span><span class="p">.</span><span class="n">forEach</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Operator</span><span class="p">());</span>


<span class="c1">// Parallel execution using C++11 lambda.</span>
<span class="n">image</span><span class="p">.</span><span class="n">forEach</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">Pixel</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">position</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>position parameter is index of current pixel.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Creating 3D matrix (255 x 255 x 255) typed uint8_t,</span>
<span class="c1">//  and initialize all elements by the value which equals elements position.</span>
<span class="c1">//  i.e. pixels (x,y,z) = (1,2,3) is (b,g,r) = (1,2,3).</span>

<span class="kt">int</span> <span class="n">sizes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span> <span class="p">};</span>
<span class="k">typedef</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point3_</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">Pixel</span><span class="p">;</span>

<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Pixel</span><span class="o">&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">CV_8UC3</span><span class="p">);</span>

<span class="n">image</span><span class="p">.</span><span class="n">forEachWithPosition</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Pixel</span><span class="o">&amp;</span> <span class="n">pixel</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">position</span><span class="p">[])</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">{</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2>Mat_<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Mat_">
<em class="property">class </em><tt class="descname">Mat_</tt><a class="headerlink" href="#Mat_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template matrix class derived from
<a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> .</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Mat_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Mat</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ... some specific methods</span>
    <span class="c1">//         and</span>
    <span class="c1">// no new extra fields</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class <tt class="docutils literal"><span class="pre">Mat_&lt;_Tp&gt;</span></tt> is a “thin” template wrapper on top of the <tt class="docutils literal"><span class="pre">Mat</span></tt> class. It does not have any extra data fields. Nor this class nor <tt class="docutils literal"><span class="pre">Mat</span></tt> has any virtual methods. Thus, references or pointers to these two classes can be freely but carefully converted one to another. For example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// create a 100x100 8-bit matrix</span>
<span class="n">Mat</span> <span class="nf">M</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">CV_8U</span><span class="p">);</span>
<span class="c1">// this will be compiled fine. no any data conversion will be done.</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">M1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span><span class="p">)</span><span class="n">M</span><span class="p">;</span>
<span class="c1">// the program is likely to crash at the statement below</span>
<span class="n">M1</span><span class="p">(</span><span class="mi">99</span><span class="p">,</span><span class="mi">99</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.f</span><span class="p">;</span>
</pre></div>
</div>
<p>While <tt class="docutils literal"><span class="pre">Mat</span></tt> is sufficient in most cases, <tt class="docutils literal"><span class="pre">Mat_</span></tt> can be more convenient if you use a lot of element access operations and if you know matrix type at the compilation time. Note that <tt class="docutils literal"><span class="pre">Mat::at&lt;_Tp&gt;(int</span> <span class="pre">y,</span> <span class="pre">int</span> <span class="pre">x)</span></tt> and <tt class="docutils literal"><span class="pre">Mat_&lt;_Tp&gt;::operator</span> <span class="pre">()(int</span> <span class="pre">y,</span> <span class="pre">int</span> <span class="pre">x)</span></tt> do absolutely the same and run at the same speed, but the latter is certainly shorter:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">M</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">Mat</span> <span class="n">E</span><span class="p">,</span> <span class="n">V</span><span class="p">;</span>
<span class="n">eigen</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">V</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">E</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>To use <tt class="docutils literal"><span class="pre">Mat_</span></tt> for multi-channel images/matrices, pass <tt class="docutils literal"><span class="pre">Vec</span></tt> as a <tt class="docutils literal"><span class="pre">Mat_</span></tt> parameter:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// allocate a 320x240 color image and fill it with green (in RGB space)</span>
<span class="n">Mat_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">img</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="n">Vec3b</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="c1">// now draw a diagonal white line</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">img</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">Vec3b</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">);</span>
<span class="c1">// and now scramble the 2nd (red) channel of each pixel</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">img</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="n">img</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">^=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(</span><span class="n">i</span> <span class="o">^</span> <span class="n">j</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="inputarray">
<h2>InputArray<a class="headerlink" href="#inputarray" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="InputArray">
<em class="property">class </em><tt class="descname">InputArray</tt><a class="headerlink" href="#InputArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This is the proxy class for passing read-only input arrays into OpenCV functions. It is defined as</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">const</span> <span class="n">_InputArray</span><span class="o">&amp;</span> <span class="n">InputArray</span><span class="p">;</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">_InputArray</span></tt> is a class that can be constructed from <tt class="docutils literal"><span class="pre">Mat</span></tt>, <tt class="docutils literal"><span class="pre">Mat_&lt;T&gt;</span></tt>, <tt class="docutils literal"><span class="pre">Matx&lt;T,</span> <span class="pre">m,</span> <span class="pre">n&gt;</span></tt>, <tt class="docutils literal"><span class="pre">std::vector&lt;T&gt;</span></tt>, <tt class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;T&gt;</span> <span class="pre">&gt;</span></tt> or <tt class="docutils literal"><span class="pre">std::vector&lt;Mat&gt;</span></tt>. It can also be constructed from a matrix expression.</p>
<p>Since this is mostly implementation-level class, and its interface may change in future versions, we do not describe it in details. There are a few key things, though, that should be kept in mind:</p>
<blockquote>
<div><ul class="simple">
<li>When you see in the reference manual or in OpenCV source code a function that takes <tt class="docutils literal"><span class="pre">InputArray</span></tt>, it means that you can actually pass <tt class="docutils literal"><span class="pre">Mat</span></tt>, <tt class="docutils literal"><span class="pre">Matx</span></tt>, <tt class="docutils literal"><span class="pre">vector&lt;T&gt;</span></tt> etc. (see above the complete list).</li>
<li>Optional input arguments: If some of the input arrays may be empty, pass <tt class="docutils literal"><span class="pre">cv::noArray()</span></tt> (or simply <tt class="docutils literal"><span class="pre">cv::Mat()</span></tt> as you probably did before).</li>
<li>The class is designed solely for passing parameters. That is, normally you <em>should not</em> declare class members, local and global variables of this type.</li>
<li>If you want to design your own function or a class method that can operate of arrays of multiple types, you can use <tt class="docutils literal"><span class="pre">InputArray</span></tt> (or <tt class="docutils literal"><span class="pre">OutputArray</span></tt>) for the respective parameters. Inside a function you should use <tt class="docutils literal"><span class="pre">_InputArray::getMat()</span></tt> method to construct a matrix header for the array (without copying data). <tt class="docutils literal"><span class="pre">_InputArray::kind()</span></tt> can be used to distinguish <tt class="docutils literal"><span class="pre">Mat</span></tt> from <tt class="docutils literal"><span class="pre">vector&lt;&gt;</span></tt> etc., but normally it is not needed.</li>
</ul>
</div></blockquote>
<p>Here is how you can use a function that takes <tt class="docutils literal"><span class="pre">InputArray</span></tt></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="c1">// points or a circle</span>
<span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point2f</span><span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">30</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">CV_PI</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">)),</span>
                          <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">30</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">CV_PI</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">5</span><span class="p">))));</span>
<span class="n">cv</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">vec</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Matx23f</span><span class="p">(</span><span class="mf">0.707</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.707</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.707</span><span class="p">,</span> <span class="mf">0.707</span><span class="p">,</span> <span class="mi">20</span><span class="p">));</span>
</pre></div>
</div>
<p>That is, we form an STL vector containing points, and apply in-place affine transformation to the vector using the 2x3 matrix created inline as <tt class="docutils literal"><span class="pre">Matx&lt;float,</span> <span class="pre">2,</span> <span class="pre">3&gt;</span></tt> instance.</p>
<p>Here is how such a function can be implemented (for simplicity, we implement a very specific case of it, according to the assertion statement inside)</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">myAffineTransform</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">_src</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">_dst</span><span class="p">,</span> <span class="n">InputArray</span> <span class="n">_m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// get Mat headers for input arrays. This is O(1) operation,</span>
    <span class="c1">// unless _src and/or _m are matrix expressions.</span>
    <span class="n">Mat</span> <span class="n">src</span> <span class="o">=</span> <span class="n">_src</span><span class="p">.</span><span class="n">getMat</span><span class="p">(),</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_m</span><span class="p">.</span><span class="n">getMat</span><span class="p">();</span>
    <span class="n">CV_Assert</span><span class="p">(</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32FC2</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_32F</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">Size</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">);</span>

    <span class="c1">// [re]create the output array so that it has the proper size and type.</span>
    <span class="c1">// In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.</span>
    <span class="n">_dst</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">src</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">src</span><span class="p">.</span><span class="n">type</span><span class="p">());</span>
    <span class="n">Mat</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">_dst</span><span class="p">.</span><span class="n">getMat</span><span class="p">();</span>

    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
        <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Point2f</span> <span class="n">pt</span> <span class="o">=</span> <span class="n">src</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">dst</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">Point2f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">Point2f</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pt</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span>
                                            <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is another related type, <tt class="docutils literal"><span class="pre">InputArrayOfArrays</span></tt>, which is currently defined as a synonym for <tt class="docutils literal"><span class="pre">InputArray</span></tt>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">InputArray</span> <span class="n">InputArrayOfArrays</span><span class="p">;</span>
</pre></div>
</div>
<p>It denotes function arguments that are either vectors of vectors or vectors of matrices. A separate synonym is needed to generate Python/Java etc. wrappers properly. At the function implementation level their use is similar, but <tt class="docutils literal"><span class="pre">_InputArray::getMat(idx)</span></tt> should be used to get header for the idx-th component of the outer vector and <tt class="docutils literal"><span class="pre">_InputArray::size().area()</span></tt> should be used to find the number of components (vectors/matrices) of the outer vector.</p>
</div>
<div class="section" id="outputarray">
<h2>OutputArray<a class="headerlink" href="#outputarray" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="OutputArray : public InputArray">
<em class="property">class </em><tt class="descname">OutputArray</tt> : <em class="property">public</em> <tt class="descname">InputArray</tt><a class="headerlink" href="#OutputArray : public InputArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This type is very similar to <tt class="docutils literal"><span class="pre">InputArray</span></tt> except that it is used for input/output and output function parameters. Just like with <tt class="docutils literal"><span class="pre">InputArray</span></tt>, OpenCV users should not care about <tt class="docutils literal"><span class="pre">OutputArray</span></tt>, they just pass <tt class="docutils literal"><span class="pre">Mat</span></tt>, <tt class="docutils literal"><span class="pre">vector&lt;T&gt;</span></tt> etc. to the functions. The same limitation as for <tt class="docutils literal"><span class="pre">InputArray</span></tt>: <strong>Do not explicitly create OutputArray instances</strong> applies here too.</p>
<p>If you want to make your function polymorphic (i.e. accept different arrays as output parameters), it is also not very difficult. Take the sample above as the reference. Note that <tt class="docutils literal"><span class="pre">_OutputArray::create()</span></tt> needs to be called before <tt class="docutils literal"><span class="pre">_OutputArray::getMat()</span></tt>. This way you guarantee that the output array is properly allocated.</p>
<p>Optional output parameters. If you do not need certain output array to be computed and returned to you, pass <tt class="docutils literal"><span class="pre">cv::noArray()</span></tt>, just like you would in the case of optional input array. At the implementation level, use <tt class="docutils literal"><span class="pre">_OutputArray::needed()</span></tt> to check if certain output array needs to be computed or not.</p>
<p>There are several synonyms for <tt class="docutils literal"><span class="pre">OutputArray</span></tt> that are used to assist automatic Python/Java/... wrapper generators:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">OutputArrayOfArrays</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">InputOutputArray</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">OutputArray</span> <span class="n">InputOutputArrayOfArrays</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="narymatiterator">
<h2>NAryMatIterator<a class="headerlink" href="#narymatiterator" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="NAryMatIterator">
<em class="property">class </em><tt class="descname">NAryMatIterator</tt><a class="headerlink" href="#NAryMatIterator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>n-ary multi-dimensional array iterator.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">NAryMatIterator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//! the default constructor</span>
    <span class="n">NAryMatIterator</span><span class="p">();</span>
    <span class="c1">//! the full constructor taking arbitrary number of n-dim matrices</span>
    <span class="n">NAryMatIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">**</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">Mat</span><span class="o">*</span> <span class="n">planes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narrays</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">//! the separate iterator initialization method</span>
    <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">**</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">Mat</span><span class="o">*</span> <span class="n">planes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">narrays</span><span class="o">=-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">//! proceeds to the next plane of every iterated matrix</span>
    <span class="n">NAryMatIterator</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">++</span><span class="p">();</span>
    <span class="c1">//! proceeds to the next plane of every iterated matrix (postfix increment operator)</span>
    <span class="n">NAryMatIterator</span> <span class="k">operator</span> <span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="kt">int</span> <span class="n">nplanes</span><span class="p">;</span> <span class="c1">// the total number of planes</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Use the class to implement unary, binary, and, generally, n-ary element-wise operations on multi-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some may be not. It is possible to use conventional
<tt class="docutils literal"><span class="pre">MatIterator</span></tt> ‘s for each array but incrementing all of the iterators after each small operations may be a big overhead. In this case consider using <tt class="docutils literal"><span class="pre">NAryMatIterator</span></tt> to iterate through several matrices simultaneously as long as they have the same geometry (dimensionality and all the dimension sizes are the same). On each iteration <tt class="docutils literal"><span class="pre">it.planes[0]</span></tt>, <tt class="docutils literal"><span class="pre">it.planes[1]</span></tt> , ... will be the slices of the corresponding matrices.</p>
<p>The example below illustrates how you can compute a normalized and threshold 3D color histogram:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">computeNormalizedColorHist</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">hist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">minProb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">histSize</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">};</span>

    <span class="c1">// make sure that the histogram has a proper size and type</span>
    <span class="n">hist</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">histSize</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>

    <span class="c1">// and clear it</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// the loop below assumes that the image</span>
    <span class="c1">// is a 8-bit 3-channel. check it.</span>
    <span class="n">CV_Assert</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">CV_8UC3</span><span class="p">);</span>
    <span class="n">MatConstIterator_</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(),</span>
                             <span class="n">it_end</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Vec3b</span><span class="o">&amp;</span> <span class="n">pix</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
        <span class="n">hist</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">,</span> <span class="n">pix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="mi">256</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">minProb</span> <span class="o">*=</span> <span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="o">*</span><span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span>
    <span class="n">Mat</span> <span class="n">plane</span><span class="p">;</span>
    <span class="n">NAryMatIterator</span> <span class="n">it</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plane</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// iterate through the matrix. on each iteration</span>
    <span class="c1">// it.planes[*] (of type Mat) will be set to the current plane.</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">it</span><span class="p">.</span><span class="n">nplanes</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">threshold</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">minProb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">THRESH_TOZERO</span><span class="p">);</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">s</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span><span class="p">;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">NAryMatIterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plane</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">it</span><span class="p">.</span><span class="n">nplanes</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">,</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">it</span><span class="p">.</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sparsemat">
<h2>SparseMat<a class="headerlink" href="#sparsemat" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SparseMat">
<em class="property">class </em><tt class="descname">SparseMat</tt><a class="headerlink" href="#SparseMat" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class <tt class="docutils literal"><span class="pre">SparseMat</span></tt> represents multi-dimensional sparse numerical arrays. Such a sparse array can store elements of any type that
<a class="reference internal" href="#Mat" title="class Mat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">Mat</span></tt></a> can store. <em>Sparse</em> means that only non-zero elements are stored (though, as a result of operations on a sparse matrix, some of its stored elements can actually become 0. It is up to you to detect such elements and delete them using <tt class="docutils literal"><span class="pre">SparseMat::erase</span></tt> ). The non-zero elements are stored in a hash table that grows when it is filled so that the search time is O(1) in average (regardless of whether element is there or not). Elements can be accessed using the following methods:</p>
<ul>
<li><p class="first">Query operations (<tt class="docutils literal"><span class="pre">SparseMat::ptr</span></tt> and the higher-level <tt class="docutils literal"><span class="pre">SparseMat::ref</span></tt>, <tt class="docutils literal"><span class="pre">SparseMat::value</span></tt> and <tt class="docutils literal"><span class="pre">SparseMat::find</span></tt>), for example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">dims</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">size</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">};</span>
<span class="n">SparseMat</span> <span class="nf">sparse_mat</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">CV_32F</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">idx</span><span class="p">[</span><span class="n">dims</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span>
    <span class="n">sparse_mat</span><span class="p">.</span><span class="n">ref</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+=</span> <span class="mf">1.f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Sparse matrix iterators. They are similar to <tt class="docutils literal"><span class="pre">MatIterator</span></tt> but different from <a class="reference internal" href="#NAryMatIterator" title="class NAryMatIterator"><tt class="xref ocv ocv-class docutils literal"><span class="pre">NAryMatIterator</span></tt></a>. That is, the iteration loop is familiar to STL users:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// prints elements of a sparse floating-point matrix</span>
<span class="c1">// and the sum of elements.</span>
<span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span>
    <span class="n">it_end</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dims</span> <span class="o">=</span> <span class="n">sparse_mat</span><span class="p">.</span><span class="n">dims</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// print element indices and the element value</span>
    <span class="k">const</span> <span class="n">SparseMat</span><span class="o">::</span><span class="n">Node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">node</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"("</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d%s"</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dims</span><span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="s">", "</span> <span class="o">:</span> <span class="s">")"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">": %g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">s</span> <span class="o">+=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Element sum is %g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</pre></div>
</div>
<p>If you run this loop, you will notice that elements are not enumerated in a logical order (lexicographical, and so on). They come in the same order as they are stored in the hash table (semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering. Note, however, that pointers to the nodes may become invalid when you add more elements to the matrix. This may happen due to possible buffer reallocation.</p>
</li>
<li><p class="first">Combination of the above 2 methods when you need to process 2 or more sparse matrices simultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2 floating-point sparse matrices:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="nf">cross_corr</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SparseMat</span> <span class="o">*</span><span class="n">_a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
    <span class="c1">// if b contains less elements than a,</span>
    <span class="c1">// it is faster to iterate through b</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_a</span><span class="o">-&gt;</span><span class="n">nzcount</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_b</span><span class="o">-&gt;</span><span class="n">nzcount</span><span class="p">())</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">);</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">_a</span><span class="o">-&gt;</span><span class="n">begin</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span>
                                   <span class="n">it_end</span> <span class="o">=</span> <span class="n">_a</span><span class="o">-&gt;</span><span class="n">end</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">ccorr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">it_end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// take the next element from the first matrix</span>
        <span class="kt">float</span> <span class="n">avalue</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">Node</span><span class="o">*</span> <span class="n">anode</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">node</span><span class="p">();</span>
        <span class="c1">// and try to find an element with the same index in the second matrix.</span>
        <span class="c1">// since the hash value depends only on the element index,</span>
        <span class="c1">// reuse the hash value stored in the node</span>
        <span class="kt">float</span> <span class="n">bvalue</span> <span class="o">=</span> <span class="n">_b</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">anode</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">,</span><span class="o">&amp;</span><span class="n">anode</span><span class="o">-&gt;</span><span class="n">hashval</span><span class="p">);</span>
        <span class="n">ccorr</span> <span class="o">+=</span> <span class="n">avalue</span><span class="o">*</span><span class="n">bvalue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ccorr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="sparsemat-sparsemat">
<h2>SparseMat::SparseMat<a class="headerlink" href="#sparsemat-sparsemat" title="Permalink to this headline">¶</a></h2>
<p>Various SparseMat constructors.</p>
<dl class="function">
<dt id="SparseMat::SparseMat()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">SparseMat</tt><big>(</big><big>)</big><a class="headerlink" href="#SparseMat::SparseMat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(int dims, const int* _sizes, int _type)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">SparseMat</tt><big>(</big>int <strong>dims</strong>, const int* <strong>_sizes</strong>, int <strong>_type</strong><big>)</big><a class="headerlink" href="#SparseMat::SparseMat(int dims, const int* _sizes, int _type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(const SparseMat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">SparseMat</tt><big>(</big>const SparseMat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#SparseMat::SparseMat(const SparseMat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat::SparseMat(const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">SparseMat</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#SparseMat::SparseMat(const Mat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Source matrix for copy constructor. If m is dense matrix (ocv:class:<cite>Mat</cite>) then it will be converted to sparse representation.</li>
<li><strong>dims</strong> – Array dimensionality.</li>
<li><strong>_sizes</strong> – Sparce matrix size on all dementions.</li>
<li><strong>_type</strong> – Sparse matrix data type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id5">
<h2>SparseMat::~SparseMat<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>SparseMat object destructor.</p>
<dl class="function">
<dt id="SparseMat::~SparseMat()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">~SparseMat</tt><big>(</big><big>)</big><a class="headerlink" href="#SparseMat::~SparseMat()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-operator">
<h2>SparseMat::operator=<a class="headerlink" href="#sparsemat-operator" title="Permalink to this headline">¶</a></h2>
<p>Provides sparse matrix assignment operators.</p>
<dl class="function">
<dt id="SparseMat&amp; SparseMat::operator = (const SparseMat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt>SparseMat&amp; <tt class="descclassname">SparseMat::</tt><tt class="descname">operator=</tt><big>(</big>const SparseMat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#SparseMat&amp; SparseMat::operator = (const SparseMat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="SparseMat&amp; SparseMat::operator = (const Mat&amp; m)">
<strong>C++:</strong><tt class="descname"> </tt>SparseMat&amp; <tt class="descclassname">SparseMat::</tt><tt class="descname">operator=</tt><big>(</big>const Mat&amp; <strong>m</strong><big>)</big><a class="headerlink" href="#SparseMat&amp; SparseMat::operator = (const Mat&amp; m)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Matrix for assignment.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The last variant is equivalent to the corresponding constructor with try1d=false.</p>
</div>
<div class="section" id="sparsemat-clone">
<h2>SparseMat::clone<a class="headerlink" href="#sparsemat-clone" title="Permalink to this headline">¶</a></h2>
<p>Creates a full copy of the matrix.</p>
<dl class="function">
<dt id="SparseMat SparseMat::clone() const">
<strong>C++:</strong><tt class="descname"> </tt>SparseMat <tt class="descclassname">SparseMat::</tt><tt class="descname">clone</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#SparseMat SparseMat::clone() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-copyto">
<h2>SparseMat::copyTo<a class="headerlink" href="#sparsemat-copyto" title="Permalink to this headline">¶</a></h2>
<p>Copy all the data to the destination matrix.The destination will be reallocated if needed.</p>
<dl class="function">
<dt id="void SparseMat::copyTo(SparseMat&amp; m) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">copyTo</tt><big>(</big>SparseMat&amp; <strong>m</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void SparseMat::copyTo(SparseMat&amp; m) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::copyTo(Mat&amp; m) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">copyTo</tt><big>(</big>Mat&amp; <strong>m</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void SparseMat::copyTo(Mat&amp; m) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Target for copiing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The last variant converts 1D or 2D sparse matrix to dense 2D matrix. If the sparse matrix is 1D, the result will be a single-column matrix.</p>
</div>
<div class="section" id="sparcemat-convertto">
<h2>SparceMat::convertTo<a class="headerlink" href="#sparcemat-convertto" title="Permalink to this headline">¶</a></h2>
<p>Convert sparse matrix with possible type change and scaling.</p>
<dl class="function">
<dt id="void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">convertTo</tt><big>(</big>SparseMat&amp; <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void SparseMat::convertTo(SparseMat&amp; m, int rtype, double alpha) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::convertTo(Mat&amp; m, int rtype, double alpha, double beta) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">convertTo</tt><big>(</big>Mat&amp; <strong>m</strong>, int <strong>rtype</strong>, double <strong>alpha</strong>=1, double <strong>beta</strong>=0 <big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void SparseMat::convertTo(Mat&amp; m, int rtype, double alpha, double beta) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>m</strong> – Destination matrix.</li>
<li><strong>rtype</strong> – Destination matrix type.</li>
<li><strong>alpha</strong> – Conversion multiplier.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The first version converts arbitrary sparse matrix to dense matrix and multiplies all the matrix elements by the specified scalar.
The second versiob converts sparse matrix to dense matrix with optional type conversion and scaling.
When rtype=-1, the destination element type will be the same as the sparse matrix element type.
Otherwise, rtype will specify the depth and the number of channels will remain the same as in the sparse matrix.</p>
</div>
<div class="section" id="sparsemat-create">
<h2>SparseMat:create<a class="headerlink" href="#sparsemat-create" title="Permalink to this headline">¶</a></h2>
<p>Reallocates sparse matrix. If it was already of the proper size and type, it is simply cleared with clear(), otherwise,
the old matrix is released (using release()) and the new one is allocated.</p>
<dl class="function">
<dt id="void SparseMat::create(int dims, const int* _sizes, int _type)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">create</tt><big>(</big>int <strong>dims</strong>, const int* <strong>_sizes</strong>, int <strong>_type</strong><big>)</big><a class="headerlink" href="#void SparseMat::create(int dims, const int* _sizes, int _type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dims</strong> – Array dimensionality.</li>
<li><strong>_sizes</strong> – Sparce matrix size on all dementions.</li>
<li><strong>_type</strong> – Sparse matrix data type.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-clear">
<h2>SparseMat::clear<a class="headerlink" href="#sparsemat-clear" title="Permalink to this headline">¶</a></h2>
<p>Sets all the matrix elements to 0, which means clearing the hash table.</p>
<dl class="function">
<dt id="void SparseMat::clear()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#void SparseMat::clear()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-addref">
<h2>SparseMat::addref<a class="headerlink" href="#sparsemat-addref" title="Permalink to this headline">¶</a></h2>
<p>Manually increases reference counter to the header.</p>
<dl class="function">
<dt id="void SparseMat::addref()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">addref</tt><big>(</big><big>)</big><a class="headerlink" href="#void SparseMat::addref()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-release">
<h2>SparseMat::release<a class="headerlink" href="#sparsemat-release" title="Permalink to this headline">¶</a></h2>
<p>Decreses the header reference counter when it reaches 0. The header and all the underlying data are deallocated.</p>
<dl class="function">
<dt id="void SparseMat::release()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#void SparseMat::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-cvsparsemat">
<h2>SparseMat::CvSparseMat *<a class="headerlink" href="#sparsemat-cvsparsemat" title="Permalink to this headline">¶</a></h2>
<p>Converts sparse matrix to the old-style representation. All the elements are copied.</p>
<dl class="function">
<dt id="SparseMat::operator CvSparseMat*() const">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">SparseMat::</tt><tt class="descname">operator</tt> CvSparseMat*<big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#SparseMat::operator CvSparseMat*() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-elemsize">
<h2>SparseMat::elemSize<a class="headerlink" href="#sparsemat-elemsize" title="Permalink to this headline">¶</a></h2>
<p>Size of each element in bytes (the matrix nodes will be bigger because of element indices and other SparseMat::Node elements).</p>
<dl class="function">
<dt id="size_t SparseMat::elemSize() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">elemSize</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::elemSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-elemsize1">
<h2>SparseMat::elemSize1<a class="headerlink" href="#sparsemat-elemsize1" title="Permalink to this headline">¶</a></h2>
<p>elemSize()/channels().</p>
<dl class="function">
<dt>
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">elemSize</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-type">
<h2>SparseMat::type<a class="headerlink" href="#sparsemat-type" title="Permalink to this headline">¶</a></h2>
<p>Returns the type of a matrix element.</p>
<dl class="function">
<dt id="int SparseMat::type() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">SparseMat::</tt><tt class="descname">type</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int SparseMat::type() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns a sparse matrix element type. This is an identifier compatible with the <tt class="docutils literal"><span class="pre">CvMat</span></tt> type system, like <tt class="docutils literal"><span class="pre">CV_16SC3</span></tt> or 16-bit signed 3-channel array, and so on.</p>
</div>
<div class="section" id="sparsemat-depth">
<h2>SparseMat::depth<a class="headerlink" href="#sparsemat-depth" title="Permalink to this headline">¶</a></h2>
<p>Returns the depth of a sparse matrix element.</p>
<dl class="function">
<dt id="int SparseMat::depth() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">SparseMat::</tt><tt class="descname">depth</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int SparseMat::depth() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the identifier of the matrix element depth (the type of each individual channel). For example, for a 16-bit signed 3-channel array, the method returns <tt class="docutils literal"><span class="pre">CV_16S</span></tt></p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CV_8U</span></tt>     - 8-bit unsigned integers ( <tt class="docutils literal"><span class="pre">0..255</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_8S</span></tt>     - 8-bit signed integers ( <tt class="docutils literal"><span class="pre">-128..127</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_16U</span></tt>     - 16-bit unsigned integers ( <tt class="docutils literal"><span class="pre">0..65535</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_16S</span></tt>     - 16-bit signed integers ( <tt class="docutils literal"><span class="pre">-32768..32767</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_32S</span></tt>     - 32-bit signed integers ( <tt class="docutils literal"><span class="pre">-2147483648..2147483647</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_32F</span></tt>     - 32-bit floating-point numbers ( <tt class="docutils literal"><span class="pre">-FLT_MAX..FLT_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></tt>     )</li>
<li><tt class="docutils literal"><span class="pre">CV_64F</span></tt>     - 64-bit floating-point numbers ( <tt class="docutils literal"><span class="pre">-DBL_MAX..DBL_MAX,</span> <span class="pre">INF,</span> <span class="pre">NAN</span></tt>     )</li>
</ul>
</div>
<div class="section" id="sparsemat-channels">
<h2>SparseMat::channels<a class="headerlink" href="#sparsemat-channels" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of matrix channels.</p>
<dl class="function">
<dt id="int SparseMat::channels() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">SparseMat::</tt><tt class="descname">channels</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int SparseMat::channels() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The method returns the number of matrix channels.</p>
</div>
<div class="section" id="sparsemat-size">
<h2>SparseMat::size<a class="headerlink" href="#sparsemat-size" title="Permalink to this headline">¶</a></h2>
<p>Returns the array of sizes or matrix size by i dimension and 0 if the matrix is not allocated.</p>
<dl class="function">
<dt id="const int* SparseMat::size() const">
<strong>C++:</strong><tt class="descname"> </tt>const int* <tt class="descclassname">SparseMat::</tt><tt class="descname">size</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#const int* SparseMat::size() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="int SparseMat::size(int i) const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">SparseMat::</tt><tt class="descname">size</tt><big>(</big>int <strong>i</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int SparseMat::size(int i) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> – Dimention index.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-dims">
<h2>SparseMat::dims<a class="headerlink" href="#sparsemat-dims" title="Permalink to this headline">¶</a></h2>
<p>Returns the matrix dimensionality.</p>
<dl class="function">
<dt id="int SparseMat::dims() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">SparseMat::</tt><tt class="descname">dims</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int SparseMat::dims() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-nzcount">
<h2>SparseMat::nzcount<a class="headerlink" href="#sparsemat-nzcount" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of non-zero elements.</p>
<dl class="function">
<dt id="size_t SparseMat::nzcount() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">nzcount</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::nzcount() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="sparsemat-hash">
<h2>SparseMat::hash<a class="headerlink" href="#sparsemat-hash" title="Permalink to this headline">¶</a></h2>
<p>Compute element hash value from the element indices.</p>
<dl class="function">
<dt id="size_t SparseMat::hash(int i0) const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">hash</tt><big>(</big>int <strong>i0</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::hash(int i0) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(int i0, int i1) const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">hash</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::hash(int i0, int i1) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(int i0, int i1, int i2) const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">hash</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::hash(int i0, int i1, int i2) const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="size_t SparseMat::hash(const int* idx) const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">SparseMat::</tt><tt class="descname">hash</tt><big>(</big>const int* <strong>idx</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t SparseMat::hash(const int* idx) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> – The first dimension index.</li>
<li><strong>i1</strong> – The second dimension index.</li>
<li><strong>i2</strong> – The third dimension index.</li>
<li><strong>idx</strong> – Array of element indices for multidimensional matices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="sparsemat-ptr">
<h2>SparseMat::ptr<a class="headerlink" href="#sparsemat-ptr" title="Permalink to this headline">¶</a></h2>
<p>Low-level element-access functions, special variants for 1D, 2D, 3D cases, and the generic one for n-D case.</p>
<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>uchar* <tt class="descclassname">SparseMat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>uchar* <tt class="descclassname">SparseMat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>uchar* <tt class="descclassname">SparseMat::</tt><tt class="descname">ptr</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>uchar* <tt class="descclassname">SparseMat::</tt><tt class="descname">ptr</tt><big>(</big>const int* <strong>idx</strong>, bool <strong>createMissing</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> – The first dimension index.</li>
<li><strong>i1</strong> – The second dimension index.</li>
<li><strong>i2</strong> – The third dimension index.</li>
<li><strong>idx</strong> – Array of element indices for multidimensional matices.</li>
<li><strong>createMissing</strong> – Create new element with 0 value if it does not exist in SparseMat.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Return pointer to the matrix element. If the element is there (it is non-zero), the pointer to it is returned.
If it is not there and <tt class="docutils literal"><span class="pre">createMissing=false</span></tt>, NULL pointer is returned. If it is not there and <tt class="docutils literal"><span class="pre">createMissing=true</span></tt>,
the new elementis created and initialized with 0. Pointer to it is returned. If the optional hashval pointer is not <tt class="docutils literal"><span class="pre">NULL</span></tt>,
the element hash value is not computed but <tt class="docutils literal"><span class="pre">hashval</span></tt> is taken instead.</p>
</div>
<div class="section" id="sparsemat-erase">
<h2>SparseMat::erase<a class="headerlink" href="#sparsemat-erase" title="Permalink to this headline">¶</a></h2>
<p>Erase the specified matrix element. When there is no such an element, the methods do nothing.</p>
<dl class="function">
<dt id="void SparseMat::erase(int i0, int i1, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">erase</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#void SparseMat::erase(int i0, int i1, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">erase</tt><big>(</big>int <strong>i0</strong>, int <strong>i1</strong>, int <strong>i2</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void SparseMat::erase(const int* idx, size_t* hashval)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">SparseMat::</tt><tt class="descname">erase</tt><big>(</big>const int* <strong>idx</strong>, size_t* <strong>hashval</strong>=0<big>)</big><a class="headerlink" href="#void SparseMat::erase(const int* idx, size_t* hashval)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i0</strong> – The first dimension index.</li>
<li><strong>i1</strong> – The second dimension index.</li>
<li><strong>i2</strong> – The third dimension index.</li>
<li><strong>idx</strong> – Array of element indices for multidimensional matices.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="id6">
<h2>SparseMat_<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="SparseMat_">
<em class="property">class </em><tt class="descname">SparseMat_</tt><a class="headerlink" href="#SparseMat_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Template sparse n-dimensional array class derived from
<a class="reference internal" href="#SparseMat" title="class SparseMat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">SparseMat</span></tt></a></p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">SparseMat_</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SparseMat</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">typedef</span> <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>

    <span class="c1">// constructors;</span>
    <span class="c1">// the created matrix will have data type = DataType&lt;_Tp&gt;::type</span>
    <span class="n">SparseMat_</span><span class="p">();</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="kt">int</span> <span class="n">dims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">_sizes</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="p">(</span><span class="k">const</span> <span class="n">CvSparseMat</span><span class="o">*</span> <span class="n">m</span><span class="p">);</span>
    <span class="c1">// assignment operators; data type conversion is done when necessary</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">SparseMat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">SparseMat_</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">);</span>

    <span class="c1">// equivalent to the correspoding parent class methods</span>
    <span class="n">SparseMat_</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">dims</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">_sizes</span><span class="p">);</span>
    <span class="k">operator</span> <span class="n">CvSparseMat</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// overriden methods that do extra checks for the data type</span>
    <span class="kt">int</span> <span class="n">type</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">channels</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// more convenient element access operations.</span>
    <span class="c1">// ref() is retained (but &lt;_Tp&gt; specification is not needed anymore);</span>
    <span class="c1">// operator () is equivalent to SparseMat::value&lt;_Tp&gt;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">i0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">_Tp</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">*</span> <span class="n">hashval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// iterators</span>
    <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">();</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SparseMatIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">();</span>
    <span class="n">SparseMatConstIterator_</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">SparseMat_</span></tt> is a thin wrapper on top of <a class="reference internal" href="#SparseMat" title="class SparseMat"><tt class="xref ocv ocv-class docutils literal"><span class="pre">SparseMat</span></tt></a> created in the same way as <tt class="docutils literal"><span class="pre">Mat_</span></tt> .
It simplifies notation of some operations.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">sz</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
<span class="n">SparseMat_</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">M</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">M</span><span class="p">.</span><span class="n">ref</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm">
<h2>Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="Algorithm">
<em class="property">class </em><tt class="descname">Algorithm</tt><a class="headerlink" href="#Algorithm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS_W</span> <span class="n">Algorithm</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Algorithm</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Algorithm</span><span class="p">();</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">ParamType</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">member_type</span> <span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">ParamType</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">member_type</span> <span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">CV_WRAP</span> <span class="kt">int</span> <span class="n">getInt</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="kt">double</span> <span class="n">getDouble</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="kt">bool</span> <span class="n">getBool</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="n">string</span> <span class="n">getString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="n">Mat</span> <span class="n">getMat</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">getMatVector</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="n">getAlgorithm</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>

    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setInt</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setDouble</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setBool</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setMat</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setMatVector</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="nf">setAlgorithm</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setAlgorithm</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">setInt</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setDouble</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setBool</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setMat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setMatVector</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">setAlgorithm</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">setAlgorithm</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;&amp;</span> <span class="n">value</span><span class="p">);</span>

    <span class="n">CV_WRAP</span> <span class="n">string</span> <span class="n">paramHelp</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">paramType</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="kt">int</span> <span class="n">paramType</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">CV_WRAP</span> <span class="kt">void</span> <span class="n">getParams</span><span class="p">(</span><span class="n">CV_OUT</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">names</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>


    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">FileStorage</span><span class="o">&amp;</span> <span class="n">fs</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="k">const</span> <span class="n">FileNode</span><span class="o">&amp;</span> <span class="n">fn</span><span class="p">);</span>

    <span class="k">typedef</span> <span class="n">Algorithm</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">Constructor</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">Algorithm</span><span class="o">::*</span><span class="n">Getter</span><span class="p">)()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="n">Algorithm</span><span class="o">::*</span><span class="n">Setter</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>

    <span class="n">CV_WRAP</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">getList</span><span class="p">(</span><span class="n">CV_OUT</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">algorithms</span><span class="p">);</span>
    <span class="n">CV_WRAP</span> <span class="k">static</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Algorithm</span><span class="o">&gt;</span> <span class="n">_create</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="n">AlgorithmInfo</span><span class="o">*</span> <span class="n">info</span><span class="p">()</span> <span class="k">const</span> <span class="cm">/* TODO: make it = 0;*/</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This is a base class for all more or less complex algorithms in OpenCV, especially for classes of algorithms, for which there can be multiple implementations. The examples are stereo correspondence (for which there are algorithms like block matching, semi-global block matching, graph-cut etc.), background subtraction (which can be done using mixture-of-gaussians models, codebook-based algorithm etc.), optical flow (block matching, Lucas-Kanade, Horn-Schunck etc.).</p>
<p>The class provides the following features for all derived classes:</p>
<blockquote>
<div><ul class="simple">
<li>so called “virtual constructor”. That is, each Algorithm derivative is registered at program start and you can get the list of registered algorithms and create instance of a particular algorithm by its name (see <tt class="docutils literal"><span class="pre">Algorithm::create</span></tt>). If you plan to add your own algorithms, it is good practice to add a unique prefix to your algorithms to distinguish them from other algorithms.</li>
<li>setting/retrieving algorithm parameters by name. If you used video capturing functionality from OpenCV videoio module, you are probably familar with <tt class="docutils literal"><span class="pre">cvSetCaptureProperty()</span></tt>, <tt class="docutils literal"><span class="pre">cvGetCaptureProperty()</span></tt>, <tt class="docutils literal"><span class="pre">VideoCapture::set()</span></tt> and <tt class="docutils literal"><span class="pre">VideoCapture::get()</span></tt>. <tt class="docutils literal"><span class="pre">Algorithm</span></tt> provides similar method where instead of integer id’s you specify the parameter names as text strings. See <tt class="docutils literal"><span class="pre">Algorithm::set</span></tt> and <tt class="docutils literal"><span class="pre">Algorithm::get</span></tt> for details.</li>
<li>reading and writing parameters from/to XML or YAML files. Every Algorithm derivative can store all its parameters and then read them back. There is no need to re-implement it each time.</li>
</ul>
</div></blockquote>
<p>Here is example of SIFT use in your application via Algorithm interface:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include "opencv2/opencv.hpp"</span>
<span class="cp">#include "opencv2/xfeatures2d.hpp"</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="o">::</span><span class="n">xfeatures2d</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Feature2D</span><span class="o">&gt;</span> <span class="n">sift</span> <span class="o">=</span> <span class="n">SIFT</span><span class="o">::</span><span class="n">create</span><span class="p">();</span>

<span class="n">FileStorage</span> <span class="nf">fs</span><span class="p">(</span><span class="s">"sift_params.xml"</span><span class="p">,</span> <span class="n">FileStorage</span><span class="o">::</span><span class="n">READ</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">fs</span><span class="p">.</span><span class="n">isOpened</span><span class="p">()</span> <span class="p">)</span> <span class="c1">// if we have file with parameters, read them</span>
<span class="p">{</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">fs</span><span class="p">[</span><span class="s">"sift_params"</span><span class="p">]);</span>
    <span class="n">fs</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span> <span class="c1">// else modify the parameters and store them; user can later edit the file to use different parameters</span>
<span class="p">{</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">setContrastThreshold</span><span class="p">(</span><span class="mf">0.01f</span><span class="p">);</span> <span class="c1">// lower the contrast threshold, compared to the default value</span>

    <span class="p">{</span>
    <span class="n">WriteStructContext</span> <span class="n">ws</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span> <span class="s">"sift_params"</span><span class="p">,</span> <span class="n">CV_NODE_MAP</span><span class="p">);</span>
    <span class="n">sift</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">Mat</span> <span class="n">image</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s">"myimage.png"</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">descriptors</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyPoint</span><span class="o">&gt;</span> <span class="n">keypoints</span><span class="p">;</span>
<span class="n">sift</span><span class="o">-&gt;</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">noArray</span><span class="p">(),</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm-name">
<h2>Algorithm::name<a class="headerlink" href="#algorithm-name" title="Permalink to this headline">¶</a></h2>
<p>Returns the algorithm name</p>
<dl class="function">
<dt id="String Algorithm::name() const">
<strong>C++:</strong><tt class="descname"> </tt>String <tt class="descclassname">Algorithm::</tt><tt class="descname">name</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#String Algorithm::name() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="algorithm-get">
<h2>Algorithm::get<a class="headerlink" href="#algorithm-get" title="Permalink to this headline">¶</a></h2>
<p>Returns the algorithm parameter</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type Algorithm::get(const String&amp; name) const">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type <tt class="descclassname">Algorithm::</tt><tt class="descname">get</tt><big>(</big>const String&amp; <strong>name</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#template&lt;typename _Tp&gt; typename ParamType&lt;_Tp&gt;::member_type Algorithm::get(const String&amp; name) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – The parameter name.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method returns value of the particular parameter. Since the compiler can not deduce the type of the returned parameter, you should specify it explicitly in angle brackets. Here are the allowed forms of get:</p>
<blockquote>
<div><ul class="simple">
<li>myalgo.get&lt;int&gt;(“param_name”)</li>
<li>myalgo.get&lt;double&gt;(“param_name”)</li>
<li>myalgo.get&lt;bool&gt;(“param_name”)</li>
<li>myalgo.get&lt;String&gt;(“param_name”)</li>
<li>myalgo.get&lt;Mat&gt;(“param_name”)</li>
<li>myalgo.get&lt;vector&lt;Mat&gt; &gt;(“param_name”)</li>
<li>myalgo.get&lt;Algorithm&gt;(“param_name”) (it returns Ptr&lt;Algorithm&gt;).</li>
</ul>
</div></blockquote>
<p>In some cases the actual type of the parameter can be cast to the specified type, e.g. integer parameter can be cast to double, <tt class="docutils literal"><span class="pre">bool</span></tt> can be cast to <tt class="docutils literal"><span class="pre">int</span></tt>. But “dangerous” transformations (string&lt;-&gt;number, double-&gt;int, 1x1 Mat&lt;-&gt;number, ...) are not performed and the method will throw an exception. In the case of <tt class="docutils literal"><span class="pre">Mat</span></tt> or <tt class="docutils literal"><span class="pre">vector&lt;Mat&gt;</span></tt> parameters the method does not clone the matrix data, so do not modify the matrices. Use <tt class="docutils literal"><span class="pre">Algorithm::set</span></tt> instead - slower, but more safe.</p>
</div>
<div class="section" id="algorithm-set">
<h2>Algorithm::set<a class="headerlink" href="#algorithm-set" title="Permalink to this headline">¶</a></h2>
<p>Sets the algorithm parameter</p>
<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, int value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, int <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, int value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, double value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, double <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, double value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, bool value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, bool <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, bool value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, const String&amp; value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, const String&amp; <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, const String&amp; value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, const Mat&amp; value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, const Mat&amp; <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, const Mat&amp; value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, const vector&lt;Mat&gt;&amp; value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, const vector&lt;Mat&gt;&amp; <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, const vector&lt;Mat&gt;&amp; value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="void Algorithm::set(const String&amp; name, const Ptr&lt;Algorithm&gt;&amp; value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">set</tt><big>(</big>const String&amp; <strong>name</strong>, const Ptr&lt;Algorithm&gt;&amp; <strong>value</strong><big>)</big><a class="headerlink" href="#void Algorithm::set(const String&amp; name, const Ptr&lt;Algorithm&gt;&amp; value)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – The parameter name.</li>
<li><strong>value</strong> – The parameter value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method sets value of the particular parameter. Some of the algorithm parameters may be declared as read-only. If you try to set such a parameter, you will get exception with the corresponding error message.</p>
</div>
<div class="section" id="algorithm-write">
<h2>Algorithm::write<a class="headerlink" href="#algorithm-write" title="Permalink to this headline">¶</a></h2>
<p>Stores algorithm parameters in a file storage</p>
<dl class="function">
<dt id="void Algorithm::write(FileStorage&amp; fs) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">write</tt><big>(</big>FileStorage&amp; <strong>fs</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void Algorithm::write(FileStorage&amp; fs) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fs</strong> – File storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method stores all the algorithm parameters (in alphabetic order) to the file storage. The method is virtual. If you define your own Algorithm derivative, your can override the method and store some extra information. However, it’s rarely needed. Here are some examples:</p>
<blockquote>
<div><ul class="simple">
<li>SIFT feature detector (from xfeatures2d module). The class only stores algorithm parameters and no keypoints or their descriptors. Therefore, it’s enough to store the algorithm parameters, which is what <tt class="docutils literal"><span class="pre">Algorithm::write()</span></tt> does. Therefore, there is no dedicated <tt class="docutils literal"><span class="pre">SIFT::write()</span></tt>.</li>
<li>Background subtractor (from video module). It has the algorithm parameters and also it has the current background model. However, the background model is not stored. First, it’s rather big. Then, if you have stored the background model, it would likely become irrelevant on the next run (because of shifted camera, changed background, different lighting etc.). Therefore, <tt class="docutils literal"><span class="pre">BackgroundSubtractorMOG</span></tt> and <tt class="docutils literal"><span class="pre">BackgroundSubtractorMOG2</span></tt> also rely on the standard <tt class="docutils literal"><span class="pre">Algorithm::write()</span></tt> to store just the algorithm parameters.</li>
<li>Expectation Maximization (from ml module). The algorithm finds mixture of gaussians that approximates user data best of all. In this case the model may be re-used on the next run to test new data against the trained statistical model. So EM needs to store the model. However, since the model is described by a few parameters that are available as read-only algorithm parameters (i.e. they are available via <tt class="docutils literal"><span class="pre">EM::get()</span></tt>), EM also relies on <tt class="docutils literal"><span class="pre">Algorithm::write()</span></tt> to store both EM parameters and the model (represented by read-only algorithm parameters).</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="algorithm-read">
<h2>Algorithm::read<a class="headerlink" href="#algorithm-read" title="Permalink to this headline">¶</a></h2>
<p>Reads algorithm parameters from a file storage</p>
<dl class="function">
<dt id="void Algorithm::read(const FileNode&amp; fn)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">read</tt><big>(</big>const FileNode&amp; <strong>fn</strong><big>)</big><a class="headerlink" href="#void Algorithm::read(const FileNode&amp; fn)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fn</strong> – File node of the file storage.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The method reads all the algorithm parameters from the specified node of a file storage. Similarly to <tt class="docutils literal"><span class="pre">Algorithm::write()</span></tt>, if you implement an algorithm that needs to read some extra data and/or re-compute some internal data, you may override the method.</p>
</div>
<div class="section" id="algorithm-getlist">
<h2>Algorithm::getList<a class="headerlink" href="#algorithm-getlist" title="Permalink to this headline">¶</a></h2>
<p>Returns the list of registered algorithms</p>
<dl class="function">
<dt id="void Algorithm::getList(vector&lt;String&gt;&amp; algorithms)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">Algorithm::</tt><tt class="descname">getList</tt><big>(</big>vector&lt;String&gt;&amp; <strong>algorithms</strong><big>)</big><a class="headerlink" href="#void Algorithm::getList(vector&lt;String&gt;&amp; algorithms)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>algorithms</strong> – The output vector of algorithm names.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This static method returns the list of registered algorithms in alphabetical order. Here is how to use it</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">algorithms</span><span class="p">;</span>
<span class="n">Algorithm</span><span class="o">::</span><span class="n">getList</span><span class="p">(</span><span class="n">algorithms</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Algorithms: "</span> <span class="o">&lt;&lt;</span> <span class="n">algorithms</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">algorithms</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">algorithms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="algorithm-create">
<h2>Algorithm::create<a class="headerlink" href="#algorithm-create" title="Permalink to this headline">¶</a></h2>
<p>Creates algorithm instance by name</p>
<dl class="function">
<dt id="template&lt;typename _Tp&gt; Ptr&lt;_Tp&gt; Algorithm::create(const String&amp; name)">
<strong>C++:</strong><tt class="descname"> </tt>template&lt;typename _Tp&gt; Ptr&lt;_Tp&gt; <tt class="descclassname">Algorithm::</tt><tt class="descname">create</tt><big>(</big>const String&amp; <strong>name</strong><big>)</big><a class="headerlink" href="#template&lt;typename _Tp&gt; Ptr&lt;_Tp&gt; Algorithm::create(const String&amp; name)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> – The algorithm name, one of the names returned by <tt class="docutils literal"><span class="pre">Algorithm::getList()</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>This static method creates a new instance of the specified algorithm. If there is no such algorithm, the method will silently return a null pointer. Also, you should specify the particular <tt class="docutils literal"><span class="pre">Algorithm</span></tt> subclass as <tt class="docutils literal"><span class="pre">_Tp</span></tt> (or simply <tt class="docutils literal"><span class="pre">Algorithm</span></tt> if you do not know it at that point).</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">BackgroundSubtractor</span><span class="o">&gt;</span> <span class="n">bgfg</span> <span class="o">=</span> <span class="n">Algorithm</span><span class="o">::</span><span class="n">create</span><span class="o">&lt;</span><span class="n">BackgroundSubtractor</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"BackgroundSubtractor.MOG2"</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is important note about seemingly mysterious behavior of <tt class="docutils literal"><span class="pre">Algorithm::create()</span></tt> when it returns NULL while it should not. The reason is simple - <tt class="docutils literal"><span class="pre">Algorithm::create()</span></tt> resides in OpenCV`s core module and the algorithms are implemented in other modules. If you create algorithms dynamically, C++ linker may decide to throw away the modules where the actual algorithms are implemented, since you do not call any functions from the modules. To avoid this problem, you need to call <tt class="docutils literal"><span class="pre">initModule_&lt;modulename&gt;();</span></tt> somewhere in the beginning of the program before <tt class="docutils literal"><span class="pre">Algorithm::create()</span></tt>. For example, call <tt class="docutils literal"><span class="pre">initModule_xfeatures2d()</span></tt> in order to use SURF/SIFT, call <tt class="docutils literal"><span class="pre">initModule_ml()</span></tt> to use expectation maximization etc.</p>
</div>
</div>
<div class="section" id="creating-own-algorithms">
<h2>Creating Own Algorithms<a class="headerlink" href="#creating-own-algorithms" title="Permalink to this headline">¶</a></h2>
<p>The above methods are usually enough for users. If you want to make your own algorithm, derived from <tt class="docutils literal"><span class="pre">Algorithm</span></tt>, you should basically follow a few conventions and add a little semi-standard piece of code to your class:</p>
<blockquote>
<div><ul class="simple">
<li>Make a class and specify <tt class="docutils literal"><span class="pre">Algorithm</span></tt> as its base class.</li>
<li>The algorithm parameters should be the class members. See <tt class="docutils literal"><span class="pre">Algorithm::get()</span></tt> for the list of possible types of the parameters.</li>
<li>Add public virtual method <tt class="docutils literal"><span class="pre">AlgorithmInfo*</span> <span class="pre">info()</span> <span class="pre">const;</span></tt> to your class.</li>
<li>Add constructor function, <tt class="docutils literal"><span class="pre">AlgorithmInfo</span></tt> instance and implement the <tt class="docutils literal"><span class="pre">info()</span></tt> method. The simplest way is to take <a class="reference external" href="https://github.com/Itseez/opencv/tree/master/modules/ml/src/ml_init.cpp">https://github.com/Itseez/opencv/tree/master/modules/ml/src/ml_init.cpp</a> as the reference and modify it according to the list of your parameters.</li>
<li>Add some public function (e.g. <tt class="docutils literal"><span class="pre">initModule_&lt;mymodule&gt;()</span></tt>) that calls info() of your algorithm and put it into the same source file as <tt class="docutils literal"><span class="pre">info()</span></tt> implementation. This is to force C++ linker to include this object file into the target application. See <tt class="docutils literal"><span class="pre">Algorithm::create()</span></tt> for details.</li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&amp;A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="command_line_parser.html" title="Command Line Parser">next</a> |</li>
        <li class="right">
          <a href="core.html" title="core. The Core Functionality">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="core.html">core. The Core Functionality</a> »</li> 
      </ul>
    </div>
    <div class="footer">
        © Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
      <a href="../../../_sources/modules/core/doc/basic_structures.txt" rel="nofollow">Show this page source.</a>
    </div>
  

<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/core/doc/basic_structures.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:03 GMT -->
</body></html>