<html><head><script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/video/doc/motion_analysis_and_object_tracking.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:27 GMT -->

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    
    <title>Motion Analysis and Object Tracking</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css">
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css">
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="../../../index.html">
    <link rel="up" title="video. Video Analysis" href="video.html">
    <link rel="next" title="calib3d. Camera Calibration and 3D Reconstruction" href="../../calib3d/doc/calib3d.html">
    <link rel="prev" title="video. Video Analysis" href="video.html">
    <link href="../../../../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700" rel="stylesheet" type="text/css">
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <body><div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="../../calib3d/doc/calib3d.html" title="calib3d. Camera Calibration and 3D Reconstruction" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="video.html" title="video. Video Analysis" accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="video.html" accesskey="U">video. Video Analysis</a> »</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo2.png" alt="Logo">
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q">
      <input type="submit" value="Go">
      <input type="hidden" name="check_keywords" value="yes">
      <input type="hidden" name="area" value="default">
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Motion Analysis and Object Tracking</a><ul>
<li><a class="reference internal" href="#calcopticalflowpyrlk">calcOpticalFlowPyrLK</a></li>
<li><a class="reference internal" href="#buildopticalflowpyramid">buildOpticalFlowPyramid</a></li>
<li><a class="reference internal" href="#calcopticalflowfarneback">calcOpticalFlowFarneback</a></li>
<li><a class="reference internal" href="#estimaterigidtransform">estimateRigidTransform</a></li>
<li><a class="reference internal" href="#findtransformecc">findTransformECC</a></li>
<li><a class="reference internal" href="#camshift">CamShift</a></li>
<li><a class="reference internal" href="#meanshift">meanShift</a></li>
<li><a class="reference internal" href="#kalmanfilter">KalmanFilter</a></li>
<li><a class="reference internal" href="#kalmanfilter-kalmanfilter">KalmanFilter::KalmanFilter</a></li>
<li><a class="reference internal" href="#kalmanfilter-init">KalmanFilter::init</a></li>
<li><a class="reference internal" href="#kalmanfilter-predict">KalmanFilter::predict</a></li>
<li><a class="reference internal" href="#kalmanfilter-correct">KalmanFilter::correct</a></li>
<li><a class="reference internal" href="#backgroundsubtractor">BackgroundSubtractor</a></li>
<li><a class="reference internal" href="#backgroundsubtractor-apply">BackgroundSubtractor::apply</a></li>
<li><a class="reference internal" href="#backgroundsubtractor-getbackgroundimage">BackgroundSubtractor::getBackgroundImage</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog">BackgroundSubtractorMOG</a></li>
<li><a class="reference internal" href="#createbackgroundsubtractormog">createBackgroundSubtractorMOG</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2">BackgroundSubtractorMOG2</a></li>
<li><a class="reference internal" href="#createbackgroundsubtractormog2">createBackgroundSubtractorMOG2</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-gethistory">BackgroundSubtractorMOG2::getHistory</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-sethistory">BackgroundSubtractorMOG2::setHistory</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getnmixtures">BackgroundSubtractorMOG2::getNMixtures</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setnmixtures">BackgroundSubtractorMOG2::setNMixtures</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getbackgroundratio">BackgroundSubtractorMOG2::getBackgroundRatio</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setbackgroundratio">BackgroundSubtractorMOG2::setBackgroundRatio</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getvarthreshold">BackgroundSubtractorMOG2::getVarThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setvarthreshold">BackgroundSubtractorMOG2::setVarThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getvarthresholdgen">BackgroundSubtractorMOG2::getVarThresholdGen</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setvarthresholdgen">BackgroundSubtractorMOG2::setVarThresholdGen</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getvarinit">BackgroundSubtractorMOG2::getVarInit</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setvarinit">BackgroundSubtractorMOG2::setVarInit</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getcomplexityreductionthreshold">BackgroundSubtractorMOG2::getComplexityReductionThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setcomplexityreductionthreshold">BackgroundSubtractorMOG2::setComplexityReductionThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getdetectshadows">BackgroundSubtractorMOG2::getDetectShadows</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setdetectshadows">BackgroundSubtractorMOG2::setDetectShadows</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getshadowvalue">BackgroundSubtractorMOG2::getShadowValue</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setshadowvalue">BackgroundSubtractorMOG2::setShadowValue</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-getshadowthreshold">BackgroundSubtractorMOG2::getShadowThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractormog2-setshadowthreshold">BackgroundSubtractorMOG2::setShadowThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn">BackgroundSubtractorKNN</a></li>
<li><a class="reference internal" href="#createbackgroundsubtractorknn">createBackgroundSubtractorKNN</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-gethistory">BackgroundSubtractorKNN::getHistory</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-sethistory">BackgroundSubtractorKNN::setHistory</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getnsamples">BackgroundSubtractorKNN::getNSamples</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setnsamples">BackgroundSubtractorKNN::setNSamples</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getdist2threshold">BackgroundSubtractorKNN::getDist2Threshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setdist2threshold">BackgroundSubtractorKNN::setDist2Threshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getknnsamples">BackgroundSubtractorKNN::getkNNSamples</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setknnsamples">BackgroundSubtractorKNN::setkNNSamples</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getdetectshadows">BackgroundSubtractorKNN::getDetectShadows</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setdetectshadows">BackgroundSubtractorKNN::setDetectShadows</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getshadowvalue">BackgroundSubtractorKNN::getShadowValue</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setshadowvalue">BackgroundSubtractorKNN::setShadowValue</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-getshadowthreshold">BackgroundSubtractorKNN::getShadowThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorknn-setshadowthreshold">BackgroundSubtractorKNN::setShadowThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg">BackgroundSubtractorGMG</a></li>
<li><a class="reference internal" href="#createbackgroundsubtractorgmg">createBackgroundSubtractorGMG</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getnumframes">BackgroundSubtractorGMG::getNumFrames</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setnumframes">BackgroundSubtractorGMG::setNumFrames</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getdefaultlearningrate">BackgroundSubtractorGMG::getDefaultLearningRate</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setdefaultlearningrate">BackgroundSubtractorGMG::setDefaultLearningRate</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getdecisionthreshold">BackgroundSubtractorGMG::getDecisionThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setdecisionthreshold">BackgroundSubtractorGMG::setDecisionThreshold</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getmaxfeatures">BackgroundSubtractorGMG::getMaxFeatures</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setmaxfeatures">BackgroundSubtractorGMG::setMaxFeatures</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getquantizationlevels">BackgroundSubtractorGMG::getQuantizationLevels</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setquantizationlevels">BackgroundSubtractorGMG::setQuantizationLevels</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getsmoothingradius">BackgroundSubtractorGMG::getSmoothingRadius</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setsmoothingradius">BackgroundSubtractorGMG::setSmoothingRadius</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getupdatebackgroundmodel">BackgroundSubtractorGMG::getUpdateBackgroundModel</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setupdatebackgroundmodel">BackgroundSubtractorGMG::setUpdateBackgroundModel</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getminval">BackgroundSubtractorGMG::getMinVal</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setminval">BackgroundSubtractorGMG::setMinVal</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getmaxval">BackgroundSubtractorGMG::getMaxVal</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setmaxval">BackgroundSubtractorGMG::setMaxVal</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-getbackgroundprior">BackgroundSubtractorGMG::getBackgroundPrior</a></li>
<li><a class="reference internal" href="#backgroundsubtractorgmg-setbackgroundprior">BackgroundSubtractorGMG::setBackgroundPrior</a></li>
<li><a class="reference internal" href="#createoptflow-dualtvl1">createOptFlow_DualTVL1</a></li>
<li><a class="reference internal" href="#denseopticalflow-calc">DenseOpticalFlow::calc</a></li>
<li><a class="reference internal" href="#denseopticalflow-collectgarbage">DenseOpticalFlow::collectGarbage</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="video.html" title="previous chapter">video. Video Analysis</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../calib3d/doc/calib3d.html" title="next chapter">calib3d. Camera Calibration and 3D Reconstruction</a></p>
        </div>
      </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="motion-analysis-and-object-tracking">
<h1>Motion Analysis and Object Tracking<a class="headerlink" href="#motion-analysis-and-object-tracking" title="Permalink to this headline">¶</a></h1>
<div class="section" id="calcopticalflowpyrlk">
<h2>calcOpticalFlowPyrLK<a class="headerlink" href="#calcopticalflowpyrlk" title="Permalink to this headline">¶</a></h2>
<p>Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.</p>
<dl class="function">
<dt id="void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">calcOpticalFlowPyrLK</tt><big>(</big>InputArray <strong>prevImg</strong>, InputArray <strong>nextImg</strong>, InputArray <strong>prevPts</strong>, InputOutputArray <strong>nextPts</strong>, OutputArray <strong>status</strong>, OutputArray <strong>err</strong>, Size <strong>winSize</strong>=Size(21,21), int <strong>maxLevel</strong>=3, TermCriteria <strong>criteria</strong>=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01), int <strong>flags</strong>=0, double <strong>minEigThreshold</strong>=1e-4 <big>)</big><a class="headerlink" href="#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EcalcOpticalFlowPyrLK"></a><dt id="cv2.calcOpticalFlowPyrLK">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">calcOpticalFlowPyrLK</tt><big>(</big>prevImg, nextImg, prevPts, nextPts<span class="optional">[</span>, status<span class="optional">[</span>, err<span class="optional">[</span>, winSize<span class="optional">[</span>, maxLevel<span class="optional">[</span>, criteria<span class="optional">[</span>, flags<span class="optional">[</span>, minEigThreshold<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → nextPts, status, err<a class="headerlink" href="#cv2.calcOpticalFlowPyrLK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCalcOpticalFlowPyrLK(const CvArr* prev, const CvArr* curr, CvArr* prev_pyr, CvArr* curr_pyr, const CvPoint2D32f* prev_features, CvPoint2D32f* curr_features, int count, CvSize win_size, int level, char* status, float* track_error, CvTermCriteria criteria, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCalcOpticalFlowPyrLK</tt><big>(</big>const CvArr* <strong>prev</strong>, const CvArr* <strong>curr</strong>, CvArr* <strong>prev_pyr</strong>, CvArr* <strong>curr_pyr</strong>, const CvPoint2D32f* <strong>prev_features</strong>, CvPoint2D32f* <strong>curr_features</strong>, int <strong>count</strong>, CvSize <strong>win_size</strong>, int <strong>level</strong>, char* <strong>status</strong>, float* <strong>track_error</strong>, CvTermCriteria <strong>criteria</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvCalcOpticalFlowPyrLK(const CvArr* prev, const CvArr* curr, CvArr* prev_pyr, CvArr* curr_pyr, const CvPoint2D32f* prev_features, CvPoint2D32f* curr_features, int count, CvSize win_size, int level, char* status, float* track_error, CvTermCriteria criteria, int flags)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prevImg</strong> – first 8-bit input image or pyramid constructed by <a class="reference internal" href="#int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)" title="int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">buildOpticalFlowPyramid()</span></tt></a>.</li>
<li><strong>nextImg</strong> – second input image or pyramid of the same size and the same type as <tt class="docutils literal"><span class="pre">prevImg</span></tt>.</li>
<li><strong>prevPts</strong> – vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers.</li>
<li><strong>nextPts</strong> – output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when <tt class="docutils literal"><span class="pre">OPTFLOW_USE_INITIAL_FLOW</span></tt> flag is passed, the vector must have the same size as in the input.</li>
<li><strong>status</strong> – output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0.</li>
<li><strong>err</strong> – output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in <tt class="docutils literal"><span class="pre">flags</span></tt> parameter; if the flow wasn’t found then the error is not defined (use the <tt class="docutils literal"><span class="pre">status</span></tt> parameter to find such cases).</li>
<li><strong>winSize</strong> – size of the search window at each pyramid level.</li>
<li><strong>maxLevel</strong> – 0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than <tt class="docutils literal"><span class="pre">maxLevel</span></tt>.</li>
<li><strong>criteria</strong> – parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations  <tt class="docutils literal"><span class="pre">criteria.maxCount</span></tt>  or when the search window moves by less than  <tt class="docutils literal"><span class="pre">criteria.epsilon</span></tt>.</li>
<li><strong>flags</strong> – <p>operation flags:</p>
<ul>
<li><strong>OPTFLOW_USE_INITIAL_FLOW</strong> uses initial estimations, stored in <tt class="docutils literal"><span class="pre">nextPts</span></tt>; if the flag is not set, then <tt class="docutils literal"><span class="pre">prevPts</span></tt> is copied to <tt class="docutils literal"><span class="pre">nextPts</span></tt> and is considered the initial estimate.</li>
<li><strong>OPTFLOW_LK_GET_MIN_EIGENVALS</strong> use minimum eigen values as an error measure (see <tt class="docutils literal"><span class="pre">minEigThreshold</span></tt> description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure.</li>
</ul>
</li>
<li><strong>minEigThreshold</strong> – the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in <a class="reference internal" href="#bouguet00" id="id1">[Bouguet00]</a>), divided by number of pixels in a window; if this value is less than <tt class="docutils literal"><span class="pre">minEigThreshold</span></tt>, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements a sparse iterative version of the Lucas-Kanade optical flow in pyramids. See <a class="reference internal" href="#bouguet00" id="id2">[Bouguet00]</a>. The function is parallelized with the TBB library.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/cpp/lkdemo.cpp</li>
<li>(Python) An example using the Lucas-Kanade optical flow algorithm can be found at opencv_source_code/samples/python2/lk_track.py</li>
<li>(Python) An example using the Lucas-Kanade tracker for homography matching can be found at opencv_source_code/samples/python2/lk_homography.py</li>
</ul>
</div>
</div>
<div class="section" id="buildopticalflowpyramid">
<h2>buildOpticalFlowPyramid<a class="headerlink" href="#buildopticalflowpyramid" title="Permalink to this headline">¶</a></h2>
<p>Constructs the image pyramid which can be passed to <a class="reference internal" href="#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)" title="void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcOpticalFlowPyrLK()</span></tt></a>.</p>
<dl class="function">
<dt id="int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">buildOpticalFlowPyramid</tt><big>(</big>InputArray <strong>img</strong>, OutputArrayOfArrays <strong>pyramid</strong>, Size <strong>winSize</strong>, int <strong>maxLevel</strong>, bool <strong>withDerivatives</strong>=true, int <strong>pyrBorder</strong>=BORDER_REFLECT_101, int <strong>derivBorder</strong>=BORDER_CONSTANT, bool <strong>tryReuseInputImage</strong>=true<big>)</big><a class="headerlink" href="#int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EbuildOpticalFlowPyramid"></a><dt id="cv2.buildOpticalFlowPyramid">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">buildOpticalFlowPyramid</tt><big>(</big>img, winSize, maxLevel<span class="optional">[</span>, pyramid<span class="optional">[</span>, withDerivatives<span class="optional">[</span>, pyrBorder<span class="optional">[</span>, derivBorder<span class="optional">[</span>, tryReuseInputImage<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → retval, pyramid<a class="headerlink" href="#cv2.buildOpticalFlowPyramid" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> – 8-bit input image.</li>
<li><strong>pyramid</strong> – output pyramid.</li>
<li><strong>winSize</strong> – window size of optical flow algorithm. Must be not less than <tt class="docutils literal"><span class="pre">winSize</span></tt> argument of <a class="reference internal" href="#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)" title="void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcOpticalFlowPyrLK()</span></tt></a>. It is needed to calculate required padding for pyramid levels.</li>
<li><strong>maxLevel</strong> – 0-based maximal pyramid level number.</li>
<li><strong>withDerivatives</strong> – set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then <a class="reference internal" href="#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)" title="void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcOpticalFlowPyrLK()</span></tt></a> will calculate them internally.</li>
<li><strong>pyrBorder</strong> – the border mode for pyramid layers.</li>
<li><strong>derivBorder</strong> – the border mode for gradients.</li>
<li><strong>tryReuseInputImage</strong> – put ROI of input image into the pyramid if possible. You can pass <tt class="docutils literal"><span class="pre">false</span></tt> to force data copying.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">number of levels in constructed pyramid. Can be less than <tt class="docutils literal"><span class="pre">maxLevel</span></tt>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="calcopticalflowfarneback">
<h2>calcOpticalFlowFarneback<a class="headerlink" href="#calcopticalflowfarneback" title="Permalink to this headline">¶</a></h2>
<p>Computes a dense optical flow using the Gunnar Farneback’s algorithm.</p>
<dl class="function">
<dt id="void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descname">calcOpticalFlowFarneback</tt><big>(</big>InputArray <strong>prev</strong>, InputArray <strong>next</strong>, InputOutputArray <strong>flow</strong>, double <strong>pyr_scale</strong>, int <strong>levels</strong>, int <strong>winsize</strong>, int <strong>iterations</strong>, int <strong>poly_n</strong>, double <strong>poly_sigma</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="void cvCalcOpticalFlowFarneback(const CvArr* prev, const CvArr* next, CvArr* flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)">
<strong>C:</strong><tt class="descname"> </tt>void <tt class="descname">cvCalcOpticalFlowFarneback</tt><big>(</big>const CvArr* <strong>prev</strong>, const CvArr* <strong>next</strong>, CvArr* <strong>flow</strong>, double <strong>pyr_scale</strong>, int <strong>levels</strong>, int <strong>winsize</strong>, int <strong>iterations</strong>, int <strong>poly_n</strong>, double <strong>poly_sigma</strong>, int <strong>flags</strong><big>)</big><a class="headerlink" href="#void cvCalcOpticalFlowFarneback(const CvArr* prev, const CvArr* next, CvArr* flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EcalcOpticalFlowFarneback"></a><dt id="cv2.calcOpticalFlowFarneback">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">calcOpticalFlowFarneback</tt><big>(</big>prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags<big>)</big> → flow<a class="headerlink" href="#cv2.calcOpticalFlowFarneback" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prev</strong> – first 8-bit single-channel input image.</li>
<li><strong>next</strong> – second input image of the same size and the same type as <tt class="docutils literal"><span class="pre">prev</span></tt>.</li>
<li><strong>flow</strong> – computed flow image that has the same size as <tt class="docutils literal"><span class="pre">prev</span></tt> and type <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt>.</li>
<li><strong>pyr_scale</strong> – parameter, specifying the image scale (&lt;1) to build pyramids for each image; <tt class="docutils literal"><span class="pre">pyr_scale=0.5</span></tt> means a classical pyramid, where each next layer is twice smaller than the previous one.</li>
<li><strong>levels</strong> – number of pyramid layers including the initial image; <tt class="docutils literal"><span class="pre">levels=1</span></tt> means that no extra layers are created and only the original images are used.</li>
<li><strong>winsize</strong> – averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field.</li>
<li><strong>iterations</strong> – number of iterations the algorithm does at each pyramid level.</li>
<li><strong>poly_n</strong> – size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred  motion field, typically <tt class="docutils literal"><span class="pre">poly_n</span></tt> =5 or 7.</li>
<li><strong>poly_sigma</strong> – standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for  <tt class="docutils literal"><span class="pre">poly_n=5</span></tt>, you can set <tt class="docutils literal"><span class="pre">poly_sigma=1.1</span></tt>, for <tt class="docutils literal"><span class="pre">poly_n=7</span></tt>, a good value would be <tt class="docutils literal"><span class="pre">poly_sigma=1.5</span></tt>.</li>
<li><strong>flags</strong> – <p>operation flags that can be a combination of the following:</p>
<ul>
<li><strong>OPTFLOW_USE_INITIAL_FLOW</strong> uses the input  <tt class="docutils literal"><span class="pre">flow</span></tt>  as an initial flow approximation.</li>
<li><strong>OPTFLOW_FARNEBACK_GAUSSIAN</strong> uses the Gaussian <img class="math" src="../../../_images/math/58841bc202b87ff23dc2f1bbc8bbfebe54767b8c.png" alt="\texttt{winsize}\times\texttt{winsize}"> filter instead of a box filter of the same size for optical flow estimation; usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; normally, <tt class="docutils literal"><span class="pre">winsize</span></tt> for a Gaussian window should be set to a larger value to achieve the same level of robustness.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function finds an optical flow for each <tt class="docutils literal"><span class="pre">prev</span></tt> pixel using the <a class="reference internal" href="#farneback2003" id="id3">[Farneback2003]</a> algorithm so that</p>
<div class="math">
<p><img src="../../../_images/math/fbf93c97d884d92c45f13996a3698283840829cd.png" alt="\texttt{prev} (y,x)  \sim \texttt{next} ( y + \texttt{flow} (y,x)[1],  x + \texttt{flow} (y,x)[0])"></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/cpp/fback.cpp</li>
<li>(Python) An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv_source_code/samples/python2/opt_flow.py</li>
</ul>
</div>
</div>
<div class="section" id="estimaterigidtransform">
<h2>estimateRigidTransform<a class="headerlink" href="#estimaterigidtransform" title="Permalink to this headline">¶</a></h2>
<p>Computes an optimal affine transformation between two 2D point sets.</p>
<dl class="function">
<dt id="Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)">
<strong>C++:</strong><tt class="descname"> </tt>Mat <tt class="descname">estimateRigidTransform</tt><big>(</big>InputArray <strong>src</strong>, InputArray <strong>dst</strong>, bool <strong>fullAffine</strong><big>)</big><a class="headerlink" href="#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EestimateRigidTransform"></a><dt id="cv2.estimateRigidTransform">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">estimateRigidTransform</tt><big>(</big>src, dst, fullAffine<big>)</big> → retval<a class="headerlink" href="#cv2.estimateRigidTransform" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>src</strong> – First input 2D point set stored in <tt class="docutils literal"><span class="pre">std::vector</span></tt> or <tt class="docutils literal"><span class="pre">Mat</span></tt>, or an image stored in <tt class="docutils literal"><span class="pre">Mat</span></tt>.</li>
<li><strong>dst</strong> – Second input 2D point set of the same size and the same type as <tt class="docutils literal"><span class="pre">A</span></tt>, or another image.</li>
<li><strong>fullAffine</strong> – If true, the function finds an optimal affine transformation with no additional restrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is limited to combinations of translation, rotation, and uniform scaling (5 degrees of freedom).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function finds an optimal affine transform <em>[A|b]</em> (a <tt class="docutils literal"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">3</span></tt> floating-point matrix) that approximates best the affine transformation between:</p>
<blockquote>
<div><ul class="simple">
<li>Two point sets</li>
<li>Two raster images. In this case, the function first finds some features in the <tt class="docutils literal"><span class="pre">src</span></tt> image and finds the corresponding features in <tt class="docutils literal"><span class="pre">dst</span></tt> image. After that, the problem is reduced to the first case.</li>
</ul>
</div></blockquote>
<p>In case of point sets, the problem is formulated as follows: you need to find a 2x2 matrix <em>A</em> and 2x1 vector <em>b</em> so that:</p>
<blockquote>
<div><div class="math">
<p><img src="../../../_images/math/f8a14dd7db6d05574d1b960fe9f1e72bf48adf77.png" alt="[A^*|b^*] = arg  \min _{[A|b]}  \sum _i  \| \texttt{dst}[i] - A { \texttt{src}[i]}^T - b  \| ^2"></p>
</div><p>where <tt class="docutils literal"><span class="pre">src[i]</span></tt> and <tt class="docutils literal"><span class="pre">dst[i]</span></tt> are the i-th points in <tt class="docutils literal"><span class="pre">src</span></tt> and <tt class="docutils literal"><span class="pre">dst</span></tt>, respectively</p>
<p><img class="math" src="../../../_images/math/9e97cf946936c8fb6ca6e71ae78ee6747072e80a.png" alt="[A|b]"> can be either arbitrary (when <tt class="docutils literal"><span class="pre">fullAffine=true</span></tt> ) or have a form of</p>
<div class="math">
<p><img src="../../../_images/math/0a22facbc11cdd0f9b8d4658e0c145da2cb8730b.png" alt="\begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1  \\ -a_{12} &amp; a_{11} &amp; b_2  \end{bmatrix}"></p>
</div><p>when <tt class="docutils literal"><span class="pre">fullAffine=false</span></tt> .</p>
</div></blockquote>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getAffineTransform(InputArray src, InputArray dst)" title="Mat getAffineTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getAffineTransform()</span></tt></a>,
<a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)" title="Mat getPerspectiveTransform(InputArray src, InputArray dst)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">getPerspectiveTransform()</span></tt></a>,
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a></p>
</div>
</div>
<div class="section" id="findtransformecc">
<h2>findTransformECC<a class="headerlink" href="#findtransformecc" title="Permalink to this headline">¶</a></h2>
<p>Finds the geometric transform (warp) between two images in terms of the ECC criterion <a class="reference internal" href="#ep08" id="id4">[EP08]</a>.</p>
<dl class="function">
<dt id="double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria)">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descname">findTransformECC</tt><big>(</big>InputArray <strong>templateImage</strong>, InputArray <strong>inputImage</strong>, InputOutputArray <strong>warpMatrix</strong>, int <strong>motionType</strong>=MOTION_AFFINE, TermCriteria <strong>criteria</strong>=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001)<big>)</big><a class="headerlink" href="#double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EfindTransformECC"></a><dt id="cv2.findTransformECC">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">findTransformECC</tt><big>(</big>templateImage, inputImage, warpMatrix<span class="optional">[</span>, motionType<span class="optional">[</span>, criteria<span class="optional">]</span><span class="optional">]</span><big>)</big> → retval, warpMatrix<a class="headerlink" href="#cv2.findTransformECC" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>templateImage</strong> – single-channel template image; <tt class="docutils literal"><span class="pre">CV_8U</span></tt> or <tt class="docutils literal"><span class="pre">CV_32F</span></tt> array.</li>
<li><strong>inputImage</strong> – single-channel input image which should be warped with the final <tt class="docutils literal"><span class="pre">warpMatrix</span></tt> in order to provide an image similar to <tt class="docutils literal"><span class="pre">templateImage</span></tt>, same type as <tt class="docutils literal"><span class="pre">temlateImage</span></tt>.</li>
<li><strong>warpMatrix</strong> – floating-point <img class="math" src="../../../_images/math/f335f976f482cd08e9c6c198204b18c1fc769882.png" alt="2\times 3"> or <img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3"> mapping matrix (warp).</li>
<li><strong>motionType</strong> – <p>parameter, specifying the type of motion:</p>
<ul>
<li><strong>MOTION_TRANSLATION</strong> sets a translational motion model; <tt class="docutils literal"><span class="pre">warpMatrix</span></tt> is <img class="math" src="../../../_images/math/f335f976f482cd08e9c6c198204b18c1fc769882.png" alt="2\times 3"> with the first <img class="math" src="../../../_images/math/64dc528a93ad1405a6bc5e773d77230501862a04.png" alt="2\times 2"> part being the unity matrix and the rest two parameters being estimated.</li>
<li><strong>MOTION_EUCLIDEAN</strong> sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; <tt class="docutils literal"><span class="pre">warpMatrix</span></tt> is <img class="math" src="../../../_images/math/f335f976f482cd08e9c6c198204b18c1fc769882.png" alt="2\times 3">.</li>
<li><strong>MOTION_AFFINE</strong> sets an affine motion model (DEFAULT); six parameters are estimated; <tt class="docutils literal"><span class="pre">warpMatrix</span></tt> is <img class="math" src="../../../_images/math/f335f976f482cd08e9c6c198204b18c1fc769882.png" alt="2\times 3">.</li>
<li><strong>MOTION_HOMOGRAPHY</strong> sets a homography as a motion model; eight parameters are estimated;``warpMatrix`` is <img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3">.</li>
</ul>
</li>
<li><strong>criteria</strong> – parameter, specifying the termination criteria of the ECC algorithm; <tt class="docutils literal"><span class="pre">criteria.epsilon</span></tt> defines the threshold of the increment in the correlation coefficient between two iterations (a negative <tt class="docutils literal"><span class="pre">criteria.epsilon</span></tt> makes <tt class="docutils literal"><span class="pre">criteria.maxcount</span></tt> the only termination criterion). Default values are shown in the declaration above.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function estimates the optimum transformation (<tt class="docutils literal"><span class="pre">warpMatrix</span></tt>) with respect to ECC criterion (<a class="reference internal" href="#ep08" id="id5">[EP08]</a>), that is</p>
<div class="math">
<p><img src="../../../_images/math/56bf41735dc70a34096466b5291eafaa3f80c2b6.png" alt="\texttt{warpMatrix} = \texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x',y'))"></p>
</div><p>where</p>
<div class="math">
<p><img src="../../../_images/math/eb1364c953f1d59a7503fb04292b559813c0b3c5.png" alt="\begin{bmatrix} x' \\ y' \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}"></p>
</div><p>(the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a <img class="math" src="../../../_images/math/268e62297468c4d7ef109727ed4bcbfad953ad61.png" alt="3\times 3"> matrix is given with <tt class="docutils literal"><span class="pre">motionType</span></tt> =0, 1 or 2, the third row is ignored.</p>
<p>Unlike <a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a> and <a class="reference internal" href="#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)" title="Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">estimateRigidTransform()</span></tt></a>, the function <a class="reference internal" href="#double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria)" title="double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findTransformECC()</span></tt></a> implements an area-based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) should be given as input. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.e. use the flag <tt class="docutils literal"><span class="pre">WARP_INVERSE_MAP</span></tt> with <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpAffine()</span></tt></a> or <a class="reference internal" href="../../imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)" title="void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar&amp; borderValue)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">warpPerspective()</span></tt></a>. See also the OpenCV sample <tt class="docutils literal"><span class="pre">image_alignment.cpp</span></tt> that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)" title="Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">estimateRigidTransform()</span></tt></a>,
<a class="reference internal" href="../../calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)" title="Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findHomography()</span></tt></a></p>
</div>
</div>
<div class="section" id="camshift">
<h2>CamShift<a class="headerlink" href="#camshift" title="Permalink to this headline">¶</a></h2>
<p>Finds an object center, size, and orientation.</p>
<dl class="function">
<dt id="RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)">
<strong>C++:</strong><tt class="descname"> </tt>RotatedRect <tt class="descname">CamShift</tt><big>(</big>InputArray <strong>probImage</strong>, Rect&amp; <strong>window</strong>, TermCriteria <strong>criteria</strong><big>)</big><a class="headerlink" href="#RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2ECamShift"></a><dt id="cv2.CamShift">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">CamShift</tt><big>(</big>probImage, window, criteria<big>)</big> → retval, window<a class="headerlink" href="#cv2.CamShift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvCamShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp, CvBox2D* box)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvCamShift</tt><big>(</big>const CvArr* <strong>prob_image</strong>, CvRect <strong>window</strong>, CvTermCriteria <strong>criteria</strong>, CvConnectedComp* <strong>comp</strong>, CvBox2D* <strong>box</strong>=NULL <big>)</big><a class="headerlink" href="#int cvCamShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp, CvBox2D* box)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>probImage</strong> – Back projection of the object histogram. See  <a class="reference internal" href="../../imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)" title="void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcBackProject()</span></tt></a> .</li>
<li><strong>window</strong> – Initial search window.</li>
<li><strong>criteria</strong> – Stop criteria for the underlying  <a class="reference internal" href="#int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">meanShift()</span></tt></a> .</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(in old interfaces) Number of iterations CAMSHIFT took to converge</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the CAMSHIFT object tracking algorithm
<a class="reference internal" href="#bradski98" id="id6">[Bradski98]</a>.
First, it finds an object center using
<a class="reference internal" href="#int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">meanShift()</span></tt></a> and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with <tt class="docutils literal"><span class="pre">RotatedRect::boundingRect()</span></tt> .</p>
<p>See the OpenCV sample <tt class="docutils literal"><span class="pre">camshiftdemo.c</span></tt> that tracks colored objects.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>(Python) A sample explaining the camshift tracking algorithm can be found at opencv_source_code/samples/python2/camshift.py</li>
</ul>
</div>
</div>
<div class="section" id="meanshift">
<h2>meanShift<a class="headerlink" href="#meanshift" title="Permalink to this headline">¶</a></h2>
<p>Finds an object on a back projection image.</p>
<dl class="function">
<dt id="int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descname">meanShift</tt><big>(</big>InputArray <strong>probImage</strong>, Rect&amp; <strong>window</strong>, TermCriteria <strong>criteria</strong><big>)</big><a class="headerlink" href="#int meanShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EmeanShift"></a><dt id="cv2.meanShift">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">meanShift</tt><big>(</big>probImage, window, criteria<big>)</big> → retval, window<a class="headerlink" href="#cv2.meanShift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="int cvMeanShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp)">
<strong>C:</strong><tt class="descname"> </tt>int <tt class="descname">cvMeanShift</tt><big>(</big>const CvArr* <strong>prob_image</strong>, CvRect <strong>window</strong>, CvTermCriteria <strong>criteria</strong>, CvConnectedComp* <strong>comp</strong><big>)</big><a class="headerlink" href="#int cvMeanShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>probImage</strong> – Back projection of the object histogram. See  <a class="reference internal" href="../../imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)" title="void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcBackProject()</span></tt></a> for details.</li>
<li><strong>window</strong> – Initial search window.</li>
<li><strong>criteria</strong> – Stop criteria for the iterative search algorithm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Number of iterations CAMSHIFT took to converge.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in <tt class="docutils literal"><span class="pre">window</span></tt> of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations <tt class="docutils literal"><span class="pre">criteria.maxCount</span></tt> is done or until the window center shifts by less than <tt class="docutils literal"><span class="pre">criteria.epsilon</span></tt> . The algorithm is used inside
<a class="reference internal" href="#RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">CamShift()</span></tt></a> and, unlike
<a class="reference internal" href="#RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)" title="RotatedRect CamShift(InputArray probImage, Rect&amp; window, TermCriteria criteria)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">CamShift()</span></tt></a> , the search window size or orientation do not change during the search. You can simply pass the output of
<a class="reference internal" href="../../imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)" title="void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">calcBackProject()</span></tt></a> to this function. But better results can be obtained if you pre-filter the back projection and remove the noise. For example, you can do this by retrieving connected components with
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)" title="void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">findContours()</span></tt></a> , throwing away contours with small area (
<a class="reference internal" href="../../imgproc/doc/structural_analysis_and_shape_descriptors.html#double contourArea(InputArray contour, bool oriented)" title="double contourArea(InputArray contour, bool oriented)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">contourArea()</span></tt></a> ), and rendering the  remaining contours with
<a class="reference internal" href="../../imgproc/doc/drawing_functions.html#void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)" title="void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar&amp; color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">drawContours()</span></tt></a> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A mean-shift tracking sample can be found at opencv_source_code/samples/cpp/camshiftdemo.cpp</li>
</ul>
</div>
</div>
<div class="section" id="kalmanfilter">
<h2>KalmanFilter<a class="headerlink" href="#kalmanfilter" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="KalmanFilter">
<em class="property">class </em><tt class="descname">KalmanFilter</tt><a class="headerlink" href="#KalmanFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Kalman filter class.</p>
</dd></dl>

<p>The class implements a standard Kalman filter
<a class="reference external" href="http://en.wikipedia.org/wiki/Kalman_filter">http://en.wikipedia.org/wiki/Kalman_filter</a>, <a class="reference internal" href="#welch95" id="id7">[Welch95]</a>. However, you can modify <tt class="docutils literal"><span class="pre">transitionMatrix</span></tt>, <tt class="docutils literal"><span class="pre">controlMatrix</span></tt>, and <tt class="docutils literal"><span class="pre">measurementMatrix</span></tt> to get an extended Kalman filter functionality. See the OpenCV sample <tt class="docutils literal"><span class="pre">kalman.cpp</span></tt> .</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example using the standard Kalman filter can be found at opencv_source_code/samples/cpp/kalman.cpp</li>
</ul>
</div>
</div>
<div class="section" id="kalmanfilter-kalmanfilter">
<h2>KalmanFilter::KalmanFilter<a class="headerlink" href="#kalmanfilter-kalmanfilter" title="Permalink to this headline">¶</a></h2>
<p>The constructors.</p>
<dl class="function">
<dt id="KalmanFilter::KalmanFilter()">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">KalmanFilter::</tt><tt class="descname">KalmanFilter</tt><big>(</big><big>)</big><a class="headerlink" href="#KalmanFilter::KalmanFilter()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="KalmanFilter::KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">KalmanFilter::</tt><tt class="descname">KalmanFilter</tt><big>(</big>int <strong>dynamParams</strong>, int <strong>measureParams</strong>, int <strong>controlParams</strong>=0, int <strong>type</strong>=CV_32F<big>)</big><a class="headerlink" href="#KalmanFilter::KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKalmanFilter"></a><dt id="cv2.KalmanFilter">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">KalmanFilter</tt><big>(</big><span class="optional">[</span>dynamParams, measureParams<span class="optional">[</span>, controlParams<span class="optional">[</span>, type<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → &lt;KalmanFilter object&gt;<a class="headerlink" href="#cv2.KalmanFilter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="CvKalman* cvCreateKalman(int dynam_params, int measure_params, int control_params)">
<strong>C:</strong><tt class="descname"> </tt>CvKalman* <tt class="descname">cvCreateKalman</tt><big>(</big>int <strong>dynam_params</strong>, int <strong>measure_params</strong>, int <strong>control_params</strong>=0 <big>)</big><a class="headerlink" href="#CvKalman* cvCreateKalman(int dynam_params, int measure_params, int control_params)" title="Permalink to this definition">¶</a></dt>
<dd><p>The full constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dynamParams</strong> – Dimensionality of the state.</li>
<li><strong>measureParams</strong> – Dimensionality of the measurement.</li>
<li><strong>controlParams</strong> – Dimensionality of the control vector.</li>
<li><strong>type</strong> – Type of the created matrices that should be <tt class="docutils literal"><span class="pre">CV_32F</span></tt> or <tt class="docutils literal"><span class="pre">CV_64F</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In C API when <tt class="docutils literal"><span class="pre">CvKalman*</span> <span class="pre">kalmanFilter</span></tt> structure is not needed anymore, it should be released with <tt class="docutils literal"><span class="pre">cvReleaseKalman(&amp;kalmanFilter)</span></tt></p>
</div>
</div>
<div class="section" id="kalmanfilter-init">
<h2>KalmanFilter::init<a class="headerlink" href="#kalmanfilter-init" title="Permalink to this headline">¶</a></h2>
<p>Re-initializes Kalman filter. The previous content is destroyed.</p>
<dl class="function">
<dt id="void KalmanFilter::init(int dynamParams, int measureParams, int controlParams, int type)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">KalmanFilter::</tt><tt class="descname">init</tt><big>(</big>int <strong>dynamParams</strong>, int <strong>measureParams</strong>, int <strong>controlParams</strong>=0, int <strong>type</strong>=CV_32F<big>)</big><a class="headerlink" href="#void KalmanFilter::init(int dynamParams, int measureParams, int controlParams, int type)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dynamParams</strong> – Dimensionalityensionality of the state.</li>
<li><strong>measureParams</strong> – Dimensionality of the measurement.</li>
<li><strong>controlParams</strong> – Dimensionality of the control vector.</li>
<li><strong>type</strong> – Type of the created matrices that should be <tt class="docutils literal"><span class="pre">CV_32F</span></tt> or <tt class="docutils literal"><span class="pre">CV_64F</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="kalmanfilter-predict">
<h2>KalmanFilter::predict<a class="headerlink" href="#kalmanfilter-predict" title="Permalink to this headline">¶</a></h2>
<p>Computes a predicted state.</p>
<dl class="function">
<dt id="const Mat&amp; KalmanFilter::predict(const Mat&amp; control)">
<strong>C++:</strong><tt class="descname"> </tt>const Mat&amp; <tt class="descclassname">KalmanFilter::</tt><tt class="descname">predict</tt><big>(</big>const Mat&amp; <strong>control</strong>=Mat()<big>)</big><a class="headerlink" href="#const Mat&amp; KalmanFilter::predict(const Mat&amp; control)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKalmanFilter%2Epredict"></a><dt id="cv2.KalmanFilter.predict">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.KalmanFilter.</tt><tt class="descname">predict</tt><big>(</big><span class="optional">[</span>control<span class="optional">]</span><big>)</big> → retval<a class="headerlink" href="#cv2.KalmanFilter.predict" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="const CvMat* cvKalmanPredict(CvKalman* kalman, const CvMat* control)">
<strong>C:</strong><tt class="descname"> </tt>const CvMat* <tt class="descname">cvKalmanPredict</tt><big>(</big>CvKalman* <strong>kalman</strong>, const CvMat* <strong>control</strong>=NULL<big>)</big><a class="headerlink" href="#const CvMat* cvKalmanPredict(CvKalman* kalman, const CvMat* control)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>control</strong> – The optional input control</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="kalmanfilter-correct">
<h2>KalmanFilter::correct<a class="headerlink" href="#kalmanfilter-correct" title="Permalink to this headline">¶</a></h2>
<p>Updates the predicted state from the measurement.</p>
<dl class="function">
<dt id="const Mat&amp; KalmanFilter::correct(const Mat&amp; measurement)">
<strong>C++:</strong><tt class="descname"> </tt>const Mat&amp; <tt class="descclassname">KalmanFilter::</tt><tt class="descname">correct</tt><big>(</big>const Mat&amp; <strong>measurement</strong><big>)</big><a class="headerlink" href="#const Mat&amp; KalmanFilter::correct(const Mat&amp; measurement)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EKalmanFilter%2Ecorrect"></a><dt id="cv2.KalmanFilter.correct">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.KalmanFilter.</tt><tt class="descname">correct</tt><big>(</big>measurement<big>)</big> → retval<a class="headerlink" href="#cv2.KalmanFilter.correct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="cfunction">
<dt id="const CvMat* cvKalmanCorrect(CvKalman* kalman, const CvMat* measurement)">
<strong>C:</strong><tt class="descname"> </tt>const CvMat* <tt class="descname">cvKalmanCorrect</tt><big>(</big>CvKalman* <strong>kalman</strong>, const CvMat* <strong>measurement</strong><big>)</big><a class="headerlink" href="#const CvMat* cvKalmanCorrect(CvKalman* kalman, const CvMat* measurement)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>measurement</strong> – The measured system parameters</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractor">
<h2>BackgroundSubtractor<a class="headerlink" href="#backgroundsubtractor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BackgroundSubtractor : public Algorithm">
<em class="property">class </em><tt class="descname">BackgroundSubtractor</tt> : <em class="property">public</em> <tt class="descname">Algorithm</tt><a class="headerlink" href="#BackgroundSubtractor : public Algorithm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Base class for background/foreground segmentation.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BackgroundSubtractor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Algorithm</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">BackgroundSubtractor</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">apply</span><span class="p">(</span><span class="n">InputArray</span> <span class="n">image</span><span class="p">,</span> <span class="n">OutputArray</span> <span class="n">fgmask</span><span class="p">,</span> <span class="kt">double</span> <span class="n">learningRate</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">getBackgroundImage</span><span class="p">(</span><span class="n">OutputArray</span> <span class="n">backgroundImage</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The class is only used to define the common interface for the whole family of background/foreground segmentation algorithms.</p>
</div>
<div class="section" id="backgroundsubtractor-apply">
<h2>BackgroundSubtractor::apply<a class="headerlink" href="#backgroundsubtractor-apply" title="Permalink to this headline">¶</a></h2>
<p>Computes a foreground mask.</p>
<dl class="function">
<dt id="void BackgroundSubtractor::apply(InputArray image, OutputArray fgmask, double learningRate)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractor::</tt><tt class="descname">apply</tt><big>(</big>InputArray <strong>image</strong>, OutputArray <strong>fgmask</strong>, double <strong>learningRate</strong>=-1<big>)</big><a class="headerlink" href="#void BackgroundSubtractor::apply(InputArray image, OutputArray fgmask, double learningRate)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EBackgroundSubtractor%2Eapply"></a><dt id="cv2.BackgroundSubtractor.apply">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.BackgroundSubtractor.</tt><tt class="descname">apply</tt><big>(</big>image<span class="optional">[</span>, fgmask<span class="optional">[</span>, learningRate<span class="optional">]</span><span class="optional">]</span><big>)</big> → fgmask<a class="headerlink" href="#cv2.BackgroundSubtractor.apply" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> – Next video frame.</li>
<li><strong>fgmask</strong> – The output foreground mask as an 8-bit binary image.</li>
<li><strong>learningRate</strong> – The value between 0 and 1 that indicates how fast the background model is learnt. Negative parameter value makes the algorithm to use some automatically chosen learning rate. 0 means that the background model is not updated at all, 1 means that the background model is completely reinitialized from the last frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractor-getbackgroundimage">
<h2>BackgroundSubtractor::getBackgroundImage<a class="headerlink" href="#backgroundsubtractor-getbackgroundimage" title="Permalink to this headline">¶</a></h2>
<p>Computes a background image.</p>
<dl class="function">
<dt id="void BackgroundSubtractor::getBackgroundImage(OutputArray backgroundImage) const">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractor::</tt><tt class="descname">getBackgroundImage</tt><big>(</big>OutputArray <strong>backgroundImage</strong><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#void BackgroundSubtractor::getBackgroundImage(OutputArray backgroundImage) const" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>backgroundImage</strong> – The output background image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sometimes the background image can be very blurry, as it contain the average background statistics.</p>
</div>
</div>
<div class="section" id="backgroundsubtractormog">
<h2>BackgroundSubtractorMOG<a class="headerlink" href="#backgroundsubtractormog" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="BackgroundSubtractorMOG : public BackgroundSubtractor">
<em class="property">class </em><tt class="descname">BackgroundSubtractorMOG</tt> : <em class="property">public</em> <tt class="descname">BackgroundSubtractor</tt><a class="headerlink" href="#BackgroundSubtractorMOG : public BackgroundSubtractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Gaussian Mixture-based Background/Foreground Segmentation Algorithm.</p>
<p>The class implements the algorithm described in <a class="reference internal" href="#kb2001" id="id8">[KB2001]</a>.</p>
</div>
<div class="section" id="createbackgroundsubtractormog">
<h2>createBackgroundSubtractorMOG<a class="headerlink" href="#createbackgroundsubtractormog" title="Permalink to this headline">¶</a></h2>
<p>Creates mixture-of-gaussian background subtractor</p>
<dl class="function">
<dt id="Ptr&lt;BackgroundSubtractorMOG&gt; createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BackgroundSubtractorMOG&gt; <tt class="descname">createBackgroundSubtractorMOG</tt><big>(</big>int <strong>history</strong>=200, int <strong>nmixtures</strong>=5, double <strong>backgroundRatio</strong>=0.7, double <strong>noiseSigma</strong>=0<big>)</big><a class="headerlink" href="#Ptr&lt;BackgroundSubtractorMOG&gt; createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EcreateBackgroundSubtractorMOG"></a><dt id="cv2.createBackgroundSubtractorMOG">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">createBackgroundSubtractorMOG</tt><big>(</big><span class="optional">[</span>history<span class="optional">[</span>, nmixtures<span class="optional">[</span>, backgroundRatio<span class="optional">[</span>, noiseSigma<span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> → retval<a class="headerlink" href="#cv2.createBackgroundSubtractorMOG" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>history</strong> – Length of the history.</li>
<li><strong>nmixtures</strong> – Number of Gaussian mixtures.</li>
<li><strong>backgroundRatio</strong> – Background ratio.</li>
<li><strong>noiseSigma</strong> – Noise strength (standard deviation of the brightness or each color channel). 0 means some automatic value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2">
<h2>BackgroundSubtractorMOG2<a class="headerlink" href="#backgroundsubtractormog2" title="Permalink to this headline">¶</a></h2>
<p>Gaussian Mixture-based Background/Foreground Segmentation Algorithm.</p>
<dl class="class">
<dt id="BackgroundSubtractorMOG2 : public BackgroundSubtractor">
<em class="property">class </em><tt class="descname">BackgroundSubtractorMOG2</tt> : <em class="property">public</em> <tt class="descname">BackgroundSubtractor</tt><a class="headerlink" href="#BackgroundSubtractorMOG2 : public BackgroundSubtractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class implements the Gaussian mixture model background subtraction described in <a class="reference internal" href="#zivkovic2004" id="id9">[Zivkovic2004]</a> and <a class="reference internal" href="#zivkovic2006" id="id10">[Zivkovic2006]</a> .</p>
</div>
<div class="section" id="createbackgroundsubtractormog2">
<h2>createBackgroundSubtractorMOG2<a class="headerlink" href="#createbackgroundsubtractormog2" title="Permalink to this headline">¶</a></h2>
<p>Creates MOG2 Background Subtractor</p>
<dl class="function">
<dt id="Ptr&lt;BackgroundSubtractorMOG2&gt; createBackgroundSubtractorMOG2(int history, double varThreshold, bool detectShadows)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BackgroundSubtractorMOG2&gt; <tt class="descname">createBackgroundSubtractorMOG2</tt><big>(</big>int <strong>history</strong>=500, double <strong>varThreshold</strong>=16, bool <strong>detectShadows</strong>=true <big>)</big><a class="headerlink" href="#Ptr&lt;BackgroundSubtractorMOG2&gt; createBackgroundSubtractorMOG2(int history, double varThreshold, bool detectShadows)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>history</strong> – Length of the history.</li>
<li><strong>varThreshold</strong> – Threshold on the squared Mahalanobis distance between the pixel and the model to decide whether a pixel is well described by the background model. This parameter does not affect the background update.</li>
<li><strong>detectShadows</strong> – If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-gethistory">
<h2>BackgroundSubtractorMOG2::getHistory<a class="headerlink" href="#backgroundsubtractormog2-gethistory" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of last frames that affect the background model</p>
<dl class="function">
<dt id="int BackgroundSubtractorMOG2::getHistory() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getHistory</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorMOG2::getHistory() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-sethistory">
<h2>BackgroundSubtractorMOG2::setHistory<a class="headerlink" href="#backgroundsubtractormog2-sethistory" title="Permalink to this headline">¶</a></h2>
<p>Sets the number of last frames that affect the background model</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setHistory(int history)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setHistory</tt><big>(</big>int <strong>history</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setHistory(int history)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getnmixtures">
<h2>BackgroundSubtractorMOG2::getNMixtures<a class="headerlink" href="#backgroundsubtractormog2-getnmixtures" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of gaussian components in the background model</p>
<dl class="function">
<dt id="int BackgroundSubtractorMOG2::getNMixtures() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getNMixtures</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorMOG2::getNMixtures() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-setnmixtures">
<h2>BackgroundSubtractorMOG2::setNMixtures<a class="headerlink" href="#backgroundsubtractormog2-setnmixtures" title="Permalink to this headline">¶</a></h2>
<p>Sets the number of gaussian components in the background model. The model needs to be reinitalized to reserve memory.</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setNMixtures(int nmixtures)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setNMixtures</tt><big>(</big>int <strong>nmixtures</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setNMixtures(int nmixtures)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getbackgroundratio">
<h2>BackgroundSubtractorMOG2::getBackgroundRatio<a class="headerlink" href="#backgroundsubtractormog2-getbackgroundratio" title="Permalink to this headline">¶</a></h2>
<p>Returns the “background ratio” parameter of the algorithm</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getBackgroundRatio() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getBackgroundRatio</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getBackgroundRatio() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>If a foreground pixel keeps semi-constant value for about <tt class="docutils literal"><span class="pre">backgroundRatio*history</span></tt> frames, it’s considered background and added to the model as a center of a new component. It corresponds to <tt class="docutils literal"><span class="pre">TB</span></tt> parameter in the paper.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setbackgroundratio">
<h2>BackgroundSubtractorMOG2::setBackgroundRatio<a class="headerlink" href="#backgroundsubtractormog2-setbackgroundratio" title="Permalink to this headline">¶</a></h2>
<p>Sets the “background ratio” parameter of the algorithm</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setBackgroundRatio(double ratio)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setBackgroundRatio</tt><big>(</big>double <strong>ratio</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setBackgroundRatio(double ratio)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getvarthreshold">
<h2>BackgroundSubtractorMOG2::getVarThreshold<a class="headerlink" href="#backgroundsubtractormog2-getvarthreshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the variance threshold for the pixel-model match</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getVarThreshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getVarThreshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getVarThreshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The main threshold on the squared Mahalanobis distance to decide if the sample is well described by the background model or not. Related to Cthr from the paper.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setvarthreshold">
<h2>BackgroundSubtractorMOG2::setVarThreshold<a class="headerlink" href="#backgroundsubtractormog2-setvarthreshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the variance threshold for the pixel-model match</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setVarThreshold(double varThreshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setVarThreshold</tt><big>(</big>double <strong>varThreshold</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setVarThreshold(double varThreshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getvarthresholdgen">
<h2>BackgroundSubtractorMOG2::getVarThresholdGen<a class="headerlink" href="#backgroundsubtractormog2-getvarthresholdgen" title="Permalink to this headline">¶</a></h2>
<p>Returns the variance threshold for the pixel-model match used for new mixture component generation</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getVarThresholdGen() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getVarThresholdGen</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getVarThresholdGen() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Threshold for the squared Mahalanobis distance that helps decide when a sample is close to the existing components (corresponds to <tt class="docutils literal"><span class="pre">Tg</span></tt> in the paper). If a pixel is not close to any component, it is considered foreground or added as a new component. <tt class="docutils literal"><span class="pre">3</span> <span class="pre">sigma</span> <span class="pre">=&gt;</span> <span class="pre">Tg=3*3=9</span></tt> is default. A smaller <tt class="docutils literal"><span class="pre">Tg</span></tt> value generates more components. A higher <tt class="docutils literal"><span class="pre">Tg</span></tt> value may result in a small number of components but they can grow too large.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setvarthresholdgen">
<h2>BackgroundSubtractorMOG2::setVarThresholdGen<a class="headerlink" href="#backgroundsubtractormog2-setvarthresholdgen" title="Permalink to this headline">¶</a></h2>
<p>Sets the variance threshold for the pixel-model match used for new mixture component generation</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setVarThresholdGen(double varThresholdGen)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setVarThresholdGen</tt><big>(</big>double <strong>varThresholdGen</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setVarThresholdGen(double varThresholdGen)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getvarinit">
<h2>BackgroundSubtractorMOG2::getVarInit<a class="headerlink" href="#backgroundsubtractormog2-getvarinit" title="Permalink to this headline">¶</a></h2>
<p>Returns the initial variance of each gaussian component</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getVarInit() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getVarInit</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getVarInit() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-setvarinit">
<h2>BackgroundSubtractorMOG2::setVarInit<a class="headerlink" href="#backgroundsubtractormog2-setvarinit" title="Permalink to this headline">¶</a></h2>
<p>Sets the initial variance of each gaussian component</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setVarInit(double varInit)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setVarInit</tt><big>(</big>double <strong>varInit</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setVarInit(double varInit)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getcomplexityreductionthreshold">
<h2>BackgroundSubtractorMOG2::getComplexityReductionThreshold<a class="headerlink" href="#backgroundsubtractormog2-getcomplexityreductionthreshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the complexity reduction threshold</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getComplexityReductionThreshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getComplexityReductionThreshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getComplexityReductionThreshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>This parameter defines the number of samples needed to accept to prove the component exists. <tt class="docutils literal"><span class="pre">CT=0.05</span></tt> is a default value for all the samples. By setting <tt class="docutils literal"><span class="pre">CT=0</span></tt> you get an algorithm very similar to the standard Stauffer&amp;Grimson algorithm.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setcomplexityreductionthreshold">
<h2>BackgroundSubtractorMOG2::setComplexityReductionThreshold<a class="headerlink" href="#backgroundsubtractormog2-setcomplexityreductionthreshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the complexity reduction threshold</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setComplexityReductionThreshold(double ct)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setComplexityReductionThreshold</tt><big>(</big>double <strong>ct</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setComplexityReductionThreshold(double ct)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getdetectshadows">
<h2>BackgroundSubtractorMOG2::getDetectShadows<a class="headerlink" href="#backgroundsubtractormog2-getdetectshadows" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow detection flag</p>
<dl class="function">
<dt id="bool BackgroundSubtractorMOG2::getDetectShadows() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getDetectShadows</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool BackgroundSubtractorMOG2::getDetectShadows() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorMOG2 for details.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setdetectshadows">
<h2>BackgroundSubtractorMOG2::setDetectShadows<a class="headerlink" href="#backgroundsubtractormog2-setdetectshadows" title="Permalink to this headline">¶</a></h2>
<p>Enables or disables shadow detection</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setDetectShadows(bool detectShadows)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setDetectShadows</tt><big>(</big>bool <strong>detectShadows</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setDetectShadows(bool detectShadows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getshadowvalue">
<h2>BackgroundSubtractorMOG2::getShadowValue<a class="headerlink" href="#backgroundsubtractormog2-getshadowvalue" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow value</p>
<dl class="function">
<dt id="int BackgroundSubtractorMOG2::getShadowValue() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getShadowValue</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorMOG2::getShadowValue() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setshadowvalue">
<h2>BackgroundSubtractorMOG2::setShadowValue<a class="headerlink" href="#backgroundsubtractormog2-setshadowvalue" title="Permalink to this headline">¶</a></h2>
<p>Sets the shadow value</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setShadowValue(int value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setShadowValue</tt><big>(</big>int <strong>value</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setShadowValue(int value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractormog2-getshadowthreshold">
<h2>BackgroundSubtractorMOG2::getShadowThreshold<a class="headerlink" href="#backgroundsubtractormog2-getshadowthreshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow threshold</p>
<dl class="function">
<dt id="double BackgroundSubtractorMOG2::getShadowThreshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">getShadowThreshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorMOG2::getShadowThreshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A shadow is detected if pixel is a darker version of the background. The shadow threshold (<tt class="docutils literal"><span class="pre">Tau</span></tt> in the paper) is a threshold defining how much darker the shadow can be. <tt class="docutils literal"><span class="pre">Tau=</span> <span class="pre">0.5</span></tt> means that if a pixel is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiarra, <em>Detecting Moving Shadows...</em>, IEEE PAMI,2003.</p>
</div>
<div class="section" id="backgroundsubtractormog2-setshadowthreshold">
<h2>BackgroundSubtractorMOG2::setShadowThreshold<a class="headerlink" href="#backgroundsubtractormog2-setshadowthreshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the shadow threshold</p>
<dl class="function">
<dt id="void BackgroundSubtractorMOG2::setShadowThreshold(double threshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorMOG2::</tt><tt class="descname">setShadowThreshold</tt><big>(</big>double <strong>threshold</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorMOG2::setShadowThreshold(double threshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn">
<h2>BackgroundSubtractorKNN<a class="headerlink" href="#backgroundsubtractorknn" title="Permalink to this headline">¶</a></h2>
<p>K-nearest neigbours - based Background/Foreground Segmentation Algorithm.</p>
<dl class="class">
<dt id="BackgroundSubtractorKNN : public BackgroundSubtractor">
<em class="property">class </em><tt class="descname">BackgroundSubtractorKNN</tt> : <em class="property">public</em> <tt class="descname">BackgroundSubtractor</tt><a class="headerlink" href="#BackgroundSubtractorKNN : public BackgroundSubtractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class implements the K-nearest neigbours background subtraction described in <a class="reference internal" href="#zivkovic2006" id="id11">[Zivkovic2006]</a> . Very efficient if number of foreground pixels is low.</p>
</div>
<div class="section" id="createbackgroundsubtractorknn">
<h2>createBackgroundSubtractorKNN<a class="headerlink" href="#createbackgroundsubtractorknn" title="Permalink to this headline">¶</a></h2>
<p>Creates KNN Background Subtractor</p>
<dl class="function">
<dt id="Ptr&lt;BackgroundSubtractorKNN&gt; createBackgroundSubtractorKNN(int history, double dist2Threshold, bool detectShadows)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BackgroundSubtractorKNN&gt; <tt class="descname">createBackgroundSubtractorKNN</tt><big>(</big>int <strong>history</strong>=500, double <strong>dist2Threshold</strong>=400.0, bool <strong>detectShadows</strong>=true <big>)</big><a class="headerlink" href="#Ptr&lt;BackgroundSubtractorKNN&gt; createBackgroundSubtractorKNN(int history, double dist2Threshold, bool detectShadows)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>history</strong> – Length of the history.</li>
<li><strong>dist2Threshold</strong> – Threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to that sample. This parameter does not affect the background update.</li>
<li><strong>detectShadows</strong> – If true, the algorithm will detect shadows and mark them. It decreases the speed a bit, so if you do not need this feature, set the parameter to false.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-gethistory">
<h2>BackgroundSubtractorKNN::getHistory<a class="headerlink" href="#backgroundsubtractorknn-gethistory" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of last frames that affect the background model</p>
<dl class="function">
<dt id="int BackgroundSubtractorKNN::getHistory() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getHistory</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorKNN::getHistory() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-sethistory">
<h2>BackgroundSubtractorKNN::setHistory<a class="headerlink" href="#backgroundsubtractorknn-sethistory" title="Permalink to this headline">¶</a></h2>
<p>Sets the number of last frames that affect the background model</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setHistory(int history)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setHistory</tt><big>(</big>int <strong>history</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setHistory(int history)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getnsamples">
<h2>BackgroundSubtractorKNN::getNSamples<a class="headerlink" href="#backgroundsubtractorknn-getnsamples" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of data samples in the background model</p>
<dl class="function">
<dt id="int BackgroundSubtractorKNN::getNSamples() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getNSamples</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorKNN::getNSamples() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-setnsamples">
<h2>BackgroundSubtractorKNN::setNSamples<a class="headerlink" href="#backgroundsubtractorknn-setnsamples" title="Permalink to this headline">¶</a></h2>
<p>Sets the number of data samples in the background model. The model needs to be reinitalized to reserve memory.</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setNSamples(int _nN)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setNSamples</tt><big>(</big>int <strong>_nN</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setNSamples(int _nN)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getdist2threshold">
<h2>BackgroundSubtractorKNN::getDist2Threshold<a class="headerlink" href="#backgroundsubtractorknn-getdist2threshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the threshold on the squared distance between the pixel and the sample</p>
<dl class="function">
<dt id="double BackgroundSubtractorKNN::getDist2Threshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getDist2Threshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorKNN::getDist2Threshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The threshold on the squared distance between the pixel and the sample to decide whether a pixel is close to a data sample.</p>
</div>
<div class="section" id="backgroundsubtractorknn-setdist2threshold">
<h2>BackgroundSubtractorKNN::setDist2Threshold<a class="headerlink" href="#backgroundsubtractorknn-setdist2threshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the threshold on the squared distance</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setDist2Threshold(double _dist2Threshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setDist2Threshold</tt><big>(</big>double <strong>_dist2Threshold</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setDist2Threshold(double _dist2Threshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getknnsamples">
<h2>BackgroundSubtractorKNN::getkNNSamples<a class="headerlink" href="#backgroundsubtractorknn-getknnsamples" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of neighbours, the k in the kNN. K is the number of samples that need to be within dist2Threshold in order to decide that that pixel is matching the kNN background model.</p>
<dl class="function">
<dt id="int BackgroundSubtractorKNN::getkNNSamples() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getkNNSamples</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorKNN::getkNNSamples() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-setknnsamples">
<h2>BackgroundSubtractorKNN::setkNNSamples<a class="headerlink" href="#backgroundsubtractorknn-setknnsamples" title="Permalink to this headline">¶</a></h2>
<p>Sets the k in the kNN. How many nearest neigbours need to match.</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setkNNSamples(int _nkNN)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setkNNSamples</tt><big>(</big>int <strong>_nkNN</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setkNNSamples(int _nkNN)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getdetectshadows">
<h2>BackgroundSubtractorKNN::getDetectShadows<a class="headerlink" href="#backgroundsubtractorknn-getdetectshadows" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow detection flag</p>
<dl class="function">
<dt id="bool BackgroundSubtractorKNN::getDetectShadows() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getDetectShadows</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool BackgroundSubtractorKNN::getDetectShadows() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>If true, the algorithm detects shadows and marks them. See createBackgroundSubtractorKNN for details.</p>
</div>
<div class="section" id="backgroundsubtractorknn-setdetectshadows">
<h2>BackgroundSubtractorKNN::setDetectShadows<a class="headerlink" href="#backgroundsubtractorknn-setdetectshadows" title="Permalink to this headline">¶</a></h2>
<p>Enables or disables shadow detection</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setDetectShadows(bool detectShadows)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setDetectShadows</tt><big>(</big>bool <strong>detectShadows</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setDetectShadows(bool detectShadows)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getshadowvalue">
<h2>BackgroundSubtractorKNN::getShadowValue<a class="headerlink" href="#backgroundsubtractorknn-getshadowvalue" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow value</p>
<dl class="function">
<dt id="int BackgroundSubtractorKNN::getShadowValue() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getShadowValue</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorKNN::getShadowValue() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Shadow value is the value used to mark shadows in the foreground mask. Default value is 127. Value 0 in the mask always means background, 255 means foreground.</p>
</div>
<div class="section" id="backgroundsubtractorknn-setshadowvalue">
<h2>BackgroundSubtractorKNN::setShadowValue<a class="headerlink" href="#backgroundsubtractorknn-setshadowvalue" title="Permalink to this headline">¶</a></h2>
<p>Sets the shadow value</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setShadowValue(int value)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setShadowValue</tt><big>(</big>int <strong>value</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setShadowValue(int value)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorknn-getshadowthreshold">
<h2>BackgroundSubtractorKNN::getShadowThreshold<a class="headerlink" href="#backgroundsubtractorknn-getshadowthreshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the shadow threshold</p>
<dl class="function">
<dt id="double BackgroundSubtractorKNN::getShadowThreshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">getShadowThreshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorKNN::getShadowThreshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>A shadow is detected if pixel is a darker version of the background. The shadow threshold (<tt class="docutils literal"><span class="pre">Tau</span></tt> in the paper) is a threshold defining how much darker the shadow can be. <tt class="docutils literal"><span class="pre">Tau=</span> <span class="pre">0.5</span></tt> means that if a pixel is more than twice darker then it is not shadow. See Prati, Mikic, Trivedi and Cucchiarra, <em>Detecting Moving Shadows...</em>, IEEE PAMI,2003.</p>
</div>
<div class="section" id="backgroundsubtractorknn-setshadowthreshold">
<h2>BackgroundSubtractorKNN::setShadowThreshold<a class="headerlink" href="#backgroundsubtractorknn-setshadowthreshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the shadow threshold</p>
<dl class="function">
<dt id="void BackgroundSubtractorKNN::setShadowThreshold(double threshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorKNN::</tt><tt class="descname">setShadowThreshold</tt><big>(</big>double <strong>threshold</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorKNN::setShadowThreshold(double threshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg">
<h2>BackgroundSubtractorGMG<a class="headerlink" href="#backgroundsubtractorgmg" title="Permalink to this headline">¶</a></h2>
<p>Background Subtractor module based on the algorithm given in <a class="reference internal" href="#gold2012" id="id12">[Gold2012]</a>.</p>
<dl class="class">
<dt id="BackgroundSubtractorGMG : public BackgroundSubtractor">
<em class="property">class </em><tt class="descname">BackgroundSubtractorGMG</tt> : <em class="property">public</em> <tt class="descname">BackgroundSubtractor</tt><a class="headerlink" href="#BackgroundSubtractorGMG : public BackgroundSubtractor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="createbackgroundsubtractorgmg">
<h2>createBackgroundSubtractorGMG<a class="headerlink" href="#createbackgroundsubtractorgmg" title="Permalink to this headline">¶</a></h2>
<p>Creates a GMG Background Subtractor</p>
<dl class="function">
<dt id="Ptr&lt;BackgroundSubtractorGMG&gt; createBackgroundSubtractorGMG(int initializationFrames, double decisionThreshold)">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;BackgroundSubtractorGMG&gt; <tt class="descname">createBackgroundSubtractorGMG</tt><big>(</big>int <strong>initializationFrames</strong>=120, double <strong>decisionThreshold</strong>=0.8<big>)</big><a class="headerlink" href="#Ptr&lt;BackgroundSubtractorGMG&gt; createBackgroundSubtractorGMG(int initializationFrames, double decisionThreshold)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="pyfunction">
<a class="dashAnchor" name="//apple_ref/Function/cv2%2EcreateBackgroundSubtractorGMG"></a><dt id="cv2.createBackgroundSubtractorGMG">
<strong>Python:</strong><tt class="descname"> </tt><tt class="descclassname">cv2.</tt><tt class="descname">createBackgroundSubtractorGMG</tt><big>(</big><span class="optional">[</span>initializationFrames<span class="optional">[</span>, decisionThreshold<span class="optional">]</span><span class="optional">]</span><big>)</big> → retval<a class="headerlink" href="#cv2.createBackgroundSubtractorGMG" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>initializationFrames</strong> – number of frames used to initialize the background models.</li>
<li><strong>decisionThreshold</strong> – Threshold value, above which it is marked foreground, else background.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getnumframes">
<h2>BackgroundSubtractorGMG::getNumFrames<a class="headerlink" href="#backgroundsubtractorgmg-getnumframes" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of frames used to initialize background model.</p>
<dl class="function">
<dt id="int BackgroundSubtractorGMG::getNumFrames() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getNumFrames</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorGMG::getNumFrames() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setnumframes">
<h2>BackgroundSubtractorGMG::setNumFrames<a class="headerlink" href="#backgroundsubtractorgmg-setnumframes" title="Permalink to this headline">¶</a></h2>
<p>Sets the number of frames used to initialize background model.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setNumFrames(int nframes)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setNumFrames</tt><big>(</big>int <strong>nframes</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setNumFrames(int nframes)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getdefaultlearningrate">
<h2>BackgroundSubtractorGMG::getDefaultLearningRate<a class="headerlink" href="#backgroundsubtractorgmg-getdefaultlearningrate" title="Permalink to this headline">¶</a></h2>
<p>Returns the learning rate of the algorithm. It lies between 0.0 and 1.0. It determines how quickly features are “forgotten” from histograms.</p>
<dl class="function">
<dt id="double BackgroundSubtractorGMG::getDefaultLearningRate() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getDefaultLearningRate</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorGMG::getDefaultLearningRate() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setdefaultlearningrate">
<h2>BackgroundSubtractorGMG::setDefaultLearningRate<a class="headerlink" href="#backgroundsubtractorgmg-setdefaultlearningrate" title="Permalink to this headline">¶</a></h2>
<p>Sets the learning rate of the algorithm.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setDefaultLearningRate(double lr)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setDefaultLearningRate</tt><big>(</big>double <strong>lr</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setDefaultLearningRate(double lr)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getdecisionthreshold">
<h2>BackgroundSubtractorGMG::getDecisionThreshold<a class="headerlink" href="#backgroundsubtractorgmg-getdecisionthreshold" title="Permalink to this headline">¶</a></h2>
<p>Returns the value of decision threshold. Decision value is the value above which pixel is determined to be FG.</p>
<dl class="function">
<dt id="double BackgroundSubtractorGMG::getDecisionThreshold() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getDecisionThreshold</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorGMG::getDecisionThreshold() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setdecisionthreshold">
<h2>BackgroundSubtractorGMG::setDecisionThreshold<a class="headerlink" href="#backgroundsubtractorgmg-setdecisionthreshold" title="Permalink to this headline">¶</a></h2>
<p>Sets the value of decision threshold.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setDecisionThreshold(double thresh)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setDecisionThreshold</tt><big>(</big>double <strong>thresh</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setDecisionThreshold(double thresh)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getmaxfeatures">
<h2>BackgroundSubtractorGMG::getMaxFeatures<a class="headerlink" href="#backgroundsubtractorgmg-getmaxfeatures" title="Permalink to this headline">¶</a></h2>
<p>Returns total number of distinct colors to maintain in histogram.</p>
<dl class="function">
<dt id="int BackgroundSubtractorGMG::getMaxFeatures() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getMaxFeatures</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorGMG::getMaxFeatures() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setmaxfeatures">
<h2>BackgroundSubtractorGMG::setMaxFeatures<a class="headerlink" href="#backgroundsubtractorgmg-setmaxfeatures" title="Permalink to this headline">¶</a></h2>
<p>Sets total number of distinct colors to maintain in histogram.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setMaxFeatures(int maxFeatures)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setMaxFeatures</tt><big>(</big>int <strong>maxFeatures</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setMaxFeatures(int maxFeatures)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getquantizationlevels">
<h2>BackgroundSubtractorGMG::getQuantizationLevels<a class="headerlink" href="#backgroundsubtractorgmg-getquantizationlevels" title="Permalink to this headline">¶</a></h2>
<p>Returns the parameter used for quantization of color-space. It is the number of discrete levels in each channel to be used in histograms.</p>
<dl class="function">
<dt id="int BackgroundSubtractorGMG::getQuantizationLevels() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getQuantizationLevels</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorGMG::getQuantizationLevels() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setquantizationlevels">
<h2>BackgroundSubtractorGMG::setQuantizationLevels<a class="headerlink" href="#backgroundsubtractorgmg-setquantizationlevels" title="Permalink to this headline">¶</a></h2>
<p>Sets the parameter used for quantization of color-space</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setQuantizationLevels(int nlevels)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setQuantizationLevels</tt><big>(</big>int <strong>nlevels</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setQuantizationLevels(int nlevels)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getsmoothingradius">
<h2>BackgroundSubtractorGMG::getSmoothingRadius<a class="headerlink" href="#backgroundsubtractorgmg-getsmoothingradius" title="Permalink to this headline">¶</a></h2>
<p>Returns the kernel radius used for morphological operations</p>
<dl class="function">
<dt id="int BackgroundSubtractorGMG::getSmoothingRadius() const">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getSmoothingRadius</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#int BackgroundSubtractorGMG::getSmoothingRadius() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setsmoothingradius">
<h2>BackgroundSubtractorGMG::setSmoothingRadius<a class="headerlink" href="#backgroundsubtractorgmg-setsmoothingradius" title="Permalink to this headline">¶</a></h2>
<p>Sets the kernel radius used for morphological operations</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setSmoothingRadius(int radius)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setSmoothingRadius</tt><big>(</big>int <strong>radius</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setSmoothingRadius(int radius)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getupdatebackgroundmodel">
<h2>BackgroundSubtractorGMG::getUpdateBackgroundModel<a class="headerlink" href="#backgroundsubtractorgmg-getupdatebackgroundmodel" title="Permalink to this headline">¶</a></h2>
<p>Returns the status of background model update</p>
<dl class="function">
<dt id="bool BackgroundSubtractorGMG::getUpdateBackgroundModel() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getUpdateBackgroundModel</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool BackgroundSubtractorGMG::getUpdateBackgroundModel() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setupdatebackgroundmodel">
<h2>BackgroundSubtractorGMG::setUpdateBackgroundModel<a class="headerlink" href="#backgroundsubtractorgmg-setupdatebackgroundmodel" title="Permalink to this headline">¶</a></h2>
<p>Sets the status of background model update</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setUpdateBackgroundModel(bool update)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setUpdateBackgroundModel</tt><big>(</big>bool <strong>update</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setUpdateBackgroundModel(bool update)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getminval">
<h2>BackgroundSubtractorGMG::getMinVal<a class="headerlink" href="#backgroundsubtractorgmg-getminval" title="Permalink to this headline">¶</a></h2>
<p>Returns the minimum value taken on by pixels in image sequence. Usually 0.</p>
<dl class="function">
<dt id="double BackgroundSubtractorGMG::getMinVal() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getMinVal</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorGMG::getMinVal() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setminval">
<h2>BackgroundSubtractorGMG::setMinVal<a class="headerlink" href="#backgroundsubtractorgmg-setminval" title="Permalink to this headline">¶</a></h2>
<p>Sets the minimum value taken on by pixels in image sequence.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setMinVal(double val)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setMinVal</tt><big>(</big>double <strong>val</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setMinVal(double val)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getmaxval">
<h2>BackgroundSubtractorGMG::getMaxVal<a class="headerlink" href="#backgroundsubtractorgmg-getmaxval" title="Permalink to this headline">¶</a></h2>
<p>Returns the maximum value taken on by pixels in image sequence. e.g. 1.0 or 255.</p>
<dl class="function">
<dt id="double BackgroundSubtractorGMG::getMaxVal() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getMaxVal</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorGMG::getMaxVal() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setmaxval">
<h2>BackgroundSubtractorGMG::setMaxVal<a class="headerlink" href="#backgroundsubtractorgmg-setmaxval" title="Permalink to this headline">¶</a></h2>
<p>Sets the maximum value taken on by pixels in image sequence.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setMaxVal(double val)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setMaxVal</tt><big>(</big>double <strong>val</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setMaxVal(double val)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-getbackgroundprior">
<h2>BackgroundSubtractorGMG::getBackgroundPrior<a class="headerlink" href="#backgroundsubtractorgmg-getbackgroundprior" title="Permalink to this headline">¶</a></h2>
<p>Returns the prior probability that each individual pixel is a background pixel.</p>
<dl class="function">
<dt id="double BackgroundSubtractorGMG::getBackgroundPrior() const">
<strong>C++:</strong><tt class="descname"> </tt>double <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">getBackgroundPrior</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#double BackgroundSubtractorGMG::getBackgroundPrior() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="backgroundsubtractorgmg-setbackgroundprior">
<h2>BackgroundSubtractorGMG::setBackgroundPrior<a class="headerlink" href="#backgroundsubtractorgmg-setbackgroundprior" title="Permalink to this headline">¶</a></h2>
<p>Sets the prior probability that each individual pixel is a background pixel.</p>
<dl class="function">
<dt id="void BackgroundSubtractorGMG::setBackgroundPrior(double bgprior)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">BackgroundSubtractorGMG::</tt><tt class="descname">setBackgroundPrior</tt><big>(</big>double <strong>bgprior</strong><big>)</big><a class="headerlink" href="#void BackgroundSubtractorGMG::setBackgroundPrior(double bgprior)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="createoptflow-dualtvl1">
<h2>createOptFlow_DualTVL1<a class="headerlink" href="#createoptflow-dualtvl1" title="Permalink to this headline">¶</a></h2>
<p>“Dual TV L1” Optical Flow Algorithm.</p>
<dl class="function">
<dt id="Ptr&lt;DenseOpticalFlow&gt; createOptFlow_DualTVL1()">
<strong>C++:</strong><tt class="descname"> </tt>Ptr&lt;DenseOpticalFlow&gt; <tt class="descname">createOptFlow_DualTVL1</tt><big>(</big><big>)</big><a class="headerlink" href="#Ptr&lt;DenseOpticalFlow&gt; createOptFlow_DualTVL1()" title="Permalink to this definition">¶</a></dt>
<dd><p>The class implements the “Dual TV L1” optical flow algorithm described in <a class="reference internal" href="#zach2007" id="id13">[Zach2007]</a> and <a class="reference internal" href="#javier2012" id="id14">[Javier2012]</a> .</p>
<p>Here are important members of the class that control the algorithm, which you can set after constructing the class instance:</p>
<blockquote>
<div><dl class="member">
<dt id="double tau">
double <tt class="descname">tau</tt><a class="headerlink" href="#double tau" title="Permalink to this definition">¶</a></dt>
<dd><p>Time step of the numerical scheme.</p>
</dd></dl>

<dl class="member">
<dt id="double lambda">
double <tt class="descname">lambda</tt><a class="headerlink" href="#double lambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight parameter for the data term, attachment parameter. This is the most relevant parameter, which determines the smoothness of the output. The smaller this parameter is, the smoother the solutions we obtain. It depends on the range of motions of the images, so its value should be adapted to each image sequence.</p>
</dd></dl>

<dl class="member">
<dt id="double theta">
double <tt class="descname">theta</tt><a class="headerlink" href="#double theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight parameter for (u - v)^2, tightness parameter. It serves as a link between the attachment and the regularization terms. In theory, it should have a small value in order to maintain both parts in correspondence. The method is stable for a large range of values of this parameter.</p>
</dd></dl>

<dl class="member">
<dt id="int nscales">
int <tt class="descname">nscales</tt><a class="headerlink" href="#int nscales" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of scales used to create the pyramid of images.</p>
</dd></dl>

<dl class="member">
<dt id="int warps">
int <tt class="descname">warps</tt><a class="headerlink" href="#int warps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of warpings per scale. Represents the number of times that I1(x+u0) and grad( I1(x+u0) ) are computed per scale. This is a parameter that assures the stability of the method. It also affects the running time, so it is a compromise between speed and accuracy.</p>
</dd></dl>

<dl class="member">
<dt id="double epsilon">
double <tt class="descname">epsilon</tt><a class="headerlink" href="#double epsilon" title="Permalink to this definition">¶</a></dt>
<dd><p>Stopping criterion threshold used in the numerical scheme, which is a trade-off between precision and running time. A small value will yield more accurate solutions at the expense of a slower convergence.</p>
</dd></dl>

<dl class="member">
<dt id="int iterations">
int <tt class="descname">iterations</tt><a class="headerlink" href="#int iterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Stopping criterion iterations number used in the numerical scheme.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

</div>
<div class="section" id="denseopticalflow-calc">
<h2>DenseOpticalFlow::calc<a class="headerlink" href="#denseopticalflow-calc" title="Permalink to this headline">¶</a></h2>
<p>Calculates an optical flow.</p>
<dl class="function">
<dt id="void DenseOpticalFlow::calc(InputArray I0, InputArray I1, InputOutputArray flow)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">DenseOpticalFlow::</tt><tt class="descname">calc</tt><big>(</big>InputArray <strong>I0</strong>, InputArray <strong>I1</strong>, InputOutputArray <strong>flow</strong><big>)</big><a class="headerlink" href="#void DenseOpticalFlow::calc(InputArray I0, InputArray I1, InputOutputArray flow)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<colgroup><col class="field-name">
<col class="field-body">
</colgroup><tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>I0</strong> – first 8-bit single-channel input image.</li>
<li><strong>I1</strong> – second input image of the same size and the same type as <tt class="docutils literal"><span class="pre">I0</span></tt> .</li>
<li><strong>flow</strong> – computed flow image that has the same size as <tt class="docutils literal"><span class="pre">I0</span></tt> and type <tt class="docutils literal"><span class="pre">CV_32FC2</span></tt> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="denseopticalflow-collectgarbage">
<h2>DenseOpticalFlow::collectGarbage<a class="headerlink" href="#denseopticalflow-collectgarbage" title="Permalink to this headline">¶</a></h2>
<p>Releases all inner buffers.</p>
<dl class="function">
<dt id="void DenseOpticalFlow::collectGarbage()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">DenseOpticalFlow::</tt><tt class="descname">collectGarbage</tt><big>(</big><big>)</big><a class="headerlink" href="#void DenseOpticalFlow::collectGarbage()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<table class="docutils citation" frame="void" id="bouguet00" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label">[Bouguet00]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Jean-Yves Bouguet. Pyramidal Implementation of the Lucas Kanade Feature Tracker.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bradski98" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Bradski98]</a></td><td>Bradski, G.R. “Computer Vision Face Tracking for Use in a Perceptual User Interface”, Intel, 1998</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="ep08" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label">[EP08]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Evangelidis, G.D. and Psarakis E.Z. “Parametric Image Alignment using Enhanced Correlation Coefficient Maximization”, IEEE Transactions on PAMI, vol. 32, no. 10, 2008</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="farneback2003" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Farneback2003]</a></td><td>Gunnar Farneback, Two-frame motion estimation based on polynomial expansion, Lecture Notes in Computer Science, 2003, (2749), , 363-370.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="horn81" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label">[Horn81]</td><td>Berthold K.P. Horn and Brian G. Schunck. Determining Optical Flow. Artificial Intelligence, 17, pp. 185-203, 1981.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="kb2001" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[KB2001]</a></td><td><ol class="first last upperalpha simple" start="16">
<li>KadewTraKuPong and R. Bowden. “An improved adaptive background mixture model for real-time tracking with shadow detection”, Proc. 2nd European Workshop on Advanced Video-Based Surveillance Systems, 2001: <a class="reference external" href="http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf">http://personal.ee.surrey.ac.uk/Personal/R.Bowden/publications/avbs01/avbs01.pdf</a></li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="javier2012" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[Javier2012]</a></td><td>Javier Sanchez, Enric Meinhardt-Llopis and Gabriele Facciolo. “TV-L1 Optical Flow Estimation”.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lucas81" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label">[Lucas81]</td><td>Lucas, B., and Kanade, T. An Iterative Image Registration Technique with an Application to Stereo Vision, Proc. of 7th International Joint Conference on Artificial Intelligence (IJCAI), pp. 674-679.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="welch95" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[Welch95]</a></td><td>Greg Welch and Gary Bishop “An Introduction to the Kalman Filter”, 1995</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zach2007" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[Zach2007]</a></td><td><ol class="first last upperalpha simple" start="3">
<li>Zach, T. Pock and H. Bischof. “A Duality Based Approach for Realtime TV-L1 Optical Flow”, In Proceedings of Pattern Recognition (DAGM), Heidelberg, Germany, pp. 214-223, 2007</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zivkovic2004" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[Zivkovic2004]</a></td><td><ol class="first last upperalpha simple" start="26">
<li>Zivkovic. “Improved adaptive Gausian mixture model for background subtraction”, International Conference Pattern Recognition, UK, August, 2004, <a class="reference external" href="http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf">http://www.zoranz.net/Publications/zivkovic2004ICPR.pdf</a>. The code is very fast and performs also shadow detection. Number of Gausssian components is adapted per pixel.</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="zivkovic2006" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label">[Zivkovic2006]</td><td><em>(<a class="fn-backref" href="#id10">1</a>, <a class="fn-backref" href="#id11">2</a>)</em> Z.Zivkovic, F. van der Heijden. “Efficient Adaptive Density Estimation per Image Pixel for the Task of Background Subtraction”, Pattern Recognition Letters, vol. 27, no. 7, pages 773-780, 2006.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gold2012" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[Gold2012]</a></td><td>Andrew B. Godbehere, Akihiro Matsukawa, Ken Goldberg, “Visual Tracking of Human Visitors under Variable-Lighting Conditions for a Responsive Audio Art Installation”, American Control Conference, Montreal, June 2012.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&amp;A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="../../calib3d/doc/calib3d.html" title="calib3d. Camera Calibration and 3D Reconstruction">next</a> |</li>
        <li class="right">
          <a href="video.html" title="video. Video Analysis">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> »</li>
          <li><a href="../../refman.html">OpenCV API Reference</a> »</li>
          <li><a href="video.html">video. Video Analysis</a> »</li> 
      </ul>
    </div>
    <div class="footer">
        © Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
      <a href="../../../_sources/modules/video/doc/motion_analysis_and_object_tracking.txt" rel="nofollow">Show this page source.</a>
    </div>
  

<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/video/doc/motion_analysis_and_object_tracking.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:27 GMT -->
</body></html>