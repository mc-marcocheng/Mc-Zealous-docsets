<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/cuda/doc/object_detection.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:51 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Object Detection</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="../../../index.html" />
    <link rel="up" title="cuda. CUDA-accelerated Computer Vision" href="cuda.html" />
    <link rel="next" title="Camera Calibration and 3D Reconstruction" href="calib3d.html" />
    <link rel="prev" title="Data Structures" href="data_structures.html" />
    <link href='../../../../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="calib3d.html" title="Camera Calibration and 3D Reconstruction"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="data_structures.html" title="Data Structures"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="cuda.html" accesskey="U">cuda. CUDA-accelerated Computer Vision</a> &raquo;</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/opencv-logo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Object Detection</a><ul>
<li><a class="reference internal" href="#cuda-hogdescriptor">cuda::HOGDescriptor</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-hogdescriptor">cuda::HOGDescriptor::HOGDescriptor</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getdescriptorsize">cuda::HOGDescriptor::getDescriptorSize</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getblockhistogramsize">cuda::HOGDescriptor::getBlockHistogramSize</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-setsvmdetector">cuda::HOGDescriptor::setSVMDetector</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getdefaultpeopledetector">cuda::HOGDescriptor::getDefaultPeopleDetector</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getpeopledetector48x96">cuda::HOGDescriptor::getPeopleDetector48x96</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getpeopledetector64x128">cuda::HOGDescriptor::getPeopleDetector64x128</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-detect">cuda::HOGDescriptor::detect</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-detectmultiscale">cuda::HOGDescriptor::detectMultiScale</a></li>
<li><a class="reference internal" href="#cuda-hogdescriptor-getdescriptors">cuda::HOGDescriptor::getDescriptors</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda">cuda::CascadeClassifier_CUDA</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda-cascadeclassifier-cuda">cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda-empty">cuda::CascadeClassifier_CUDA::empty</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda-load">cuda::CascadeClassifier_CUDA::load</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda-release">cuda::CascadeClassifier_CUDA::release</a></li>
<li><a class="reference internal" href="#cuda-cascadeclassifier-cuda-detectmultiscale">cuda::CascadeClassifier_CUDA::detectMultiScale</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="data_structures.html"
                        title="previous chapter">Data Structures</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="calib3d.html"
                        title="next chapter">Camera Calibration and 3D Reconstruction</a></p>
        </div>
      </div>
  <body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="object-detection">
<h1>Object Detection<a class="headerlink" href="#object-detection" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cuda-hogdescriptor">
<h2>cuda::HOGDescriptor<a class="headerlink" href="#cuda-hogdescriptor" title="Permalink to this headline">¶</a></h2>
<dl class="struct">
<dt id="cuda::HOGDescriptor">
<em class="property">struct </em><tt class="descclassname">cuda::</tt><tt class="descname">HOGDescriptor</tt><a class="headerlink" href="#cuda::HOGDescriptor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The class implements Histogram of Oriented Gradients (<a class="reference internal" href="#dalal2005" id="id1">[Dalal2005]</a>) object detector.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">struct</span> <span class="n">CV_EXPORTS</span> <span class="n">HOGDescriptor</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_WIN_SIGMA</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DEFAULT_NLEVELS</span> <span class="o">=</span> <span class="mi">64</span> <span class="p">};</span>
    <span class="k">enum</span> <span class="p">{</span> <span class="n">DESCR_FORMAT_ROW_BY_ROW</span><span class="p">,</span> <span class="n">DESCR_FORMAT_COL_BY_COL</span> <span class="p">};</span>

    <span class="n">HOGDescriptor</span><span class="p">(</span><span class="n">Size</span> <span class="n">win_size</span><span class="o">=</span><span class="n">Size</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span> <span class="n">Size</span> <span class="n">block_size</span><span class="o">=</span><span class="n">Size</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
                  <span class="n">Size</span> <span class="n">block_stride</span><span class="o">=</span><span class="n">Size</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Size</span> <span class="n">cell_size</span><span class="o">=</span><span class="n">Size</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                  <span class="kt">int</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="kt">double</span> <span class="n">win_sigma</span><span class="o">=</span><span class="n">DEFAULT_WIN_SIGMA</span><span class="p">,</span>
                  <span class="kt">double</span> <span class="n">threshold_L2hys</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">gamma_correction</span><span class="o">=</span><span class="nb">true</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">nlevels</span><span class="o">=</span><span class="n">DEFAULT_NLEVELS</span><span class="p">);</span>

    <span class="kt">size_t</span> <span class="n">getDescriptorSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">getBlockHistogramSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">setSVMDetector</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">detector</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">getDefaultPeopleDetector</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">getPeopleDetector48x96</span><span class="p">();</span>
    <span class="k">static</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">getPeopleDetector64x128</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">detect</span><span class="p">(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">found_locations</span><span class="p">,</span>
                <span class="kt">double</span> <span class="n">hit_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Size</span> <span class="n">win_stride</span><span class="o">=</span><span class="n">Size</span><span class="p">(),</span>
                <span class="n">Size</span> <span class="n">padding</span><span class="o">=</span><span class="n">Size</span><span class="p">());</span>

    <span class="kt">void</span> <span class="nf">detectMultiScale</span><span class="p">(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Rect</span><span class="o">&gt;&amp;</span> <span class="n">found_locations</span><span class="p">,</span>
                          <span class="kt">double</span> <span class="n">hit_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Size</span> <span class="n">win_stride</span><span class="o">=</span><span class="n">Size</span><span class="p">(),</span>
                          <span class="n">Size</span> <span class="n">padding</span><span class="o">=</span><span class="n">Size</span><span class="p">(),</span> <span class="kt">double</span> <span class="n">scale0</span><span class="o">=</span><span class="mf">1.05</span><span class="p">,</span>
                          <span class="kt">int</span> <span class="n">group_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">getDescriptors</span><span class="p">(</span><span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">img</span><span class="p">,</span> <span class="n">Size</span> <span class="n">win_stride</span><span class="p">,</span>
                        <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">descriptors</span><span class="p">,</span>
                        <span class="kt">int</span> <span class="n">descr_format</span><span class="o">=</span><span class="n">DESCR_FORMAT_COL_BY_COL</span><span class="p">);</span>

    <span class="n">Size</span> <span class="n">win_size</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">block_size</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">block_stride</span><span class="p">;</span>
    <span class="n">Size</span> <span class="n">cell_size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nbins</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">win_sigma</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">threshold_L2hys</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">gamma_correction</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nlevels</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">// Hidden</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Interfaces of all methods are kept similar to the <tt class="docutils literal"><span class="pre">CPU</span> <span class="pre">HOG</span></tt> descriptor and detector analogues as much as possible.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>An example applying the HOG descriptor for people detection can be found at opencv_source_code/samples/cpp/peopledetect.cpp</li>
<li>A CUDA example applying the HOG descriptor for people detection can be found at opencv_source_code/samples/gpu/hog.cpp</li>
<li>(Python) An example applying the HOG descriptor for people detection can be found at opencv_source_code/samples/python2/peopledetect.py</li>
</ul>
</div>
</div>
<div class="section" id="cuda-hogdescriptor-hogdescriptor">
<h2>cuda::HOGDescriptor::HOGDescriptor<a class="headerlink" href="#cuda-hogdescriptor-hogdescriptor" title="Permalink to this headline">¶</a></h2>
<p>Creates the <tt class="docutils literal"><span class="pre">HOG</span></tt> descriptor and detector.</p>
<dl class="function">
<dt id="cuda::HOGDescriptor::HOGDescriptor(Size win_size, Size block_size, Size block_stride, Size cell_size, int nbins, double win_sigma, double threshold_L2hys, bool gamma_correction, int nlevels)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">HOGDescriptor</tt><big>(</big>Size <strong>win_size</strong>=Size(64, 128), Size <strong>block_size</strong>=Size(16, 16), Size <strong>block_stride</strong>=Size(8, 8), Size <strong>cell_size</strong>=Size(8, 8), int <strong>nbins</strong>=9, double <strong>win_sigma</strong>=DEFAULT_WIN_SIGMA, double <strong>threshold_L2hys</strong>=0.2, bool <strong>gamma_correction</strong>=true, int <strong>nlevels</strong>=DEFAULT_NLEVELS<big>)</big><a class="headerlink" href="#cuda::HOGDescriptor::HOGDescriptor(Size win_size, Size block_size, Size block_stride, Size cell_size, int nbins, double win_sigma, double threshold_L2hys, bool gamma_correction, int nlevels)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>win_size</strong> &#8211; Detection window size. Align to block size and block stride.</li>
<li><strong>block_size</strong> &#8211; Block size in pixels. Align to cell size. Only (16,16) is supported for now.</li>
<li><strong>block_stride</strong> &#8211; Block stride. It must be a multiple of cell size.</li>
<li><strong>cell_size</strong> &#8211; Cell size. Only (8, 8) is supported for now.</li>
<li><strong>nbins</strong> &#8211; Number of bins. Only 9 bins per cell are supported for now.</li>
<li><strong>win_sigma</strong> &#8211; Gaussian smoothing window parameter.</li>
<li><strong>threshold_L2hys</strong> &#8211; L2-Hys normalization method shrinkage.</li>
<li><strong>gamma_correction</strong> &#8211; Flag to specify whether the gamma correction preprocessing is required or not.</li>
<li><strong>nlevels</strong> &#8211; Maximum number of detection window increases.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getdescriptorsize">
<h2>cuda::HOGDescriptor::getDescriptorSize<a class="headerlink" href="#cuda-hogdescriptor-getdescriptorsize" title="Permalink to this headline">¶</a></h2>
<p>Returns the number of coefficients required for the classification.</p>
<dl class="function">
<dt id="size_t cuda::HOGDescriptor::getDescriptorSize() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getDescriptorSize</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t cuda::HOGDescriptor::getDescriptorSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getblockhistogramsize">
<h2>cuda::HOGDescriptor::getBlockHistogramSize<a class="headerlink" href="#cuda-hogdescriptor-getblockhistogramsize" title="Permalink to this headline">¶</a></h2>
<p>Returns the block histogram size.</p>
<dl class="function">
<dt id="size_t cuda::HOGDescriptor::getBlockHistogramSize() const">
<strong>C++:</strong><tt class="descname"> </tt>size_t <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getBlockHistogramSize</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#size_t cuda::HOGDescriptor::getBlockHistogramSize() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-setsvmdetector">
<h2>cuda::HOGDescriptor::setSVMDetector<a class="headerlink" href="#cuda-hogdescriptor-setsvmdetector" title="Permalink to this headline">¶</a></h2>
<p>Sets coefficients for the linear SVM classifier.</p>
<dl class="function">
<dt id="void cuda::HOGDescriptor::setSVMDetector(const vector&lt;float&gt;&amp; detector)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">setSVMDetector</tt><big>(</big>const vector&lt;float&gt;&amp; <strong>detector</strong><big>)</big><a class="headerlink" href="#void cuda::HOGDescriptor::setSVMDetector(const vector<float>& detector)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getdefaultpeopledetector">
<h2>cuda::HOGDescriptor::getDefaultPeopleDetector<a class="headerlink" href="#cuda-hogdescriptor-getdefaultpeopledetector" title="Permalink to this headline">¶</a></h2>
<p>Returns coefficients of the classifier trained for people detection (for default window size).</p>
<dl class="function">
<dt id="static vector&lt;float&gt; cuda::HOGDescriptor::getDefaultPeopleDetector()">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> vector&lt;float&gt; <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getDefaultPeopleDetector</tt><big>(</big><big>)</big><a class="headerlink" href="#static vector<float> cuda::HOGDescriptor::getDefaultPeopleDetector()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getpeopledetector48x96">
<h2>cuda::HOGDescriptor::getPeopleDetector48x96<a class="headerlink" href="#cuda-hogdescriptor-getpeopledetector48x96" title="Permalink to this headline">¶</a></h2>
<p>Returns coefficients of the classifier trained for people detection (for 48x96 windows).</p>
<dl class="function">
<dt id="static vector&lt;float&gt; cuda::HOGDescriptor::getPeopleDetector48x96()">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> vector&lt;float&gt; <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getPeopleDetector48x96</tt><big>(</big><big>)</big><a class="headerlink" href="#static vector<float> cuda::HOGDescriptor::getPeopleDetector48x96()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getpeopledetector64x128">
<h2>cuda::HOGDescriptor::getPeopleDetector64x128<a class="headerlink" href="#cuda-hogdescriptor-getpeopledetector64x128" title="Permalink to this headline">¶</a></h2>
<p>Returns coefficients of the classifier trained for people detection (for 64x128 windows).</p>
<dl class="function">
<dt id="static vector&lt;float&gt; cuda::HOGDescriptor::getPeopleDetector64x128()">
<strong>C++:</strong><tt class="descname"> </tt><em class="property">static</em> vector&lt;float&gt; <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getPeopleDetector64x128</tt><big>(</big><big>)</big><a class="headerlink" href="#static vector<float> cuda::HOGDescriptor::getPeopleDetector64x128()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-detect">
<h2>cuda::HOGDescriptor::detect<a class="headerlink" href="#cuda-hogdescriptor-detect" title="Permalink to this headline">¶</a></h2>
<p>Performs object detection without a multi-scale window.</p>
<dl class="function">
<dt id="void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">detect</tt><big>(</big>const GpuMat&amp; <strong>img</strong>, vector&lt;Point&gt;&amp; <strong>found_locations</strong>, double <strong>hit_threshold</strong>=0, Size <strong>win_stride</strong>=Size(), Size <strong>padding</strong>=Size()<big>)</big><a class="headerlink" href="#void cuda::HOGDescriptor::detect(const GpuMat& img, vector<Point>& found_locations, double hit_threshold, Size win_stride, Size padding)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; Source image.  <tt class="docutils literal"><span class="pre">CV_8UC1</span></tt>  and  <tt class="docutils literal"><span class="pre">CV_8UC4</span></tt> types are supported for now.</li>
<li><strong>found_locations</strong> &#8211; Left-top corner points of detected objects boundaries.</li>
<li><strong>hit_threshold</strong> &#8211; Threshold for the distance between features and SVM classifying plane. Usually it is 0 and should be specfied in the detector coefficients (as the last free coefficient). But if the free coefficient is omitted (which is allowed), you can specify it manually here.</li>
<li><strong>win_stride</strong> &#8211; Window stride. It must be a multiple of block stride.</li>
<li><strong>padding</strong> &#8211; Mock parameter to keep the CPU interface compatibility. It must be (0,0).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-detectmultiscale">
<h2>cuda::HOGDescriptor::detectMultiScale<a class="headerlink" href="#cuda-hogdescriptor-detectmultiscale" title="Permalink to this headline">¶</a></h2>
<p>Performs object detection with a multi-scale window.</p>
<dl class="function">
<dt id="void cuda::HOGDescriptor::detectMultiScale(const GpuMat&amp; img, vector&lt;Rect&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding, double scale0, int group_threshold)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">detectMultiScale</tt><big>(</big>const GpuMat&amp; <strong>img</strong>, vector&lt;Rect&gt;&amp; <strong>found_locations</strong>, double <strong>hit_threshold</strong>=0, Size <strong>win_stride</strong>=Size(), Size <strong>padding</strong>=Size(), double <strong>scale0</strong>=1.05, int <strong>group_threshold</strong>=2<big>)</big><a class="headerlink" href="#void cuda::HOGDescriptor::detectMultiScale(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold, Size win_stride, Size padding, double scale0, int group_threshold)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; Source image. See  <a class="reference internal" href="#void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)" title="void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cuda::HOGDescriptor::detect()</span></tt></a>  for type limitations.</li>
<li><strong>found_locations</strong> &#8211; Detected objects boundaries.</li>
<li><strong>hit_threshold</strong> &#8211; Threshold for the distance between features and SVM classifying plane. See  <a class="reference internal" href="#void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)" title="void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cuda::HOGDescriptor::detect()</span></tt></a>  for details.</li>
<li><strong>win_stride</strong> &#8211; Window stride. It must be a multiple of block stride.</li>
<li><strong>padding</strong> &#8211; Mock parameter to keep the CPU interface compatibility. It must be (0,0).</li>
<li><strong>scale0</strong> &#8211; Coefficient of the detection window increase.</li>
<li><strong>group_threshold</strong> &#8211; Coefficient to regulate the similarity threshold. When detected, some objects can be covered by many rectangles. 0 means not to perform grouping. See  <a class="reference internal" href="../../objdetect/doc/cascade_classification.html#void groupRectangles(vector&lt;Rect&gt;&amp; rectList, int groupThreshold, double eps)" title="void groupRectangles(vector&lt;Rect&gt;&amp; rectList, int groupThreshold, double eps)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">groupRectangles()</span></tt></a> .</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cuda-hogdescriptor-getdescriptors">
<h2>cuda::HOGDescriptor::getDescriptors<a class="headerlink" href="#cuda-hogdescriptor-getdescriptors" title="Permalink to this headline">¶</a></h2>
<p>Returns block descriptors computed for the whole image.</p>
<dl class="function">
<dt id="void cuda::HOGDescriptor::getDescriptors(const GpuMat&amp; img, Size win_stride, GpuMat&amp; descriptors, int descr_format)">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">cuda::HOGDescriptor::</tt><tt class="descname">getDescriptors</tt><big>(</big>const GpuMat&amp; <strong>img</strong>, Size <strong>win_stride</strong>, GpuMat&amp; <strong>descriptors</strong>, int <strong>descr_format</strong>=DESCR_FORMAT_COL_BY_COL<big>)</big><a class="headerlink" href="#void cuda::HOGDescriptor::getDescriptors(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>img</strong> &#8211; Source image. See  <a class="reference internal" href="#void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)" title="void cuda::HOGDescriptor::detect(const GpuMat&amp; img, vector&lt;Point&gt;&amp; found_locations, double hit_threshold, Size win_stride, Size padding)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">cuda::HOGDescriptor::detect()</span></tt></a>  for type limitations.</li>
<li><strong>win_stride</strong> &#8211; Window stride. It must be a multiple of block stride.</li>
<li><strong>descriptors</strong> &#8211; 2D array of descriptors.</li>
<li><strong>descr_format</strong> &#8211; <p>Descriptor storage format:</p>
<ul>
<li><strong>DESCR_FORMAT_ROW_BY_ROW</strong> - Row-major order.</li>
<li><strong>DESCR_FORMAT_COL_BY_COL</strong> - Column-major order.</li>
</ul>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The function is mainly used to learn the classifier.</p>
</div>
<div class="section" id="cuda-cascadeclassifier-cuda">
<h2>cuda::CascadeClassifier_CUDA<a class="headerlink" href="#cuda-cascadeclassifier-cuda" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="cuda::CascadeClassifier_CUDA">
<em class="property">class </em><tt class="descclassname">cuda::</tt><tt class="descname">CascadeClassifier_CUDA</tt><a class="headerlink" href="#cuda::CascadeClassifier_CUDA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>Cascade classifier class used for object detection. Supports HAAR and LBP cascades.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">CV_EXPORTS</span> <span class="n">CascadeClassifier_CUDA</span>
<span class="p">{</span>
<span class="nl">public:</span>
        <span class="n">CascadeClassifier_CUDA</span><span class="p">();</span>
        <span class="n">CascadeClassifier_CUDA</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
        <span class="o">~</span><span class="n">CascadeClassifier_CUDA</span><span class="p">();</span>

        <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nf">load</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">filename</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">release</span><span class="p">();</span>

        <span class="cm">/* Returns number of detected objects */</span>
        <span class="kt">int</span> <span class="nf">detectMultiScale</span><span class="p">(</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">objectsBuf</span><span class="p">,</span> <span class="kt">double</span> <span class="n">scaleFactor</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minNeighbors</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">Size</span> <span class="n">minSize</span><span class="o">=</span><span class="n">Size</span><span class="p">());</span>
        <span class="kt">int</span> <span class="nf">detectMultiScale</span><span class="p">(</span> <span class="k">const</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">image</span><span class="p">,</span> <span class="n">GpuMat</span><span class="o">&amp;</span> <span class="n">objectsBuf</span><span class="p">,</span> <span class="n">Size</span> <span class="n">maxObjectSize</span><span class="p">,</span> <span class="n">Size</span> <span class="n">minSize</span> <span class="o">=</span> <span class="n">Size</span><span class="p">(),</span> <span class="kt">double</span> <span class="n">scaleFactor</span> <span class="o">=</span> <span class="mf">1.1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minNeighbors</span> <span class="o">=</span> <span class="mi">4</span><span class="p">);</span>

        <span class="cm">/* Finds only the largest object. Special mode if training is required.*/</span>
        <span class="kt">bool</span> <span class="n">findLargestObject</span><span class="p">;</span>

        <span class="cm">/* Draws rectangles in input image */</span>
        <span class="kt">bool</span> <span class="n">visualizeInPlace</span><span class="p">;</span>

        <span class="n">Size</span> <span class="n">getClassifierSize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>A cascade classifier example can be found at opencv_source_code/samples/gpu/cascadeclassifier.cpp</li>
<li>A Nvidea API specific cascade classifier example can be found at opencv_source_code/samples/gpu/cascadeclassifier_nvidia_api.cpp</li>
</ul>
</div>
</div>
<div class="section" id="cuda-cascadeclassifier-cuda-cascadeclassifier-cuda">
<h2>cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA<a class="headerlink" href="#cuda-cascadeclassifier-cuda-cascadeclassifier-cuda" title="Permalink to this headline">¶</a></h2>
<p>Loads the classifier from a file. Cascade type is detected automatically by constructor parameter.</p>
<dl class="function">
<dt id="cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA(const String&amp; filename)">
<strong>C++:</strong><tt class="descname"> </tt> <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">CascadeClassifier_CUDA</tt><big>(</big>const String&amp; <strong>filename</strong><big>)</big><a class="headerlink" href="#cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA(const String& filename)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; Name of the file from which the classifier is loaded. Only the old <tt class="docutils literal"><span class="pre">haar</span></tt> classifier (trained by the <tt class="docutils literal"><span class="pre">haar</span></tt> training application) and NVIDIA&#8217;s <tt class="docutils literal"><span class="pre">nvbin</span></tt> are supported for HAAR and only new type of OpenCV XML cascade supported for LBP.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cuda-cascadeclassifier-cuda-empty">
<h2>cuda::CascadeClassifier_CUDA::empty<a class="headerlink" href="#cuda-cascadeclassifier-cuda-empty" title="Permalink to this headline">¶</a></h2>
<p>Checks whether the classifier is loaded or not.</p>
<dl class="function">
<dt id="bool cuda::CascadeClassifier_CUDA::empty() const">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">empty</tt><big>(</big><big>)</big><tt class="descclassname"> const</tt><a class="headerlink" href="#bool cuda::CascadeClassifier_CUDA::empty() const" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-cascadeclassifier-cuda-load">
<h2>cuda::CascadeClassifier_CUDA::load<a class="headerlink" href="#cuda-cascadeclassifier-cuda-load" title="Permalink to this headline">¶</a></h2>
<p>Loads the classifier from a file. The previous content is destroyed.</p>
<dl class="function">
<dt id="bool cuda::CascadeClassifier_CUDA::load(const String&amp; filename)">
<strong>C++:</strong><tt class="descname"> </tt>bool <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">load</tt><big>(</big>const String&amp; <strong>filename</strong><big>)</big><a class="headerlink" href="#bool cuda::CascadeClassifier_CUDA::load(const String& filename)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filename</strong> &#8211; Name of the file from which the classifier is loaded. Only the old <tt class="docutils literal"><span class="pre">haar</span></tt> classifier (trained by the <tt class="docutils literal"><span class="pre">haar</span></tt> training application) and NVIDIA&#8217;s <tt class="docutils literal"><span class="pre">nvbin</span></tt> are supported for HAAR and only new type of OpenCV XML cascade supported for LBP.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cuda-cascadeclassifier-cuda-release">
<h2>cuda::CascadeClassifier_CUDA::release<a class="headerlink" href="#cuda-cascadeclassifier-cuda-release" title="Permalink to this headline">¶</a></h2>
<p>Destroys the loaded classifier.</p>
<dl class="function">
<dt id="void cuda::CascadeClassifier_CUDA::release()">
<strong>C++:</strong><tt class="descname"> </tt>void <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">release</tt><big>(</big><big>)</big><a class="headerlink" href="#void cuda::CascadeClassifier_CUDA::release()" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="cuda-cascadeclassifier-cuda-detectmultiscale">
<h2>cuda::CascadeClassifier_CUDA::detectMultiScale<a class="headerlink" href="#cuda-cascadeclassifier-cuda-detectmultiscale" title="Permalink to this headline">¶</a></h2>
<p>Detects objects of different sizes in the input image.</p>
<dl class="function">
<dt id="int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat&amp; image, GpuMat&amp; objectsBuf, double scaleFactor, int minNeighbors, Size minSize)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">detectMultiScale</tt><big>(</big>const GpuMat&amp; <strong>image</strong>, GpuMat&amp; <strong>objectsBuf</strong>, double <strong>scaleFactor</strong>=1.2, int <strong>minNeighbors</strong>=4, Size <strong>minSize</strong>=Size()<big>)</big><a class="headerlink" href="#int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, double scaleFactor, int minNeighbors, Size minSize)" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat&amp; image, GpuMat&amp; objectsBuf, Size maxObjectSize, Size minSize , double scaleFactor , int minNeighbors)">
<strong>C++:</strong><tt class="descname"> </tt>int <tt class="descclassname">cuda::CascadeClassifier_CUDA::</tt><tt class="descname">detectMultiScale</tt><big>(</big>const GpuMat&amp; <strong>image</strong>, GpuMat&amp; <strong>objectsBuf</strong>, Size <strong>maxObjectSize</strong>, Size <strong>minSize</strong>=Size(), double <strong>scaleFactor</strong>=1.1, int <strong>minNeighbors</strong>=4<big>)</big><a class="headerlink" href="#int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, Size maxObjectSize, Size minSize , double scaleFactor , int minNeighbors)" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>image</strong> &#8211; Matrix of type  <tt class="docutils literal"><span class="pre">CV_8U</span></tt>  containing an image where objects should be detected.</li>
<li><strong>objectsBuf</strong> &#8211; Buffer to store detected objects (rectangles). If it is empty, it is allocated with the default size. If not empty, the function searches not more than N objects, where <tt class="docutils literal"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">sizeof(objectsBufer's</span> <span class="pre">data)/sizeof(cv::Rect)</span></tt>.</li>
<li><strong>maxObjectSize</strong> &#8211; Maximum possible object size. Objects larger than that are ignored. Used for second signature and supported only for LBP cascades.</li>
<li><strong>scaleFactor</strong> &#8211; Parameter specifying how much the image size is reduced at each image scale.</li>
<li><strong>minNeighbors</strong> &#8211; Parameter specifying how many neighbors each candidate rectangle should have to retain it.</li>
<li><strong>minSize</strong> &#8211; Minimum possible object size. Objects smaller than that are ignored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>The detected objects are returned as a list of rectangles.</p>
<p>The function returns the number of detected objects, so you can retrieve them as in the following example:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cuda</span><span class="o">::</span><span class="n">CascadeClassifier_CUDA</span> <span class="n">cascade_gpu</span><span class="p">(...);</span>

<span class="n">Mat</span> <span class="n">image_cpu</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(...)</span>
<span class="n">GpuMat</span> <span class="n">image_gpu</span><span class="p">(</span><span class="n">image_cpu</span><span class="p">);</span>

<span class="n">GpuMat</span> <span class="n">objbuf</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">detections_number</span> <span class="o">=</span> <span class="n">cascade_gpu</span><span class="p">.</span><span class="n">detectMultiScale</span><span class="p">(</span> <span class="n">image_gpu</span><span class="p">,</span>
          <span class="n">objbuf</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="n">minNeighbors</span><span class="p">);</span>

<span class="n">Mat</span> <span class="n">obj_host</span><span class="p">;</span>
<span class="c1">// download only detected number of rectangles</span>
<span class="n">objbuf</span><span class="p">.</span><span class="n">colRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">detections_number</span><span class="p">).</span><span class="n">download</span><span class="p">(</span><span class="n">obj_host</span><span class="p">);</span>

<span class="n">Rect</span><span class="o">*</span> <span class="n">faces</span> <span class="o">=</span> <span class="n">obj_host</span><span class="p">.</span><span class="n">ptr</span><span class="o">&lt;</span><span class="n">Rect</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">detections_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
   <span class="n">cv</span><span class="o">::</span><span class="n">rectangle</span><span class="p">(</span><span class="n">image_cpu</span><span class="p">,</span> <span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Scalar</span><span class="p">(</span><span class="mi">255</span><span class="p">));</span>

<span class="n">imshow</span><span class="p">(</span><span class="s">&quot;Faces&quot;</span><span class="p">,</span> <span class="n">image_cpu</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="../../objdetect/doc/cascade_classification.html#void CascadeClassifier::detectMultiScale(InputArray image, vector&lt;Rect&gt;&amp; objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)" title="void CascadeClassifier::detectMultiScale(InputArray image, vector&lt;Rect&gt;&amp; objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">CascadeClassifier::detectMultiScale()</span></tt></a></p>
</div>
<table class="docutils citation" frame="void" id="dalal2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Dalal2005]</a></td><td>Navneet Dalal and Bill Triggs. <em>Histogram of oriented gradients for human detection</em>. 2005.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="calib3d.html" title="Camera Calibration and 3D Reconstruction"
             >next</a> |</li>
        <li class="right" >
          <a href="data_structures.html" title="Data Structures"
             >previous</a> |</li>
        <li><a href="../../../index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li>
          <li><a href="../../refman.html" >OpenCV API Reference</a> &raquo;</li>
          <li><a href="cuda.html" >cuda. CUDA-accelerated Computer Vision</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
      <a href="../../../_sources/modules/cuda/doc/object_detection.txt" rel="nofollow">Show this page source.</a>
    </div>
  </body>

<!-- Mirrored from docs.opencv.org/3.0-last-rst/modules/cuda/doc/object_detection.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:58:51 GMT -->
</html>