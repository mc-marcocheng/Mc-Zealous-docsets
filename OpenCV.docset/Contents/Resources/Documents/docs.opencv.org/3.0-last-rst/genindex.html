
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/genindex.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:57:27 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Index</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="index.html" />
    <link href='../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="#" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/opencv-logo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

   

        </div>
      </div>
  <body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            

<h1 id="index">Index</h1>

<div class="genindex-jumpbox">
 <a href="#Symbols"><strong>Symbols</strong></a>
 | <a href="#A"><strong>A</strong></a>
 | <a href="#B"><strong>B</strong></a>
 | <a href="#C"><strong>C</strong></a>
 | <a href="#D"><strong>D</strong></a>
 | <a href="#E"><strong>E</strong></a>
 | <a href="#F"><strong>F</strong></a>
 | <a href="#G"><strong>G</strong></a>
 | <a href="#H"><strong>H</strong></a>
 | <a href="#I"><strong>I</strong></a>
 | <a href="#J"><strong>J</strong></a>
 | <a href="#K"><strong>K</strong></a>
 | <a href="#L"><strong>L</strong></a>
 | <a href="#M"><strong>M</strong></a>
 | <a href="#N"><strong>N</strong></a>
 | <a href="#O"><strong>O</strong></a>
 | <a href="#P"><strong>P</strong></a>
 | <a href="#Q"><strong>Q</strong></a>
 | <a href="#R"><strong>R</strong></a>
 | <a href="#S"><strong>S</strong></a>
 | <a href="#T"><strong>T</strong></a>
 | <a href="#U"><strong>U</strong></a>
 | <a href="#V"><strong>V</strong></a>
 | <a href="#W"><strong>W</strong></a>
 | <a href="#X"><strong>X</strong></a>
 
</div>
<h2 id="Symbols">Symbols</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cv2DRotationMatrix(CvPoint2D32f center, double angle, double scale, CvMat* map_matrix)"><strong>2DRotationMatrix (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="A">A</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr abs(const Mat& m)"><strong>abs (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr abs(const MatExpr& e)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAbsDiff(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>AbsDiff (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void absdiff(InputArray src1, InputArray src2, OutputArray dst)"><strong>absdiff (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.absdiff"><strong>absdiff() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAbsDiffS(const CvArr* src, CvArr* dst, CvScalar value)"><strong>AbsDiffS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvAcc(const CvArr* image, CvArr* sum, const CvArr* mask)"><strong>Acc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulate(InputArray src, InputOutputArray dst, InputArray mask)"><strong>accumulate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulate"><strong>accumulate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateProduct(InputArray src1, InputArray src2, InputOutputArray dst, InputArray mask)"><strong>accumulateProduct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateProduct"><strong>accumulateProduct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateSquare(InputArray src, InputOutputArray dst, InputArray mask)"><strong>accumulateSquare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateSquare"><strong>accumulateSquare() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void accumulateWeighted(InputArray src, InputOutputArray dst, double alpha, InputArray mask)"><strong>accumulateWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#cv2.accumulateWeighted"><strong>accumulateWeighted() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#AdaptiveManifoldFilter : public Algorithm"><strong>AdaptiveManifoldFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.AdaptiveManifoldFilter.filter"><strong>AdaptiveManifoldFilter.filter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#bool adjust_outliers = false"><strong>AdaptiveManifoldFilter::adjust_outliers (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void AdaptiveManifoldFilter::filter(InputArray src, OutputArray dst, InputArray joint)"><strong>AdaptiveManifoldFilter::filter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#int num_pca_iterations = 1"><strong>AdaptiveManifoldFilter::num_pca_iterations (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#double sigma_r = 0.2"><strong>AdaptiveManifoldFilter::sigma_r (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#double sigma_s = 16.0"><strong>AdaptiveManifoldFilter::sigma_s (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#int tree_height = -1"><strong>AdaptiveManifoldFilter::tree_height (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#bool use_RNG = true"><strong>AdaptiveManifoldFilter::use_RNG (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvAdaptiveThreshold(const CvArr* src, CvArr* dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1)"><strong>AdaptiveThreshold (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void adaptiveThreshold(InputArray src, OutputArray dst, double maxValue, int adaptiveMethod, int thresholdType, int blockSize, double C)"><strong>adaptiveThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.adaptiveThreshold"><strong>adaptiveThreshold() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAdd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Add (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><strong>add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.add"><strong>add() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void addCloud(InputArray cloud, InputArray colors, const Affine3d &pose)"><strong>addCloud (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void addCloud(InputArray cloud, const Color &color , const Affine3d &pose)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAddS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>AddS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvAddText(const CvArr* img, const char* text, CvPoint org, CvFont * arg2)"><strong>AddText (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void addText(const Mat& img, const String& text, Point org, const QtFont& font)"><strong>addText (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAddWeighted(const CvArr* src1, double alpha, const CvArr* src2, double beta, double gamma, CvArr* dst)"><strong>AddWeighted (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype)"><strong>addWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.addWeighted"><strong>addWeighted() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void addWidget(const Widget3D& widget, const Affine3d &pose)"><strong>addWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#AffineTransformer : public Algorithm"><strong>AffineTransformer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#AKAZE : public Feature2D"><strong>AKAZE (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#AKAZE::AKAZE(int descriptor_type, int descriptor_size, int descriptor_channels, float threshold, int octaves, int sublevels, int diffusivity)"><strong>AKAZE::AKAZE (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Algorithm"><strong>Algorithm (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> Ptr<_Tp> Algorithm::create(const String& name)"><strong>Algorithm::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> typename ParamType<_Tp>::member_type Algorithm::get(const String& name) const"><strong>Algorithm::get (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::getList(vector<String>& algorithms)"><strong>Algorithm::getList (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#String Algorithm::name() const"><strong>Algorithm::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::read(const FileNode& fn)"><strong>Algorithm::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, int value)"><strong>Algorithm::set (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, double value)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, bool value)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, const String& value)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, const Mat& value)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, const vector<Mat>& value)"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Algorithm::set(const String& name, const Ptr<Algorithm>& value)"><strong>[6]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Algorithm::write(FileStorage& fs) const"><strong>Algorithm::write (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/photo/doc/hdr_imaging.html#AlignExposures : public Algorithm"><strong>AlignExposures (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void AlignExposures::process(InputArrayOfArrays src, std::vector<Mat>& dst, InputArray times, InputArray response)"><strong>AlignExposures::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#AlignMTB : public AlignExposures"><strong>AlignMTB (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Point AlignMTB::calculateShift(InputArray img0, InputArray img1)"><strong>AlignMTB::calculateShift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void AlignMTB::computeBitmaps(InputArray img, OutputArray tb, OutputArray eb)"><strong>AlignMTB::computeBitmaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void AlignMTB::process(InputArrayOfArrays src, std::vector<Mat>& dst)"><strong>AlignMTB::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void AlignMTB::shiftMat(InputArray src, OutputArray dst, const Point shift)"><strong>AlignMTB::shiftMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> _Tp* alignPtr(_Tp* ptr, int n)"><strong>alignPtr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#size_t alignSize(size_t sz, int n)"><strong>alignSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void* cvAlloc(size_t size)"><strong>Alloc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> _Tp* allocate(size_t n)"><strong>allocate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void amFilter(InputArray joint, InputArray src, OutputArray dst, double sigma_s, double sigma_r, bool adjust_outliers)"><strong>amFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.amFilter"><strong>amFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAnd(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>And (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAndS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>AndS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#ANN_MLP : public StatModel"><strong>ANN_MLP (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#Ptr<ANN_MLP> ANN_MLP::create(const Params& params)"><strong>ANN_MLP::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#Params ANN_MLP::getParams() const"><strong>ANN_MLP::getParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#ANN_MLP::Params"><strong>ANN_MLP::Params (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/ml/doc/neural_networks.html#ANN_MLP::Params()"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/ml/doc/neural_networks.html#int activateFunc"><strong>ANN_MLP::Params::activateFunc (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double bpDWScale"><strong>ANN_MLP::Params::bpDWScale (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double bpMomentScale"><strong>ANN_MLP::Params::bpMomentScale (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double fparam1"><strong>ANN_MLP::Params::fparam1 (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double fparam2"><strong>ANN_MLP::Params::fparam2 (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#Mat layerSizes"><strong>ANN_MLP::Params::layerSizes (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#ANN_MLP::Params::Params(const Mat& layerSizes, int activateFunc, double fparam1, double fparam2, TermCriteria termCrit, int trainMethod, double param1, double param2)"><strong>ANN_MLP::Params::Params (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double prDW0"><strong>ANN_MLP::Params::prDW0 (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rpDWMax"><strong>ANN_MLP::Params::rpDWMax (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rpDWMin"><strong>ANN_MLP::Params::rpDWMin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rpDWMinus"><strong>ANN_MLP::Params::rpDWMinus (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#double rpDWPlus"><strong>ANN_MLP::Params::rpDWPlus (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/neural_networks.html#void ANN_MLP::setParams(const Params& params)"><strong>ANN_MLP::setParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/colormaps.html#void applyColorMap(InputArray src, OutputArray dst, int colormap)"><strong>applyColorMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void applyTransform(const Affine3d &transform)"><strong>applyTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#float applyTransformation(InputArray input, OutputArray output)"><strong>applyTransformation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvApproxChains(CvSeq* src_seq, CvMemStorage* storage, int method, double parameter, int minimal_perimeter, int recursive)"><strong>ApproxChains (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvApproxPoly(const void* src_seq, int header_size, CvMemStorage* storage, int method, double eps, int recursive)"><strong>ApproxPoly (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void approxPolyDP(InputArray curve, OutputArray approxCurve, double epsilon, bool closed)"><strong>approxPolyDP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.approxPolyDP"><strong>approxPolyDP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/ar_hmdb.html#AR_hmdb"><strong>AR_hmdb (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/ar_sports.html#AR_sports"><strong>AR_sports (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvArcLength(const void* curve, CvSlice slice, int is_closed)"><strong>ArcLength (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double arcLength(InputArray curve, bool closed)"><strong>arcLength (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.arcLength"><strong>arcLength() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void arrowedLine(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift, double tipLength)"><strong>arrowedLine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvAvg(const CvArr* arr, const CvArr* mask)"><strong>Avg (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvAvgSdv(const CvArr* arr, CvScalar* mean, CvScalar* std_dev, const CvArr* mask)"><strong>AvgSdv (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="B">B</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractor : public Algorithm"><strong>BackgroundSubtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.BackgroundSubtractor.apply"><strong>BackgroundSubtractor.apply() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractor::apply(InputArray image, OutputArray fgmask, double learningRate)"><strong>BackgroundSubtractor::apply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractor::getBackgroundImage(OutputArray backgroundImage) const"><strong>BackgroundSubtractor::getBackgroundImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorGMG : public BackgroundSubtractor"><strong>BackgroundSubtractorGMG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorGMG::getBackgroundPrior() const"><strong>BackgroundSubtractorGMG::getBackgroundPrior (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorGMG::getDecisionThreshold() const"><strong>BackgroundSubtractorGMG::getDecisionThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorGMG::getDefaultLearningRate() const"><strong>BackgroundSubtractorGMG::getDefaultLearningRate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorGMG::getMaxFeatures() const"><strong>BackgroundSubtractorGMG::getMaxFeatures (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorGMG::getMaxVal() const"><strong>BackgroundSubtractorGMG::getMaxVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorGMG::getMinVal() const"><strong>BackgroundSubtractorGMG::getMinVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorGMG::getNumFrames() const"><strong>BackgroundSubtractorGMG::getNumFrames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorGMG::getQuantizationLevels() const"><strong>BackgroundSubtractorGMG::getQuantizationLevels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorGMG::getSmoothingRadius() const"><strong>BackgroundSubtractorGMG::getSmoothingRadius (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#bool BackgroundSubtractorGMG::getUpdateBackgroundModel() const"><strong>BackgroundSubtractorGMG::getUpdateBackgroundModel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setBackgroundPrior(double bgprior)"><strong>BackgroundSubtractorGMG::setBackgroundPrior (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setDecisionThreshold(double thresh)"><strong>BackgroundSubtractorGMG::setDecisionThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setDefaultLearningRate(double lr)"><strong>BackgroundSubtractorGMG::setDefaultLearningRate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setMaxFeatures(int maxFeatures)"><strong>BackgroundSubtractorGMG::setMaxFeatures (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setMaxVal(double val)"><strong>BackgroundSubtractorGMG::setMaxVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setMinVal(double val)"><strong>BackgroundSubtractorGMG::setMinVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setNumFrames(int nframes)"><strong>BackgroundSubtractorGMG::setNumFrames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setQuantizationLevels(int nlevels)"><strong>BackgroundSubtractorGMG::setQuantizationLevels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setSmoothingRadius(int radius)"><strong>BackgroundSubtractorGMG::setSmoothingRadius (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorGMG::setUpdateBackgroundModel(bool update)"><strong>BackgroundSubtractorGMG::setUpdateBackgroundModel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorKNN : public BackgroundSubtractor"><strong>BackgroundSubtractorKNN (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#bool BackgroundSubtractorKNN::getDetectShadows() const"><strong>BackgroundSubtractorKNN::getDetectShadows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorKNN::getDist2Threshold() const"><strong>BackgroundSubtractorKNN::getDist2Threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorKNN::getHistory() const"><strong>BackgroundSubtractorKNN::getHistory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorKNN::getkNNSamples() const"><strong>BackgroundSubtractorKNN::getkNNSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorKNN::getNSamples() const"><strong>BackgroundSubtractorKNN::getNSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorKNN::getShadowThreshold() const"><strong>BackgroundSubtractorKNN::getShadowThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorKNN::getShadowValue() const"><strong>BackgroundSubtractorKNN::getShadowValue (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setDetectShadows(bool detectShadows)"><strong>BackgroundSubtractorKNN::setDetectShadows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setDist2Threshold(double _dist2Threshold)"><strong>BackgroundSubtractorKNN::setDist2Threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setHistory(int history)"><strong>BackgroundSubtractorKNN::setHistory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setkNNSamples(int _nkNN)"><strong>BackgroundSubtractorKNN::setkNNSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setNSamples(int _nN)"><strong>BackgroundSubtractorKNN::setNSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setShadowThreshold(double threshold)"><strong>BackgroundSubtractorKNN::setShadowThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorKNN::setShadowValue(int value)"><strong>BackgroundSubtractorKNN::setShadowValue (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG : public BackgroundSubtractor"><strong>BackgroundSubtractorMOG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#BackgroundSubtractorMOG2 : public BackgroundSubtractor"><strong>BackgroundSubtractorMOG2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getBackgroundRatio() const"><strong>BackgroundSubtractorMOG2::getBackgroundRatio (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getComplexityReductionThreshold() const"><strong>BackgroundSubtractorMOG2::getComplexityReductionThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#bool BackgroundSubtractorMOG2::getDetectShadows() const"><strong>BackgroundSubtractorMOG2::getDetectShadows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorMOG2::getHistory() const"><strong>BackgroundSubtractorMOG2::getHistory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorMOG2::getNMixtures() const"><strong>BackgroundSubtractorMOG2::getNMixtures (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getShadowThreshold() const"><strong>BackgroundSubtractorMOG2::getShadowThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int BackgroundSubtractorMOG2::getShadowValue() const"><strong>BackgroundSubtractorMOG2::getShadowValue (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getVarInit() const"><strong>BackgroundSubtractorMOG2::getVarInit (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getVarThreshold() const"><strong>BackgroundSubtractorMOG2::getVarThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double BackgroundSubtractorMOG2::getVarThresholdGen() const"><strong>BackgroundSubtractorMOG2::getVarThresholdGen (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setBackgroundRatio(double ratio)"><strong>BackgroundSubtractorMOG2::setBackgroundRatio (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setComplexityReductionThreshold(double ct)"><strong>BackgroundSubtractorMOG2::setComplexityReductionThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setDetectShadows(bool detectShadows)"><strong>BackgroundSubtractorMOG2::setDetectShadows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setHistory(int history)"><strong>BackgroundSubtractorMOG2::setHistory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setNMixtures(int nmixtures)"><strong>BackgroundSubtractorMOG2::setNMixtures (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setShadowThreshold(double threshold)"><strong>BackgroundSubtractorMOG2::setShadowThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setShadowValue(int value)"><strong>BackgroundSubtractorMOG2::setShadowValue (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setVarInit(double varInit)"><strong>BackgroundSubtractorMOG2::setVarInit (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setVarThreshold(double varThreshold)"><strong>BackgroundSubtractorMOG2::setVarThreshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void BackgroundSubtractorMOG2::setVarThresholdGen(double varThresholdGen)"><strong>BackgroundSubtractorMOG2::setVarThresholdGen (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xphoto/doc/whitebalance.html#void balanceWhite(const Mat &src, Mat &dst, const int algorithmType, const float inputMin , const float inputMax , const float outputMin , const float outputMax)"><strong>balanceWhite (C++ function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/BaseLoaderCallback.html#BaseLoaderCallback">BaseLoaderCallback (built-in class)</a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#BFMatcher : public DescriptorMatcher"><strong>BFMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#BFMatcher::BFMatcher(int normType, bool crossCheck)"><strong>BFMatcher::BFMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><strong>bilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.bilateralFilter"><strong>bilateralFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#bool BinaryDescriptor::BinaryDescriptor(const BinaryDescriptor::Params &parameters)"><strong>BinaryDescriptor::BinaryDescriptor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#Ptr<BinaryDescriptor> BinaryDescriptor::createBinaryDescriptor()"><strong>BinaryDescriptor::createBinaryDescriptor (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/binary_descriptor.html#Ptr<BinaryDescriptor> BinaryDescriptor::createBinaryDescriptor(Params parameters)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::defaultNorm() const"><strong>BinaryDescriptor::defaultNorm (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::descriptorSize() const"><strong>BinaryDescriptor::descriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::descriptorType() const"><strong>BinaryDescriptor::descriptorType (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::getNumOfOctaves()"><strong>BinaryDescriptor::getNumOfOctaves (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::getReductionRatio()"><strong>BinaryDescriptor::getReductionRatio (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#int BinaryDescriptor::getWidthOfBand()"><strong>BinaryDescriptor::getWidthOfBand (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::operator()(InputArray image, InputArray mask, vector<KeyLine>& keylines, OutputArray descriptors, bool useProvidedKeyLines, bool returnFloatDescr) const"><strong>BinaryDescriptor::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#BinaryDescriptor::Params"><strong>BinaryDescriptor::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::read(const FileNode& fn)"><strong>BinaryDescriptor::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::setNumOfOctaves(int octaves)"><strong>BinaryDescriptor::setNumOfOctaves (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::setReductionRatio(int rRatio)"><strong>BinaryDescriptor::setReductionRatio (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::setWidthOfBand(int width)"><strong>BinaryDescriptor::setWidthOfBand (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void BinaryDescriptor::write(FileStorage& fs) const"><strong>BinaryDescriptor::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::add(const std::vector<Mat>& descriptors)"><strong>BinaryDescriptorMatcher::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#BinaryDescriptorMatcher::BinaryDescriptorMatcher()"><strong>BinaryDescriptorMatcher::BinaryDescriptorMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::clear()"><strong>BinaryDescriptorMatcher::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#Ptr<BinaryDescriptorMatcher> BinaryDescriptorMatcher::createBinaryDescriptorMatcher()"><strong>BinaryDescriptorMatcher::createBinaryDescriptorMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::knnMatch(const Mat& queryDescriptors, const Mat& trainDescriptors, std::vector<std::vector<DMatch> >& matches, int k, const Mat& mask, bool compactResult) const"><strong>BinaryDescriptorMatcher::knnMatch (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::knnMatch(const Mat& queryDescriptors, std::vector<std::vector<DMatch> >& matches, int k, const std::vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::match(const Mat& queryDescriptors, const Mat& trainDescriptors, std::vector<DMatch>& matches, const Mat& mask) const"><strong>BinaryDescriptorMatcher::match (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::match(const Mat& queryDescriptors, std::vector<DMatch>& matches, const std::vector<Mat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::radiusMatch(const Mat& queryDescriptors, const Mat& trainDescriptors, std::vector<std::vector<DMatch> >& matches, float maxDistance, const Mat& mask, bool compactResult) const"><strong>BinaryDescriptorMatcher::radiusMatch (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::radiusMatch(const Mat& queryDescriptors, std::vector<std::vector<DMatch> >& matches, float maxDistance, const std::vector<Mat>& masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/matching.html#void BinaryDescriptorMatcher::train()"><strong>BinaryDescriptorMatcher::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_and (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_and"><strong>bitwise_and() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_not(InputArray src, OutputArray dst, InputArray mask)"><strong>bitwise_not (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_not"><strong>bitwise_not() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_or (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_or"><strong>bitwise_or() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask)"><strong>bitwise_xor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.bitwise_xor"><strong>bitwise_xor() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void blur(InputArray src, OutputArray dst, Size ksize, Point anchor, int borderType)"><strong>blur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.blur"><strong>blur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#Boost : public DTrees"><strong>Boost (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#Ptr<Boost> Boost::create(const Params& params)"><strong>Boost::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#Params Boost::getBParams() const"><strong>Boost::getBParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#Boost::Params : public DTree::Params"><strong>Boost::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#Boost::Params::Params()"><strong>Boost::Params::Params (C++ function)</strong></a>, <a href="modules/ml/doc/boosting.html#Boost::Params::Params(int boostType, int weakCount, double weightTrimRate, int maxDepth, bool useSurrogates, const Mat& priors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/boosting.html#void Boost::setBParams(const Params& p)"><strong>Boost::setBParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int borderInterpolate(int p, int len, int borderType)"><strong>borderInterpolate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.borderInterpolate"><strong>borderInterpolate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvRect cvBoundingRect(CvArr* points, int update)"><strong>BoundingRect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#Rect boundingRect(InputArray points)"><strong>boundingRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.boundingRect"><strong>boundingRect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWImgDescriptorExtractor"><strong>BOWImgDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(const Ptr<DescriptorExtractor>& dextractor, const Ptr<DescriptorMatcher>& dmatcher)"><strong>BOWImgDescriptorExtractor::BOWImgDescriptorExtractor (C++ function)</strong></a>, <a href="modules/features2d/doc/object_categorization.html#BOWImgDescriptorExtractor::BOWImgDescriptorExtractor(const Ptr<DescriptorMatcher>& dmatcher)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWImgDescriptorExtractor::compute(InputArray image, vector<KeyPoint>& keypoints, OutputArray imgDescriptor, vector<vector<int> >* pointIdxsOfClusters, Mat* descriptors)"><strong>BOWImgDescriptorExtractor::compute (C++ function)</strong></a>, <a href="modules/features2d/doc/object_categorization.html#void BOWImgDescriptorExtractor::compute(InputArray keypointDescriptors, OutputArray imgDescriptor, std::vector<std::vector<int> >* pointIdxsOfClusters)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWImgDescriptorExtractor::descriptorSize() const"><strong>BOWImgDescriptorExtractor::descriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWImgDescriptorExtractor::descriptorType() const"><strong>BOWImgDescriptorExtractor::descriptorType (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#const Mat& BOWImgDescriptorExtractor::getVocabulary() const"><strong>BOWImgDescriptorExtractor::getVocabulary (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWImgDescriptorExtractor::setVocabulary(const Mat& vocabulary)"><strong>BOWImgDescriptorExtractor::setVocabulary (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWKMeansTrainer : public BOWTrainer"><strong>BOWKMeansTrainer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWKMeansTrainer::BOWKMeansTrainer(int clusterCount, const TermCriteria& termcrit, int attempts, int flags)"><strong>BOWKMeansTrainer::BOWKMeansTrainer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#BOWTrainer"><strong>BOWTrainer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#void BOWTrainer::add(const Mat& descriptors)"><strong>BOWTrainer::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#Mat BOWTrainer::cluster() const"><strong>BOWTrainer::cluster (C++ function)</strong></a>, <a href="modules/features2d/doc/object_categorization.html#Mat BOWTrainer::cluster(const Mat& descriptors) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#int BOWTrainer::descriptorsCount() const"><strong>BOWTrainer::descriptorsCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/object_categorization.html#const vector<Mat>& BOWTrainer::getDescriptors() const"><strong>BOWTrainer::getDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void boxFilter(InputArray src, OutputArray dst, int ddepth, Size ksize, Point anchor, bool normalize, int borderType)"><strong>boxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.boxFilter"><strong>boxFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvBoxPoints(CvBox2D box, CvPoint2D32f pt[4])"><strong>BoxPoints (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void boxPoints(RotatedRect box, OutputArray points)"><strong>boxPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.boxPoints"><strong>boxPoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/extra_features.html#BriefDescriptorExtractor : public DescriptorExtractor"><strong>BriefDescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#BRISK : public Feature2D"><strong>BRISK (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.BRISK"><strong>BRISK() (Python function in cv2)</strong></a>, <a href="modules/features2d/doc/feature_detection_and_description.html#cv2.BRISK"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.BRISK.compute"><strong>BRISK.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.BRISK.detect"><strong>BRISK.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.BRISK.detectAndCompute"><strong>BRISK.detectAndCompute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#BRISK::BRISK(int thresh, int octaves, float patternScale)"><strong>BRISK::BRISK (C++ function)</strong></a>, <a href="modules/features2d/doc/feature_detection_and_description.html#BRISK::BRISK(std::vector<float> &radiusList, std::vector<int> &numberList, float dMax, float dMin, std::vector<int> indexChange)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void BRISK::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const"><strong>BRISK::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int buildOpticalFlowPyramid(InputArray img, OutputArrayOfArrays pyramid, Size winSize, int maxLevel, bool withDerivatives , int pyrBorder , int derivBorder , bool tryReuseInputImage)"><strong>buildOpticalFlowPyramid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.buildOpticalFlowPyramid"><strong>buildOpticalFlowPyramid() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void buildPyramid(InputArray src, OutputArrayOfArrays dst, int maxlevel, int borderType)"><strong>buildPyramid (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="C">C</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcBackProject(IplImage** image, CvArr* backProject, const CvHistogram* hist)"><strong>CalcBackProject (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, InputArray hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><strong>calcBackProject (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#void calcBackProject(const Mat* images, int nimages, const int* channels, const SparseMat& hist, OutputArray backProject, const float** ranges, double scale, bool uniform)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.calcBackProject"><strong>calcBackProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcBackProjectPatch(IplImage** images, CvArr* dst, CvSize patch_size, CvHistogram* hist, int method, double factor)"><strong>CalcBackProjectPatch (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCalcCovarMatrix(const CvArr** vects, int count, CvArr* cov_mat, CvArr* avg, int flags)"><strong>CalcCovarMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void calcCovarMatrix(const Mat* samples, int nsamples, Mat& covar, Mat& mean, int flags, int ctype)"><strong>calcCovarMatrix (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void calcCovarMatrix(InputArray samples, OutputArray covar, InputOutputArray mean, int flags, int ctype)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.calcCovarMatrix"><strong>calcCovarMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#float cvCalcEMD2(const CvArr* signature1, const CvArr* signature2, int distance_type, CvDistanceFunction distance_func, const CvArr* cost_matrix, CvArr* flow, float* lower_bound, void* userdata)"><strong>CalcEMD2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#double calcGlobalOrientation(InputArray orientation, InputArray mask, InputArray mhi, double timestamp, double duration)"><strong>calcGlobalOrientation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#cv2.calcGlobalOrientation"><strong>calcGlobalOrientation() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcHist(IplImage** image, CvHistogram* hist, int accumulate, const CvArr* mask)"><strong>CalcHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void calcHist(const Mat* images, int nimages, const int* channels, InputArray mask, OutputArray hist, int dims, const int* histSize, const float** ranges, bool uniform, bool accumulate)"><strong>calcHist (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#void calcHist(const Mat* images, int nimages, const int* channels, InputArray mask, SparseMat& hist, int dims, const int* histSize, const float** ranges, bool uniform, bool accumulate)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.calcHist"><strong>calcHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#void calcMotionGradient(InputArray mhi, OutputArray mask, OutputArray orientation, double delta1, double delta2, int apertureSize)"><strong>calcMotionGradient (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#cv2.calcMotionGradient"><strong>calcMotionGradient() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvCalcOpticalFlowFarneback(const CvArr* prev, const CvArr* next, CvArr* flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)"><strong>CalcOpticalFlowFarneback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowFarneback(InputArray prev, InputArray next, InputOutputArray flow, double pyr_scale, int levels, int winsize, int iterations, int poly_n, double poly_sigma, int flags)"><strong>calcOpticalFlowFarneback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcOpticalFlowFarneback"><strong>calcOpticalFlowFarneback() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void cvCalcOpticalFlowPyrLK(const CvArr* prev, const CvArr* curr, CvArr* prev_pyr, CvArr* curr_pyr, const CvPoint2D32f* prev_features, CvPoint2D32f* curr_features, int count, CvSize win_size, int level, char* status, float* track_error, CvTermCriteria criteria, int flags)"><strong>CalcOpticalFlowPyrLK (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void calcOpticalFlowPyrLK(InputArray prevImg, InputArray nextImg, InputArray prevPts, InputOutputArray nextPts, OutputArray status, OutputArray err, Size winSize, int maxLevel, TermCriteria criteria, int flags, double minEigThreshold)"><strong>calcOpticalFlowPyrLK (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.calcOpticalFlowPyrLK"><strong>calcOpticalFlowPyrLK() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#void calcOpticalFlowSF(InputArray from, InputArray to, OutputArray flow, int layers, int averaging_block_size, int max_flow)"><strong>calcOpticalFlowSF (C++ function)</strong></a>, <a href="modules/optflow/doc/dense_optflow.html#calcOpticalFlowSF(InputArray from, InputArray to, OutputArray flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCalcProbDensity(const CvHistogram* hist1, const CvHistogram* hist2, CvHistogram* dst_hist, double scale)"><strong>CalcProbDensity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double calibrateCamera(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags, TermCriteria criteria)"><strong>calibrateCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.calibrateCamera"><strong>calibrateCamera() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double cvCalibrateCamera2(const CvMat* object_points, const CvMat* image_points, const CvMat* point_counts, CvSize image_size, CvMat* camera_matrix, CvMat* distortion_coeffs, CvMat* rotation_vectors, CvMat* translation_vectors, int flags, CvTermCriteria term_crit)"><strong>CalibrateCamera2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#CalibrateCRF : public Algorithm"><strong>CalibrateCRF (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void CalibrateCRF::process(InputArrayOfArrays src, OutputArray dst, InputArray times)"><strong>CalibrateCRF::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#CalibrateDebevec : public CalibrateCRF"><strong>CalibrateDebevec (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#CalibrateRobertson : public CalibrateCRF"><strong>CalibrateRobertson (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void calibrationMatrixValues(InputArray cameraMatrix, Size imageSize, double apertureWidth, double apertureHeight, double& fovx, double& fovy, double& focalLength, Point2d& principalPoint, double& aspectRatio)"><strong>calibrationMatrixValues (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.calibrationMatrixValues"><strong>calibrationMatrixValues() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Camera"><strong>Camera (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#Camera(double f_x, double f_y, double c_x, double c_y, const Size &window_size)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(const Vec2d &fov, const Size &window_size)"><strong>[1]</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(const Matx33d &K, const Size &window_size)"><strong>[2]</strong></a>, <a href="modules/viz/doc/viz3d.html#Camera(const Matx44d &proj, const Size &window_size)"><strong>[3]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int cvCamShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp, CvBox2D* box)"><strong>CamShift (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#RotatedRect CamShift(InputArray probImage, Rect& window, TermCriteria criteria)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.CamShift"><strong>CamShift() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCanny(const CvArr* image, CvArr* edges, double threshold1, double threshold2, int aperture_size)"><strong>Canny (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/feature_detection.html#void Canny(InputArray image, OutputArray edges, double threshold1, double threshold2, int apertureSize, bool L2gradient)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.Canny"><strong>Canny() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#CvCapture* cvCaptureFromCAM(int device)"><strong>CaptureFromCAM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#CvCapture* cvCaptureFromFile(const char* filename)"><strong>CaptureFromFile (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCartToPolar(const CvArr* x, const CvArr* y, CvArr* magnitude, CvArr* angle, int angle_in_degrees)"><strong>CartToPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees)"><strong>cartToPolar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.cartToPolar"><strong>cartToPolar() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CascadeClassifier"><strong>CascadeClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier"><strong>CascadeClassifier() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale"><strong>CascadeClassifier.detectMultiScale() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale2"><strong>CascadeClassifier.detectMultiScale2() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.detectMultiScale3"><strong>CascadeClassifier.detectMultiScale3() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.empty"><strong>CascadeClassifier.empty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.CascadeClassifier.load"><strong>CascadeClassifier.load() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CascadeClassifier::CascadeClassifier(const String& filename)"><strong>CascadeClassifier::CascadeClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#void CascadeClassifier::detectMultiScale(InputArray image, vector<Rect>& objects, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)"><strong>CascadeClassifier::detectMultiScale (C++ function)</strong></a>, <a href="modules/objdetect/doc/cascade_classification.html#void CascadeClassifier::detectMultiScale(InputArray image, vector<Rect>& objects, vector<int>& numDetections, double scaleFactor, int minNeighbors, int flags, Size minSize, Size maxSize)"><strong>[1]</strong></a>, <a href="modules/objdetect/doc/cascade_classification.html#void CascadeClassifier::detectMultiScale(InputArray image, std::vector<Rect>& objects, std::vector<int>& rejectLevels, std::vector<double>& levelWeights, double scaleFactor , int minNeighbors , int flags , Size minSize , Size maxSize , bool outputRejectLevels)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::empty() const"><strong>CascadeClassifier::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::load(const String& filename)"><strong>CascadeClassifier::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#bool CascadeClassifier::read(const FileNode& node)"><strong>CascadeClassifier::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#template<typename _W> _W cast()"><strong>cast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cvCbrt(float value)"><strong>Cbrt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvCeil(double value)"><strong>Ceil (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">center (built-in class)</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[1]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[2]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[3]</a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#center">[4]</a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvCheckContourConvexity(const CvArr* contour)"><strong>CheckContourConvexity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvCheckHardwareSupport(int feature)"><strong>CheckHardwareSupport (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#bool checkHardwareSupport(int feature)"><strong>checkHardwareSupport (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.checkHardwareSupport"><strong>checkHardwareSupport() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool checkRange(InputArray a, bool quiet, Point* pos, double minVal, double maxVal)"><strong>checkRange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.checkRange"><strong>checkRange() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/histogram_cost_matrix.html#ChiHistogramCostExtractor : public HistogramCostExtractor"><strong>ChiHistogramCostExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvCircle(CvArr* img, CvPoint center, int radius, CvScalar color, int thickness, int line_type, int shift)"><strong>Circle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void circle(InputOutputArray img, Point center, int radius, const Scalar& color, int thickness, int lineType, int shift)"><strong>circle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.circle"><strong>circle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearGraph(CvGraph* graph)"><strong>ClearGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvClearHist(CvHistogram* hist)"><strong>ClearHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearMemStorage(CvMemStorage* storage)"><strong>ClearMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvClearND(CvArr* arr, const int* idx)"><strong>ClearND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearSeq(CvSeq* seq)"><strong>ClearSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvClearSet(CvSet* set_header)"><strong>ClearSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#int cvClipLine(CvSize img_size, CvPoint* pt1, CvPoint* pt2)"><strong>ClipLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#bool clipLine(Size imgSize, Point& pt1, Point& pt2)"><strong>clipLine (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#bool clipLine(Rect imgRect, Point& pt1, Point& pt2)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.clipLine"><strong>clipLine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvClone(const void* struct_ptr)"><strong>Clone (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph* cvCloneGraph(const CvGraph* graph, CvMemStorage* storage)"><strong>CloneGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCloneImage(const IplImage* image)"><strong>CloneImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCloneMat(const CvMat* mat)"><strong>CloneMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCloneMatND(const CvMatND* mat)"><strong>CloneMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvCloneSeq(const CvSeq* seq, CvMemStorage* storage)"><strong>CloneSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat* cvCloneSparseMat(const CvSparseMat* mat)"><strong>CloneSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCmp(const CvArr* src1, const CvArr* src2, CvArr* dst, int cmp_op)"><strong>Cmp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvCmpS(const CvArr* src, double value, CvArr* dst, int cmp_op)"><strong>CmpS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Color"><strong>Color (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/cloning.html#void colorChange(InputArray src, InputArray mask, OutputArray dst, float red_mul , float green_mul , float blue_mul)"><strong>colorChange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#CommandLineParser"><strong>CommandLineParser (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#void CommandLineParser::about(const String& message)"><strong>CommandLineParser::about (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#bool CommandLineParser::check()"><strong>CommandLineParser::check (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#CommandLineParser::CommandLineParser(int argc, const char* const argv[], const String& keys)"><strong>CommandLineParser::CommandLineParser (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#template<typename T> T CommandLineParser::get<T>(const String& name, bool space_delete)"><strong>CommandLineParser::get&lt;T&gt; (C++ function)</strong></a>, <a href="modules/core/doc/command_line_parser.html#template<typename T> T CommandLineParser::get<T>(int index, bool space_delete)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#String CommandLineParser::getPathToApplication()"><strong>CommandLineParser::getPathToApplication (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#bool CommandLineParser::has(const String& name)"><strong>CommandLineParser::has (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#void CommandLineParser::printErrors()"><strong>CommandLineParser::printErrors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/command_line_parser.html#void CommandLineParser::printMessage()"><strong>CommandLineParser::printMessage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop)"><strong>compare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.compare"><strong>compare() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#double cvCompareHist(const CvHistogram* hist1, const CvHistogram* hist2, int method)"><strong>CompareHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#double compareHist(InputArray H1, InputArray H2, int method)"><strong>compareHist (C++ function)</strong></a>, <a href="modules/imgproc/doc/histograms.html#double compareHist(const SparseMat& H1, const SparseMat& H2, int method)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.compareHist"><strong>compareHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void completeSymm(InputOutputArray mtx, bool lowerToUpper)"><strong>completeSymm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.completeSymm"><strong>completeSymm() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void composeRT(InputArray rvec1, InputArray tvec1, InputArray rvec2, InputArray tvec2, OutputArray rvec3, OutputArray tvec3, OutputArray dr3dr1, OutputArray dr3dt1, OutputArray dr3dr2, OutputArray dr3dt2, OutputArray dt3dr1, OutputArray dt3dt1, OutputArray dt3dr2, OutputArray dt3dt2)"><strong>composeRT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.composeRT"><strong>composeRT() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void compute(const Mat& image, vector<KeyLine>& keylines, Mat& descriptors, bool returnFloatDescr) const"><strong>compute (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/binary_descriptor.html#void compute(const vector<Mat>& images, vector<vector<KeyLine> >& keylines, vector<Mat>& descriptors, bool returnFloatDescr) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/saliency_categories.html#bool computeBinaryMap(const Mat& saliencyMap, Mat& binaryMap)"><strong>computeBinaryMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void computeChannels(InputArray image, vector<Mat>& channels)"><strong>computeChannels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvComputeCorrespondEpilines(const CvMat* points, int which_image, const CvMat* fundamental_matrix, CvMat* correspondent_lines)"><strong>ComputeCorrespondEpilines (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void computeCorrespondEpilines(InputArray points, int whichImage, InputArray F, OutputArray lines)"><strong>computeCorrespondEpilines (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.computeCorrespondEpilines"><strong>computeCorrespondEpilines() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#void computeNMChannels(InputArray _src, OutputArrayOfArrays _channels, int _mode)"><strong>computeNMChannels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void computeProjectionMatrix(Matx44d &proj) const"><strong>computeProjectionMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#c.ConfidenceMap">ConfidenceMap (C type)</a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#ConjGradSolver"><strong>ConjGradSolver (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#Ptr<Solver::Function> ConjGradSolver::getFunction()"><strong>ConjGradSolver::getFunction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#TermCriteria ConjGradSolver::getTermCriteria()"><strong>ConjGradSolver::getTermCriteria (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#double ConjGradSolver::minimize(InputOutputArray x)"><strong>ConjGradSolver::minimize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void ConjGradSolver::setFunction(const Ptr<Solver::Function>& f)"><strong>ConjGradSolver::setFunction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void ConjGradSolver::setTermCriteria(const TermCriteria& termcrit)"><strong>ConjGradSolver::setTermCriteria (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int connectedComponents(InputArray image, OutputArray labels, int connectivity , int ltype)"><strong>connectedComponents (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int connectedComponentsWithStats(InputArray image, OutputArray labels, OutputArray stats, OutputArray centroids, int connectivity , int ltype)"><strong>connectedComponentsWithStats (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvContourArea(const CvArr* contour, CvSlice slice, int oriented)"><strong>ContourArea (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double contourArea(InputArray contour, bool oriented)"><strong>contourArea (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.contourArea"><strong>contourArea() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void convertMaps(InputArray map1, InputArray map2, OutputArray dstmap1, OutputArray dstmap2, int dstmap1type, bool nninterpolation)"><strong>convertMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.convertMaps"><strong>convertMaps() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void converTo3DRay(const Point3d &window_coord, Point3d &origin, Vec3d &direction)"><strong>converTo3DRay (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsFromHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsFromHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.convertPointsFromHomogeneous"><strong>convertPointsFromHomogeneous() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvConvertPointsHomogeneous(const CvMat* src, CvMat* dst)"><strong>ConvertPointsHomogeneous (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void convertPointsToHomogeneous(InputArray src, OutputArray dst)"><strong>convertPointsToHomogeneous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.convertPointsToHomogeneous"><strong>convertPointsToHomogeneous() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvConvertScale(const CvArr* src, CvArr* dst, double scale, double shift)"><strong>ConvertScale (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvConvertScaleAbs(const CvArr* src, CvArr* dst, double scale, double shift)"><strong>ConvertScaleAbs (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void convertScaleAbs(InputArray src, OutputArray dst, double alpha, double beta)"><strong>convertScaleAbs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.convertScaleAbs"><strong>convertScaleAbs() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void convertToWindowCoordinates(const Point3d &pt, Point3d &window_coord)"><strong>convertToWindowCoordinates (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void convexHull(InputArray points, OutputArray hull, bool clockwise, bool returnPoints)"><strong>convexHull (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.convexHull"><strong>convexHull() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvConvexHull2(const CvArr* input, void* hull_storage, int orientation, int return_points)"><strong>ConvexHull2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvSeq* cvConvexityDefects(const CvArr* contour, const CvArr* convexhull, CvMemStorage* storage)"><strong>ConvexityDefects (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void convexityDefects(InputArray contour, InputArray convexhull, OutputArray convexityDefects)"><strong>convexityDefects (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.convexityDefects"><strong>convexityDefects() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCopy(const CvArr* src, CvArr* dst, const CvArr* mask)"><strong>Copy (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvCopyHist(const CvHistogram* src, CvHistogram** dst)"><strong>CopyHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, const Scalar& value)"><strong>copyMakeBorder (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.copyMakeBorder"><strong>copyMakeBorder() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerEigenValsAndVecs(const CvArr* image, CvArr* eigenvv, int block_size, int aperture_size)"><strong>CornerEigenValsAndVecs (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerEigenValsAndVecs(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)"><strong>cornerEigenValsAndVecs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerEigenValsAndVecs"><strong>cornerEigenValsAndVecs() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerHarris(const CvArr* image, CvArr* harris_response, int block_size, int aperture_size, double k)"><strong>CornerHarris (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerHarris(InputArray src, OutputArray dst, int blockSize, int ksize, double k, int borderType)"><strong>cornerHarris (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerHarris"><strong>cornerHarris() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvCornerMinEigenVal(const CvArr* image, CvArr* eigenval, int block_size, int aperture_size)"><strong>CornerMinEigenVal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerMinEigenVal(InputArray src, OutputArray dst, int blockSize, int ksize, int borderType)"><strong>cornerMinEigenVal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerMinEigenVal"><strong>cornerMinEigenVal() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cornerSubPix(InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria)"><strong>cornerSubPix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.cornerSubPix"><strong>cornerSubPix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvCorrectMatches(CvMat* F, CvMat* points1, CvMat* points2, CvMat* new_points1, CvMat* new_points2)"><strong>CorrectMatches (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void correctMatches(InputArray F, InputArray points1, InputArray points2, OutputArray newPoints1, OutputArray newPoints2)"><strong>correctMatches (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.correctMatches"><strong>correctMatches() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvCountNonZero(const CvArr* arr)"><strong>CountNonZero (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int countNonZero(InputArray src)"><strong>countNonZero (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.countNonZero"><strong>countNonZero() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Ptr<TrainData> create(InputArray samples, int layout, InputArray responses, InputArray varIdx, InputArray sampleIdx, InputArray sampleWeights, InputArray varType)"><strong>create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<AlignMTB> createAlignMTB(int max_bits , int exclude_range , bool cut)"><strong>createAlignMTB (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#Ptr<AdaptiveManifoldFilter> createAMFilter(double sigma_s, double sigma_r, bool adjust_outliers)"><strong>createAMFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.createAMFilter"><strong>createAMFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<BackgroundSubtractorGMG> createBackgroundSubtractorGMG(int initializationFrames, double decisionThreshold)"><strong>createBackgroundSubtractorGMG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.createBackgroundSubtractorGMG"><strong>createBackgroundSubtractorGMG() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<BackgroundSubtractorKNN> createBackgroundSubtractorKNN(int history, double dist2Threshold, bool detectShadows)"><strong>createBackgroundSubtractorKNN (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<BackgroundSubtractorMOG> createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)"><strong>createBackgroundSubtractorMOG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.createBackgroundSubtractorMOG"><strong>createBackgroundSubtractorMOG() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<BackgroundSubtractorMOG2> createBackgroundSubtractorMOG2(int history, double varThreshold, bool detectShadows)"><strong>createBackgroundSubtractorMOG2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#int cvCreateButton(const char* button_name, CvButtonCallback on_change, void* userdata, int button_type, int initial_button_state)"><strong>CreateButton (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#int createButton(const String& bar_name, ButtonCallback on_change, void* userdata, int type, bool initial_button_state)"><strong>createButton (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#createCalibrateDebevec(int samples , float lambda , bool random)"><strong>createCalibrateDebevec (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#createCalibrateRobertson(int max_iter , float threshold)"><strong>createCalibrateRobertson (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* cvCreateChildMemStorage(CvMemStorage* parent)"><strong>CreateChildMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#Ptr<cuda::CLAHE> createCLAHE(double clipLimit , Size tileGridSize)"><strong>createCLAHE (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#Ptr<ConjGradSolver> createConjGradSolver(const Ptr<Solver::Function>& f, TermCriteria termcrit)"><strong>createConjGradSolver (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#Ptr<Convolution> createConvolution(Size user_block_size)"><strong>createConvolution (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCreateData(CvArr* arr)"><strong>CreateData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#Ptr<DownhillSolver> createDownhillSolver(const Ptr<Solver::Function>& f,InputArray initStep, TermCriteria termcrit)"><strong>createDownhillSolver (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#Ptr<DTFilter> createDTFilter(InputArray guide, double sigmaSpatial, double sigmaColor, int mode , int numIters)"><strong>createDTFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.createDTFilter"><strong>createDTFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#Ptr<FaceRecognizer> createEigenFaceRecognizer(int num_components , double threshold)"><strong>createEigenFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#Ptr<ERFilter> createERFilterNM1(const Ptr<ERFilter::Callback>& cb, int thresholdDelta , float minArea , float maxArea , float minProbability , bool nonMaxSuppression , float minProbabilityDiff)"><strong>createERFilterNM1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#Ptr<ERFilter> createERFilterNM2(const Ptr<ERFilter::Callback>& cb, float minProbability)"><strong>createERFilterNM2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#Ptr<FeatureEvaluator> createFeatureEvaluator(const vector<vector<int>>& features, const string& type)"><strong>createFeatureEvaluator (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#Ptr<FaceRecognizer> createFisherFaceRecognizer(int num_components , double threshold)"><strong>createFisherFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph* cvCreateGraph(int graph_flags, int header_size, int vtx_size, int edge_size, CvMemStorage* storage)"><strong>CreateGraph (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphScanner* cvCreateGraphScanner(CvGraph* graph, CvGraphVtx* vtx, int mask)"><strong>CreateGraphScanner (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#Ptr<GuidedFilter> createGuidedFilter(InputArray guide, int radius, double eps)"><strong>createGuidedFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.createGuidedFilter"><strong>createGuidedFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void createHanningWindow(OutputArray dst, Size winSize, int type)"><strong>createHanningWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#CvHistogram* cvCreateHist(int dims, int* sizes, int type, float** ranges, int uniform)"><strong>CreateHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCreateImage(CvSize size, int depth, int channels)"><strong>CreateImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvCreateImageHeader(CvSize size, int depth, int channels)"><strong>CreateImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#CvKalman* cvCreateKalman(int dynam_params, int measure_params, int control_params)"><strong>CreateKalman (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#Ptr<FaceRecognizer> createLBPHFaceRecognizer(int radius, int neighbors, int grid_x, int grid_y, double threshold)"><strong>createLBPHFaceRecognizer (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#Ptr<LineSegmentDetector> createLineSegmentDetector(int _refine , double _scale , double _sigma_scale , double _quant , double _ang_th , double _log_eps , double _density_th , int _n_bins)"><strong>createLineSegmentDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.createLineSegmentDetector"><strong>createLineSegmentDetector() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.createLineSegmentDetector.compareSegments"><strong>createLineSegmentDetector.compareSegments() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.createLineSegmentDetector.detect"><strong>createLineSegmentDetector.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.createLineSegmentDetector.drawSegments"><strong>createLineSegmentDetector.drawSegments() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#Ptr<LookUpTable> createLookUpTable(InputArray lut)"><strong>createLookUpTable (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCreateMat(int rows, int cols, int type)"><strong>CreateMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvCreateMatHeader(int rows, int cols, int type)"><strong>CreateMatHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCreateMatND(int dims, const int* sizes, int type)"><strong>CreateMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvCreateMatNDHeader(int dims, const int* sizes, int type)"><strong>CreateMatNDHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* cvCreateMemStorage(int block_size)"><strong>CreateMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<MergeDebevec> createMergeDebevec()"><strong>createMergeDebevec (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<MergeMertens> createMergeMertens(float contrast_weight , float saturation_weight , float exposure_weight)"><strong>createMergeMertens (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<MergeRobertson> createMergeRobertson()"><strong>createMergeRobertson (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Ptr<DenseOpticalFlow> createOptFlow_DualTVL1()"><strong>createOptFlow_DualTVL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double epsilon"><strong>createOptFlow_DualTVL1::epsilon (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int iterations"><strong>createOptFlow_DualTVL1::iterations (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double lambda"><strong>createOptFlow_DualTVL1::lambda (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int nscales"><strong>createOptFlow_DualTVL1::nscales (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double tau"><strong>createOptFlow_DualTVL1::tau (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double theta"><strong>createOptFlow_DualTVL1::theta (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int warps"><strong>createOptFlow_DualTVL1::warps (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#Ptr<cv::bioinspired::Retina> createRetina(Size inputSize)"><strong>createRetina (C++ function)</strong></a>, <a href="modules/bioinspired/doc/retina.html#Ptr<cv::bioinspired::Retina> createRetina(Size inputSize, const bool colorMode, cv::bioinspired::RETINA_COLORSAMPLINGMETHOD colorSamplingMethod , const bool useRetinaLogSampling , const double reductionFactor , const double samplingStrenght)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvCreateSeq(int seq_flags, size_t header_size, size_t elem_size, CvMemStorage* storage)"><strong>CreateSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSet* cvCreateSet(int set_flags, int header_size, int elem_size, CvMemStorage* storage)"><strong>CreateSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat* cvCreateSparseMat(int dims, const int* sizes, int type)"><strong>CreateSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Ptr<StereoBM> createStereoBM(int numDisparities, int blockSize)"><strong>createStereoBM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.createStereoBM"><strong>createStereoBM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Ptr<StereoSGBM> createStereoSGBM(int minDisparity, int numDisparities, int blockSize, int P1, int P2, int disp12MaxDiff, int preFilterCap, int uniquenessRatio, int speckleWindowSize, int speckleRange, int mode)"><strong>createStereoSGBM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.createStereoSGBM"><strong>createStereoSGBM() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/structured_edge_detection.html#Ptr<cv::StructuredEdgeDetection> createStructuredEdgeDetection(String model)"><strong>createStructuredEdgeDetection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#IplConvKernel* cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, int* values)"><strong>CreateStructuringElementEx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<Tonemap> createTonemap(float gamma)"><strong>createTonemap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<TonemapDrago> createTonemapDrago(float gamma , float saturation , float bias)"><strong>createTonemapDrago (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<TonemapDurand> createTonemapDurand(float gamma , float contrast , float saturation , float sigma_space , float sigma_color)"><strong>createTonemapDurand (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<TonemapMantiuk> createTonemapMantiuk(float gamma , float scale , float saturation)"><strong>createTonemapMantiuk (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Ptr<TonemapReinhard> createTonemapReinhard(float gamma , float intensity , float light_adapt , float color_adapt)"><strong>createTonemapReinhard (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvCreateTrackbar(const char* trackbar_name, const char* window_name, int* value, int count, CvTrackbarCallback on_change)"><strong>CreateTrackbar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int createTrackbar(const String& trackbarname, const String& winname, int* value, int count, TrackbarCallback onChange, void* userdata)"><strong>createTrackbar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.createTrackbar"><strong>createTrackbar() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#CvVideoWriter* cvCreateVideoWriter(const char* filename, int fourcc, double fps, CvSize frame_size, int is_color)"><strong>CreateVideoWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#Ptr<WaldBoost> createWaldBoost(const WaldBoostParams& params)"><strong>createWaldBoost (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvCrossProduct(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>CrossProduct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cubeRoot(float val)"><strong>cubeRoot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.cubeRoot"><strong>cubeRoot() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::abs(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::abs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::absdiff(InputArray src1, InputArray src2, OutputArray dst, Stream& stream)"><strong>cuda::absdiff (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::absSum(InputArray src)"><strong>cuda::absSum (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::absSum(InputArray src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::absSum(InputArray src, InputArray mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::add(InputArray src1, InputArray src2, OutputArray dst, InputArray mask , int dtype , Stream& stream)"><strong>cuda::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype , Stream& stream)"><strong>cuda::addWeighted (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/color.html#void cuda::alphaComp(InputArray img1, InputArray img2, OutputArray dst, int alpha_op, Stream& stream)"><strong>cuda::alphaComp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#cuda::BackgroundSubtractorFGD : public cv::BackgroundSubtractor"><strong>cuda::BackgroundSubtractorFGD (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#void cuda::BackgroundSubtractorFGD::getForegroundRegions(OutputArrayOfArrays foreground_regions)"><strong>cuda::BackgroundSubtractorFGD::getForegroundRegions (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#cuda::BackgroundSubtractorGMG : public cv::BackgroundSubtractorGMG"><strong>cuda::BackgroundSubtractorGMG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#cuda::BackgroundSubtractorMOG : public cv::BackgroundSubtractorMOG"><strong>cuda::BackgroundSubtractorMOG (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#cuda::BackgroundSubtractorMOG2 : public cv::BackgroundSubtractorMOG2"><strong>cuda::BackgroundSubtractorMOG2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#cuda::BFMatcher_CUDA"><strong>cuda::BFMatcher_CUDA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatch(const GpuMat& query, const GpuMat& train, std::vector< std::vector<DMatch> >&matches, int k, const GpuMat& mask , bool compactResult)"><strong>cuda::BFMatcher_CUDA::knnMatch (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatch(const GpuMat& query, std::vector< std::vector<DMatch> >&matches, int k, const std::vector<GpuMat>&masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatch2Collection(const GpuMat& query, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& maskCollection , Stream& stream)"><strong>cuda::BFMatcher_CUDA::knnMatch2Collection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatch2Convert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::knnMatch2Convert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatch2Download(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::knnMatch2Download (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatchConvert(const Mat& trainIdx, const Mat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::knnMatchConvert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::knnMatchDownload (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::knnMatchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, GpuMat& allDist, int k, const GpuMat& mask , Stream& stream)"><strong>cuda::BFMatcher_CUDA::knnMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::makeGpuCollection(GpuMat& trainCollection, GpuMat& maskCollection, const vector<GpuMat>& masks)"><strong>cuda::BFMatcher_CUDA::makeGpuCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::match(const GpuMat& query, const GpuMat& train, std::vector<DMatch>& matches, const GpuMat& mask)"><strong>cuda::BFMatcher_CUDA::match (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::match(const GpuMat& query, std::vector<DMatch>& matches, const std::vector<GpuMat>& masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::matchCollection(const GpuMat& query, const GpuMat& trainCollection, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, const GpuMat& masks, Stream& stream)"><strong>cuda::BFMatcher_CUDA::matchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::matchConvert(const Mat& trainIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>cuda::BFMatcher_CUDA::matchConvert (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::matchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, std::vector<DMatch>&matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#static void cuda::BFMatcher_CUDA::matchDownload(const GpuMat& trainIdx, const GpuMat& distance, std::vector<DMatch>&matches)"><strong>cuda::BFMatcher_CUDA::matchDownload (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#static void cuda::BFMatcher_CUDA::matchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, std::vector<DMatch>& matches)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::matchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, const GpuMat& mask , Stream& stream)"><strong>cuda::BFMatcher_CUDA::matchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatch(const GpuMat& query, const GpuMat& train, std::vector< std::vector<DMatch> >&matches, float maxDistance, const GpuMat& mask , bool compactResult)"><strong>cuda::BFMatcher_CUDA::radiusMatch (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatch(const GpuMat& query, std::vector< std::vector<DMatch> >&matches, float maxDistance, const std::vector<GpuMat>& masks , bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchCollection(const GpuMat& query, GpuMat& trainIdx, GpuMat& imgIdx, GpuMat& distance, GpuMat& nMatches, float maxDistance, const std::vector<GpuMat>& masks , Stream& stream)"><strong>cuda::BFMatcher_CUDA::radiusMatchCollection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchConvert(const Mat& trainIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::radiusMatchConvert (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchConvert(const Mat& trainIdx, const Mat& imgIdx, const Mat& distance, const Mat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& distance, const GpuMat& nMatches, std::vector< std::vector<DMatch> >&matches, bool compactResult)"><strong>cuda::BFMatcher_CUDA::radiusMatchDownload (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchDownload(const GpuMat& trainIdx, const GpuMat& imgIdx, const GpuMat& distance, const GpuMat& nMatches, std::vector< std::vector<DMatch> >& matches, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::BFMatcher_CUDA::radiusMatchSingle(const GpuMat& query, const GpuMat& train, GpuMat& trainIdx, GpuMat& distance, GpuMat& nMatches, float maxDistance, const GpuMat& mask , Stream& stream)"><strong>cuda::BFMatcher_CUDA::radiusMatchSingle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::bilateralFilter(InputArray src, OutputArray dst, int kernel_size, float sigma_color, float sigma_spatial, int borderMode, Stream& stream)"><strong>cuda::bilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::bitwise_and(InputArray src1, InputArray src2, OutputArray dst, InputArray mask , Stream& stream)"><strong>cuda::bitwise_and (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::bitwise_not(InputArray src, OutputArray dst, InputArray mask , Stream& stream)"><strong>cuda::bitwise_not (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::bitwise_or(InputArray src1, InputArray src2, OutputArray dst, InputArray mask , Stream& stream)"><strong>cuda::bitwise_or (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::bitwise_xor(InputArray src1, InputArray src2, OutputArray dst, InputArray mask , Stream& stream)"><strong>cuda::bitwise_xor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::blendLinear(InputArray img1, InputArray img2, InputArray weights1, InputArray weights2, OutputArray result, Stream& stream)"><strong>cuda::blendLinear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#cuda::BroxOpticalFlow"><strong>cuda::BroxOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::buildWarpAffineMaps(InputArray M, bool inverse, Size dsize, OutputArray xmap, OutputArray ymap, Stream& stream)"><strong>cuda::buildWarpAffineMaps (C++ function)</strong></a>, <a href="modules/cudawarping/doc/warping.html#void cuda::buildWarpAffineMaps(InputArray M, bool inverse, Size dsize, OutputArray xmap, OutputArray ymap, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::buildWarpCylindricalMaps(Size src_size, Rect dst_roi, InputArray K, InputArray R, float scale, OutputArray map_x, OutputArray map_y, Stream& stream)"><strong>cuda::buildWarpCylindricalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::buildWarpPlaneMaps(Size src_size, Rect dst_roi, InputArray K, InputArray R, InputArray T, float scale, OutputArray map_x, OutputArray map_y, Stream& stream)"><strong>cuda::buildWarpPlaneMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::buildWarpSphericalMaps(Size src_size, Rect dst_roi, InputArray K, InputArray R, float scale, OutputArray map_x, OutputArray map_y, Stream& stream)"><strong>cuda::buildWarpSphericalMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::calcHist(InputArray src, OutputArray hist, Stream& stream)"><strong>cuda::calcHist (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#cuda::CannyEdgeDetector : public Algorithm"><strong>cuda::CannyEdgeDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::CannyEdgeDetector::detect(InputArray image, OutputArray edges)"><strong>cuda::CannyEdgeDetector::detect (C++ function)</strong></a>, <a href="modules/cudaimgproc/doc/imgproc.html#void cuda::CannyEdgeDetector::detect(InputArray dx, InputArray dy, OutputArray edges)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::cartToPolar(InputArray x, InputArray y, OutputArray magnitude, OutputArray angle, bool angleInDegrees , Stream& stream)"><strong>cuda::cartToPolar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#cuda::CascadeClassifier_CUDA"><strong>cuda::CascadeClassifier_CUDA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA(const String& filename)"><strong>cuda::CascadeClassifier_CUDA::CascadeClassifier_CUDA (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, double scaleFactor, int minNeighbors, Size minSize)"><strong>cuda::CascadeClassifier_CUDA::detectMultiScale (C++ function)</strong></a>, <a href="modules/cuda/doc/object_detection.html#int cuda::CascadeClassifier_CUDA::detectMultiScale(const GpuMat& image, GpuMat& objectsBuf, Size maxObjectSize, Size minSize , double scaleFactor , int minNeighbors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#bool cuda::CascadeClassifier_CUDA::empty() const"><strong>cuda::CascadeClassifier_CUDA::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#bool cuda::CascadeClassifier_CUDA::load(const String& filename)"><strong>cuda::CascadeClassifier_CUDA::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#void cuda::CascadeClassifier_CUDA::release()"><strong>cuda::CascadeClassifier_CUDA::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#cuda::CLAHE : public cv::CLAHE"><strong>cuda::CLAHE (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::CLAHE::apply(InputArray src, OutputArray dst)"><strong>cuda::CLAHE::apply (C++ function)</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::CLAHE::apply(InputArray src, OutputArray dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::compare(InputArray src1, InputArray src2, OutputArray dst, int cmpop, Stream& stream)"><strong>cuda::compare (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/cudaarithm/doc/arithm.html#cuda::Convolution : public Algorithm"><strong>cuda::Convolution (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#void cuda::Convolution::convolve(InputArray image, InputArray templ, OutputArray result, bool ccorr , Stream& stream)"><strong>cuda::Convolution::convolve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::copyMakeBorder(InputArray src, OutputArray dst, int top, int bottom, int left, int right, int borderType, Scalar value , Stream& stream)"><strong>cuda::copyMakeBorder (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#cuda::CornernessCriteria : public Algorithm"><strong>cuda::CornernessCriteria (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#void cuda::CornernessCriteria::compute(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::CornernessCriteria::compute (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#cuda::CornersDetector : public Algorithm"><strong>cuda::CornersDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#void cuda::CornersDetector::detect(InputArray image, OutputArray corners, InputArray mask)"><strong>cuda::CornersDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#int cuda::countNonZero(InputArray src)"><strong>cuda::countNonZero (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#int cuda::countNonZero(InputArray src, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#Ptr<cuda::BackgroundSubtractorGMG> cuda::createBackgroundSubtractorFGD(const FGDParams& params)"><strong>cuda::createBackgroundSubtractorFGD (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#Ptr<cuda::BackgroundSubtractorGMG> cuda::createBackgroundSubtractorGMG(int initializationFrames , double decisionThreshold)"><strong>cuda::createBackgroundSubtractorGMG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#Ptr<cuda::BackgroundSubtractorMOG> cuda::createBackgroundSubtractorMOG(int history, int nmixtures, double backgroundRatio, double noiseSigma)"><strong>cuda::createBackgroundSubtractorMOG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudabgsegm/doc/background_segmentation.html#Ptr<cuda::BackgroundSubtractorMOG2> cuda::createBackgroundSubtractorMOG2(int history, double varThreshold, bool detectShadows)"><strong>cuda::createBackgroundSubtractorMOG2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createBoxFilter(int srcType, int dstType, Size ksize, Point anchor , int borderMode , Scalar borderVal)"><strong>cuda::createBoxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createBoxMaxFilter(int srcType, Size ksize, Point anchor , int borderMode , Scalar borderVal)"><strong>cuda::createBoxMaxFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createBoxMinFilter(int srcType, Size ksize, Point anchor , int borderMode , Scalar borderVal)"><strong>cuda::createBoxMinFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#Ptr<CannyEdgeDetector> cuda::createCannyEdgeDetector(double low_thresh, double high_thresh, int apperture_size , bool L2gradient)"><strong>cuda::createCannyEdgeDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createColumnSumFilter(int srcType, int dstType, int ksize, int anchor , int borderMode , Scalar borderVal)"><strong>cuda::createColumnSumFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::createContinuous(int rows, int cols, int type, OutputArray arr)"><strong>cuda::createContinuous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createDerivFilter(int srcType, int dstType, int dx, int dy, int ksize, bool normalize , double scale , int rowBorderMode , int columnBorderMode)"><strong>cuda::createDerivFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#Ptr<cuda::DisparityBilateralFilter> cuda::createDisparityBilateralFilter(int ndisp , int radius , int iters)"><strong>cuda::createDisparityBilateralFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createGaussianFilter(int srcType, int dstType, Size ksize, double sigma1, double sigma2 , int rowBorderMode , int columnBorderMode)"><strong>cuda::createGaussianFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#Ptr<GeneralizedHoughBallard> cuda::createGeneralizedHoughBallard()"><strong>cuda::createGeneralizedHoughBallard (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#Ptr<GeneralizedHoughGuil> cuda::createGeneralizedHoughGuil()"><strong>cuda::createGeneralizedHoughGuil (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#Ptr<CornersDetector> cuda::createGoodFeaturesToTrackDetector(int srcType, int maxCorners , double qualityLevel , double minDistance , int blockSize , bool useHarrisDetector , double harrisK)"><strong>cuda::createGoodFeaturesToTrackDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#Ptr<CornernessCriteria> cuda::createHarrisCorner(int srcType, int blockSize, int ksize, double k, int borderType)"><strong>cuda::createHarrisCorner (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#Ptr<HoughCirclesDetector> cuda::createHoughCirclesDetector(float dp, float minDist, int cannyThreshold, int votesThreshold, int minRadius, int maxRadius, int maxCircles)"><strong>cuda::createHoughCirclesDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#Ptr<HoughLinesDetector> cuda::createHoughLinesDetector(float rho, float theta, int threshold, bool doSort , int maxLines)"><strong>cuda::createHoughLinesDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#Ptr<HoughSegmentDetector> cuda::createHoughSegmentDetector(float rho, float theta, int minLineLength, int maxLineGap, int maxLines)"><strong>cuda::createHoughSegmentDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createLaplacianFilter(int srcType, int dstType, int ksize , double scale , int borderMode , Scalar borderVal)"><strong>cuda::createLaplacianFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createLinearFilter(int srcType, int dstType, InputArray kernel, Point anchor , int borderMode , Scalar borderVal)"><strong>cuda::createLinearFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/feature_detection.html#Ptr<CornernessCriteria> cuda::createMinEigenValCorner(int srcType, int blockSize, int ksize, int borderType)"><strong>cuda::createMinEigenValCorner (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createMorphologyFilter(int op, int srcType, InputArray kernel, Point anchor , int iterations)"><strong>cuda::createMorphologyFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createRowSumFilter(int srcType, int dstType, int ksize, int anchor , int borderMode , Scalar borderVal)"><strong>cuda::createRowSumFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createScharrFilter(int srcType, int dstType, int dx, int dy, double scale , int rowBorderMode , int columnBorderMode)"><strong>cuda::createScharrFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createSeparableLinearFilter(int srcType, int dstType, InputArray rowKernel, InputArray columnKernel, Point anchor , int rowBorderMode , int columnBorderMode)"><strong>cuda::createSeparableLinearFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#Ptr<Filter> cuda::createSobelFilter(int srcType, int dstType, int dx, int dy, int ksize , double scale , int rowBorderMode , int columnBorderMode)"><strong>cuda::createSobelFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#Ptr<cuda::StereoBeliefPropagation> cuda::createStereoBeliefPropagation(int ndisp , int iters , int levels , int msg_type)"><strong>cuda::createStereoBeliefPropagation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#Ptr<cuda::StereoBM> cuda::createStereoBM(int numDisparities , int blockSize)"><strong>cuda::createStereoBM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#Ptr<cuda::StereoConstantSpaceBP> cuda::createStereoConstantSpaceBP(int ndisp , int iters , int levels , int nr_plane , int msg_type)"><strong>cuda::createStereoConstantSpaceBP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#Ptr<TemplateMatching> cuda::createTemplateMatching(int srcType, int method, Size user_block_size)"><strong>cuda::createTemplateMatching (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::CudaMem"><strong>cuda::CudaMem (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#GpuMat cuda::CudaMem::createGpuMatHeader() const"><strong>cuda::CudaMem::createGpuMatHeader (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#Mat cuda::CudaMem::createMatHeader() const"><strong>cuda::CudaMem::createMatHeader (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/color.html#void cuda::cvtColor(InputArray src, OutputArray dst, int code, int dcn , Stream& stream)"><strong>cuda::cvtColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/color.html#void cuda::demosaicing(InputArray src, OutputArray dst, int code, int dcn , Stream& stream)"><strong>cuda::demosaicing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#cuda::DeviceInfo"><strong>cuda::DeviceInfo (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#int cuda::DeviceInfo::deviceID()"><strong>cuda::DeviceInfo::deviceID (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#cuda::DeviceInfo::DeviceInfo()"><strong>cuda::DeviceInfo::DeviceInfo (C++ function)</strong></a>, <a href="modules/cuda/doc/initalization_and_information.html#cuda::DeviceInfo::DeviceInfo(int device_id)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#size_t cuda::DeviceInfo::freeMemory()"><strong>cuda::DeviceInfo::freeMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#bool cuda::DeviceInfo::isCompatible()"><strong>cuda::DeviceInfo::isCompatible (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#int cuda::DeviceInfo::majorVersion()"><strong>cuda::DeviceInfo::majorVersion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#int cuda::DeviceInfo::minorVersion()"><strong>cuda::DeviceInfo::minorVersion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#const char* cuda::DeviceInfo::name() const"><strong>cuda::DeviceInfo::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#bool cuda::DeviceInfo::supports(FeatureSet feature_set) const"><strong>cuda::DeviceInfo::supports (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#size_t cuda::DeviceInfo::totalMemory()"><strong>cuda::DeviceInfo::totalMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#void cuda::dft(InputArray src, OutputArray dst, Size dft_size, int flags, Stream& stream)"><strong>cuda::dft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#cuda::DisparityBilateralFilter : public cv::Algorithm"><strong>cuda::DisparityBilateralFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::DisparityBilateralFilter::apply(InputArray disparity, InputArray image, OutputArray dst, Stream& stream)"><strong>cuda::DisparityBilateralFilter::apply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::divide(InputArray src1, InputArray src2, OutputArray dst, double scale , int dtype , Stream& stream)"><strong>cuda::divide (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/element_operations.html#void cuda::divide(double src1, InputArray src2, OutputArray dst, int dtype , Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::drawColorDisp(InputArray src_disp, OutputArray dst_disp, int ndisp, Stream& stream)"><strong>cuda::drawColorDisp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::ensureSizeIsEnough(int rows, int cols, int type, OutputArray arr)"><strong>cuda::ensureSizeIsEnough (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::equalizeHist(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::equalizeHist (C++ function)</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::equalizeHist(InputArray src, OutputArray dst, InputOutputArray buf, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::evenLevels(OutputArray levels, int nLevels, int lowerLevel, int upperLevel)"><strong>cuda::evenLevels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::exp(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::exp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#cuda::FarnebackOpticalFlow"><strong>cuda::FarnebackOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::FarnebackOpticalFlow::operator ()(const GpuMat &frame0, const GpuMat &frame1, GpuMat &flowx, GpuMat &flowy, Stream &s)"><strong>cuda::FarnebackOpticalFlow::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::FarnebackOpticalFlow::releaseMemory()"><strong>cuda::FarnebackOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#cuda::FAST_CUDA"><strong>cuda::FAST_CUDA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#int cuda::FAST_CUDA::calcKeyPointsLocation(const GpuMat& image, const GpuMat& mask)"><strong>cuda::FAST_CUDA::calcKeyPointsLocation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::FAST_CUDA::convertKeypoints(const Mat& h_keypoints, std::vector<KeyPoint>& keypoints)"><strong>cuda::FAST_CUDA::convertKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::FAST_CUDA::downloadKeypoints(const GpuMat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>cuda::FAST_CUDA::downloadKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#cuda::FAST_CUDA::FAST_CUDA(int threshold, bool nonmaxSuppression , double keypointsRatio)"><strong>cuda::FAST_CUDA::FAST_CUDA (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#int cuda::FAST_CUDA::getKeyPoints(GpuMat& keypoints)"><strong>cuda::FAST_CUDA::getKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::FAST_CUDA::operator ()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints)"><strong>cuda::FAST_CUDA::operator() (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::FAST_CUDA::operator ()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::FAST_CUDA::release()"><strong>cuda::FAST_CUDA::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#cuda::FastNonLocalMeansDenoising"><strong>cuda::FastNonLocalMeansDenoising (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void cuda::FastNonLocalMeansDenoising::labMethod(const GpuMat& src, GpuMat& dst, float h_luminance, float h_color, int search_window , int block_size , Stream& s)"><strong>cuda::FastNonLocalMeansDenoising::labMethod (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void cuda::FastNonLocalMeansDenoising::simpleMethod(const GpuMat& src, GpuMat& dst, float h, int search_window , int block_size , Stream& s)"><strong>cuda::FastNonLocalMeansDenoising::simpleMethod (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#cuda::FeatureSet"><strong>cuda::FeatureSet (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#cuda::Filter"><strong>cuda::Filter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafilters/doc/filtering.html#void cuda::Filter::apply(InputArray src, OutputArray dst, Stream& stream) = 0"><strong>cuda::Filter::apply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::flip(InputArray src, OutputArray dst, int flipCode, Stream& stream)"><strong>cuda::flip (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/color.html#void cuda::gammaCorrection(InputArray src, OutputArray dst, bool forward , Stream& stream)"><strong>cuda::gammaCorrection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#void cuda::gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags , Stream& stream)"><strong>cuda::gemm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#int cuda::getCudaEnabledDeviceCount()"><strong>cuda::getCudaEnabledDeviceCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#int cuda::getDevice()"><strong>cuda::getDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::GpuMat"><strong>cuda::GpuMat (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::histEven(InputArray src, OutputArray hist, int histSize, int lowerLevel, int upperLevel, Stream& stream)"><strong>cuda::histEven (C++ function)</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histEven(InputArray src, OutputArray hist, InputOutputArray buf, int histSize, int lowerLevel, int upperLevel, Stream& stream)"><strong>[1]</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histEven(InputArray src, GpuMat hist[4], int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream)"><strong>[2]</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histEven(InputArray src, GpuMat hist[4], InputOutputArray buf, int histSize[4], int lowerLevel[4], int upperLevel[4], Stream& stream)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/histogram.html#void cuda::histRange(InputArray src, OutputArray hist, InputArray levels, Stream& stream)"><strong>cuda::histRange (C++ function)</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histRange(InputArray src, OutputArray hist, InputArray levels, InputOutputArray buf, Stream& stream)"><strong>[1]</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histRange(InputArray src, GpuMat hist[4], const GpuMat levels[4], Stream& stream)"><strong>[2]</strong></a>, <a href="modules/cudaimgproc/doc/histogram.html#void cuda::histRange(InputArray src, GpuMat hist[4], const GpuMat levels[4], InputOutputArray buf, Stream& stream)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#cuda::HOGDescriptor"><strong>cuda::HOGDescriptor (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#void cuda::HOGDescriptor::detect(const GpuMat& img, vector<Point>& found_locations, double hit_threshold, Size win_stride, Size padding)"><strong>cuda::HOGDescriptor::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#void cuda::HOGDescriptor::detectMultiScale(const GpuMat& img, vector<Rect>& found_locations, double hit_threshold, Size win_stride, Size padding, double scale0, int group_threshold)"><strong>cuda::HOGDescriptor::detectMultiScale (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#size_t cuda::HOGDescriptor::getBlockHistogramSize() const"><strong>cuda::HOGDescriptor::getBlockHistogramSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#static vector<float> cuda::HOGDescriptor::getDefaultPeopleDetector()"><strong>cuda::HOGDescriptor::getDefaultPeopleDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#void cuda::HOGDescriptor::getDescriptors(const GpuMat& img, Size win_stride, GpuMat& descriptors, int descr_format)"><strong>cuda::HOGDescriptor::getDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#size_t cuda::HOGDescriptor::getDescriptorSize() const"><strong>cuda::HOGDescriptor::getDescriptorSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#static vector<float> cuda::HOGDescriptor::getPeopleDetector48x96()"><strong>cuda::HOGDescriptor::getPeopleDetector48x96 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#static vector<float> cuda::HOGDescriptor::getPeopleDetector64x128()"><strong>cuda::HOGDescriptor::getPeopleDetector64x128 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#cuda::HOGDescriptor::HOGDescriptor(Size win_size, Size block_size, Size block_stride, Size cell_size, int nbins, double win_sigma, double threshold_L2hys, bool gamma_correction, int nlevels)"><strong>cuda::HOGDescriptor::HOGDescriptor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/object_detection.html#void cuda::HOGDescriptor::setSVMDetector(const vector<float>& detector)"><strong>cuda::HOGDescriptor::setSVMDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#cuda::HoughCirclesDetector : public Algorithm"><strong>cuda::HoughCirclesDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#void cuda::HoughCirclesDetector::detect(InputArray src, OutputArray circles)"><strong>cuda::HoughCirclesDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#cuda::HoughLinesDetector : public Algorithm"><strong>cuda::HoughLinesDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#void cuda::HoughLinesDetector::detect(InputArray src, OutputArray lines)"><strong>cuda::HoughLinesDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#void cuda::HoughLinesDetector::downloadResults(InputArray d_lines, OutputArray h_lines, OutputArray h_votes)"><strong>cuda::HoughLinesDetector::downloadResults (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#cuda::HoughSegmentDetector : public Algorithm"><strong>cuda::HoughSegmentDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/hough.html#void cuda::HoughSegmentDetector::detect(InputArray src, OutputArray lines)"><strong>cuda::HoughSegmentDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::integral(InputArray src, OutputArray sum, Stream& stream)"><strong>cuda::integral (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::integral(InputArray src, OutputArray sum, GpuMat& buffer, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::interpolateFrames(const GpuMat& frame0, const GpuMat& frame1, const GpuMat& fu, const GpuMat& fv, const GpuMat& bu, const GpuMat& bv, float pos, GpuMat& newFrame, GpuMat& buf, Stream& stream)"><strong>cuda::interpolateFrames (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::log(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::log (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#cuda::LookUpTable : public Algorithm"><strong>cuda::LookUpTable (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::LookUpTable::transform(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::LookUpTable::transform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::lshift(InputArray src, Scalar_<int> val, OutputArray dst, Stream& stream)"><strong>cuda::lshift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::magnitude(InputArray xy, OutputArray magnitude, Stream& stream)"><strong>cuda::magnitude (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/element_operations.html#void cuda::magnitude(InputArray x, InputArray y, OutputArray magnitude, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::magnitudeSqr(InputArray xy, OutputArray magnitude, Stream& stream)"><strong>cuda::magnitudeSqr (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/element_operations.html#void cuda::magnitudeSqr(InputArray x, InputArray y, OutputArray magnitude, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::max(InputArray src1, InputArray src2, OutputArray dst, Stream& stream)"><strong>cuda::max (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::meanShiftFiltering(InputArray src, OutputArray dst, int sp, int sr, TermCriteria criteria , Stream& stream)"><strong>cuda::meanShiftFiltering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::meanShiftProc(InputArray src, OutputArray dstr, OutputArray dstsp, int sp, int sr, TermCriteria criteria , Stream& stream)"><strong>cuda::meanShiftProc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::meanShiftSegmentation(InputArray src, OutputArray dst, int sp, int sr, int minsize, TermCriteria criteria)"><strong>cuda::meanShiftSegmentation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::meanStdDev(InputArray mtx, Scalar& mean, Scalar& stddev)"><strong>cuda::meanStdDev (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::meanStdDev(InputArray mtx, Scalar& mean, Scalar& stddev, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::merge(const GpuMat* src, size_t n, OutputArray dst, Stream& stream)"><strong>cuda::merge (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/core.html#void cuda::merge(const std::vector<GpuMat>& src, OutputArray dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::min(InputArray src1, InputArray src2, OutputArray dst, Stream& stream)"><strong>cuda::min (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::minMax(InputArray src, double* minVal, double* maxVal, InputArray mask)"><strong>cuda::minMax (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::minMax(InputArray src, double* minVal, double* maxVal, InputArray mask, GpuMat& buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><strong>cuda::minMaxLoc (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask, GpuMat& valbuf, GpuMat& locbuf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#void cuda::mulAndScaleSpectrums(InputArray src1, InputArray src2, OutputArray dst, int flags, float scale, bool conjB, Stream& stream)"><strong>cuda::mulAndScaleSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/arithm.html#void cuda::mulSpectrums(InputArray src1, InputArray src2, OutputArray dst, int flags, bool conjB, Stream& stream)"><strong>cuda::mulSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::multiply(InputArray src1, InputArray src2, OutputArray dst, double scale , int dtype , Stream& stream)"><strong>cuda::multiply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void cuda::nonLocalMeans(const GpuMat& src, GpuMat& dst, float h, int search_window , int block_size , int borderMode , Stream& s)"><strong>cuda::nonLocalMeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#double cuda::norm(InputArray src1, int normType)"><strong>cuda::norm (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#double cuda::norm(InputArray src1, int normType, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#double cuda::norm(InputArray src1, int normType, InputArray mask, GpuMat& buf)"><strong>[2]</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#double cuda::norm(InputArray src1, InputArray src2, int normType)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::normalize(InputArray src, OutputArray dst, double alpha , double beta , int norm_type , int dtype , InputArray mask)"><strong>cuda::normalize (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::normalize(InputArray src, OutputArray dst, double alpha, double beta, int norm_type, int dtype, InputArray mask, GpuMat& norm_buf, GpuMat& cvt_buf)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#cuda::ORB_CUDA"><strong>cuda::ORB_CUDA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#static void cuda::ORB_CUDA::convertKeyPoints(const Mat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>cuda::ORB_CUDA::convertKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#static void cuda::ORB_CUDA::downloadKeyPoints(const GpuMat& d_keypoints, std::vector<KeyPoint>& keypoints)"><strong>cuda::ORB_CUDA::downloadKeyPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::ORB_CUDA::operator()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints)"><strong>cuda::ORB_CUDA::operator() (C++ function)</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::ORB_CUDA::operator()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints)"><strong>[1]</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::ORB_CUDA::operator()(const GpuMat& image, const GpuMat& mask, std::vector<KeyPoint>& keypoints, GpuMat& descriptors)"><strong>[2]</strong></a>, <a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::ORB_CUDA::operator()(const GpuMat& image, const GpuMat& mask, GpuMat& keypoints, GpuMat& descriptors)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#cuda::ORB_CUDA::ORB_CUDA(int nFeatures , float scaleFactor , int nLevels , int edgeThreshold , int firstLevel , int WTA_K , int scoreType , int patchSize)"><strong>cuda::ORB_CUDA::ORB_CUDA (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudafeatures2d/doc/feature_detection_and_description.html#void cuda::ORB_CUDA::release()"><strong>cuda::ORB_CUDA::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees , Stream& stream)"><strong>cuda::phase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees , Stream& stream)"><strong>cuda::polarToCart (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::pow(InputArray src, double power, OutputArray dst, Stream& stream)"><strong>cuda::pow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::PtrStep"><strong>cuda::PtrStep (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::PtrStepSz"><strong>cuda::PtrStepSz (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::pyrDown(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::pyrDown (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#cuda::PyrLKOpticalFlow"><strong>cuda::PyrLKOpticalFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::PyrLKOpticalFlow::dense(const GpuMat& prevImg, const GpuMat& nextImg, GpuMat& u, GpuMat& v, GpuMat* err)"><strong>cuda::PyrLKOpticalFlow::dense (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::PyrLKOpticalFlow::releaseMemory()"><strong>cuda::PyrLKOpticalFlow::releaseMemory (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaoptflow/doc/optflow.html#void cuda::PyrLKOpticalFlow::sparse(const GpuMat& prevImg, const GpuMat& nextImg, const GpuMat& prevPts, GpuMat& nextPts, GpuMat& status, GpuMat* err)"><strong>cuda::PyrLKOpticalFlow::sparse (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::pyrUp(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::pyrUp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::rectStdDev(InputArray src, InputArray sqr, OutputArray dst, Rect rect, Stream& stream)"><strong>cuda::rectStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::reduce(InputArray mtx, OutputArray vec, int dim, int reduceOp, int dtype , Stream& stream)"><strong>cuda::reduce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::registerPageLocked(Mat& m)"><strong>cuda::registerPageLocked (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::remap(InputArray src, OutputArray dst, InputArray xmap, InputArray ymap, int interpolation, int borderMode , Scalar borderValue , Stream& stream)"><strong>cuda::remap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::reprojectImageTo3D(InputArray disp, OutputArray xyzw, InputArray Q, int dst_cn , Stream& stream)"><strong>cuda::reprojectImageTo3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#void cuda::resetDevice()"><strong>cuda::resetDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation , Stream& stream)"><strong>cuda::resize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::rotate(InputArray src, OutputArray dst, Size dsize, double angle, double xShift , double yShift , int interpolation , Stream& stream)"><strong>cuda::rotate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::rshift(InputArray src, Scalar_<int> val, OutputArray dst, Stream& stream)"><strong>cuda::rshift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#void cuda::setDevice(int device)"><strong>cuda::setDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void cuda::setGlDevice(int device)"><strong>cuda::setGlDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/calib3d.html#void cuda::solvePnPRansac(const Mat& object, const Mat& image, const Mat& camera_mat, const Mat& dist_coef, Mat& rvec, Mat& tvec, bool use_extrinsic_guess, int num_iters, float max_dist, int min_inlier_count, vector<int>* inliers)"><strong>cuda::solvePnPRansac (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::split(InputArray src, GpuMat* dst, Stream& stream)"><strong>cuda::split (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/core.html#void cuda::split(InputArray src, vector<GpuMat>& dst, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::sqr(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::sqr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#void cuda::sqrIntegral(InputArray src, OutputArray sqsum, Stream& stream)"><strong>cuda::sqrIntegral (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#void cuda::sqrIntegral(InputArray src, OutputArray sqsum, GpuMat& buf, Stream& stream)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sqrSum(InputArray src)"><strong>cuda::sqrSum (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sqrSum(InputArray src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sqrSum(InputArray src, InputArray mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::sqrt(InputArray src, OutputArray dst, Stream& stream)"><strong>cuda::sqrt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#cuda::StereoBeliefPropagation : public cv::StereoMatcher"><strong>cuda::StereoBeliefPropagation (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::StereoBeliefPropagation::compute(InputArray data, OutputArray disparity, Stream& stream)"><strong>cuda::StereoBeliefPropagation::compute (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::StereoBeliefPropagation::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels)"><strong>cuda::StereoBeliefPropagation::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#cuda::StereoBM : public cv::StereoBM"><strong>cuda::StereoBM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#cuda::StereoConstantSpaceBP : public cuda::StereoBeliefPropagation"><strong>cuda::StereoConstantSpaceBP (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudastereo/doc/stereo.html#void cuda::StereoConstantSpaceBP::estimateRecommendedParams(int width, int height, int& ndisp, int& iters, int& levels, int& nr_plane)"><strong>cuda::StereoConstantSpaceBP::estimateRecommendedParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::Stream"><strong>cuda::Stream (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::Stream::enqueueHostCallback(StreamCallback callback, void* userData)"><strong>cuda::Stream::enqueueHostCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#bool cuda::Stream::queryIfComplete()"><strong>cuda::Stream::queryIfComplete (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::Stream::waitEvent(const Event& event)"><strong>cuda::Stream::waitEvent (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::Stream::waitForCompletion()"><strong>cuda::Stream::waitForCompletion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#cuda::StreamAccessor"><strong>cuda::StreamAccessor (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#void cuda::subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask , int dtype , Stream& stream)"><strong>cuda::subtract (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sum(InputArray src)"><strong>cuda::sum (C++ function)</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sum(InputArray src, GpuMat& buf)"><strong>[1]</strong></a>, <a href="modules/cudaarithm/doc/reductions.html#Scalar cuda::sum(InputArray src, InputArray mask, GpuMat& buf)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cuda::SURF_CUDA"><strong>cuda::SURF_CUDA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/color.html#void cuda::swapChannels(InputOutputArray image, const int dstOrder[4], Stream& stream)"><strong>cuda::swapChannels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#cuda::TargetArchs"><strong>cuda::TargetArchs (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::builtWith(FeatureSet feature_set)"><strong>cuda::TargetArchs::builtWith (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::has(int major, int minor)"><strong>cuda::TargetArchs::has (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasBin(int major, int minor)"><strong>cuda::TargetArchs::hasBin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasEqualOrGreater(int major, int minor)"><strong>cuda::TargetArchs::hasEqualOrGreater (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasEqualOrGreaterBin(int major, int minor)"><strong>cuda::TargetArchs::hasEqualOrGreaterBin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasEqualOrGreaterPtx(int major, int minor)"><strong>cuda::TargetArchs::hasEqualOrGreaterPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasEqualOrLessPtx(int major, int minor)"><strong>cuda::TargetArchs::hasEqualOrLessPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/initalization_and_information.html#static bool cuda::TargetArchs::hasPtx(int major, int minor)"><strong>cuda::TargetArchs::hasPtx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#cuda::TemplateMatching : public Algorithm"><strong>cuda::TemplateMatching (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaimgproc/doc/imgproc.html#void cuda::TemplateMatching::match(InputArray image, InputArray templ, OutputArray result, Stream& stream)"><strong>cuda::TemplateMatching::match (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/element_operations.html#double cuda::threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type, Stream& stream)"><strong>cuda::threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudaarithm/doc/core.html#void cuda::transpose(InputArray src1, OutputArray dst, Stream& stream)"><strong>cuda::transpose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cuda/doc/data_structures.html#void cuda::unregisterPageLocked(Mat& m)"><strong>cuda::unregisterPageLocked (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags , int borderMode , Scalar borderValue , Stream& stream)"><strong>cuda::warpAffine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudawarping/doc/warping.html#void cuda::warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags , int borderMode , Scalar borderValue , Stream& stream)"><strong>cuda::warpPerspective (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#cudacodec::ChromaFormat"><strong>cudacodec::ChromaFormat (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#cudacodec::Codec"><strong>cudacodec::Codec (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#Ptr<VideoReader> cudacodec::createVideoReader(const String& filename)"><strong>cudacodec::createVideoReader (C++ function)</strong></a>, <a href="modules/cudacodec/doc/videodec.html#Ptr<VideoReader> cudacodec::createVideoReader(const Ptr<RawVideoSource>& source)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#Ptr<cudacodec::VideoWriter> cudacodec::createVideoWriter(const String& fileName, Size frameSize, double fps, SurfaceFormat format)"><strong>cudacodec::createVideoWriter (C++ function)</strong></a>, <a href="modules/cudacodec/doc/videoenc.html#Ptr<cudacodec::VideoWriter> cudacodec::createVideoWriter(const String& fileName, Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[1]</strong></a>, <a href="modules/cudacodec/doc/videoenc.html#Ptr<cudacodec::VideoWriter> cudacodec::createVideoWriter(const Ptr<EncoderCallBack>& encoderCallback, Size frameSize, double fps, SurfaceFormat format)"><strong>[2]</strong></a>, <a href="modules/cudacodec/doc/videoenc.html#Ptr<cudacodec::VideoWriter> cudacodec::createVideoWriter(const Ptr<EncoderCallBack>& encoderCallback, Size frameSize, double fps, const EncoderParams& params, SurfaceFormat format)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#cudacodec::EncoderCallBack"><strong>cudacodec::EncoderCallBack (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#virtual uchar* cudacodec::EncoderCallBack::acquireBitStream(int* bufferSize) = 0"><strong>cudacodec::EncoderCallBack::acquireBitStream (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#virtual void cudacodec::EncoderCallBack::onBeginFrame(int frameNumber, PicType picType) = 0"><strong>cudacodec::EncoderCallBack::onBeginFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#virtual void cudacodec::EncoderCallBack::onEndFrame(int frameNumber, PicType picType) = 0"><strong>cudacodec::EncoderCallBack::onEndFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#virtual void cudacodec::EncoderCallBack::releaseBitStream(unsigned char* data, int size) = 0"><strong>cudacodec::EncoderCallBack::releaseBitStream (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#cudacodec::EncoderParams"><strong>cudacodec::EncoderParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#cudacodec::EncoderParams::EncoderParams()"><strong>cudacodec::EncoderParams::EncoderParams (C++ function)</strong></a>, <a href="modules/cudacodec/doc/videoenc.html#cudacodec::EncoderParams::EncoderParams(const String& configFile)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#void cudacodec::EncoderParams::load(const String& configFile)"><strong>cudacodec::EncoderParams::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#void cudacodec::EncoderParams::save(const String& configFile) const"><strong>cudacodec::EncoderParams::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#cudacodec::FormatInfo"><strong>cudacodec::FormatInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#cudacodec::RawVideoSource"><strong>cudacodec::RawVideoSource (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#virtual FormatInfo cudacodec::RawVideoSource::format() const = 0"><strong>cudacodec::RawVideoSource::format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#cudacodec::VideoReader"><strong>cudacodec::VideoReader (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#FormatInfo cudacodec::VideoReader::format() const"><strong>cudacodec::VideoReader::format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#bool cudacodec::VideoReader::nextFrame(OutputArray frame)"><strong>cudacodec::VideoReader::nextFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videodec.html#bool cudacodec::VideoSource::getNextPacket(unsigned char** data, int* size, bool* endOfFile) = 0"><strong>cudacodec::VideoSource::getNextPacket (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#cudacodec::VideoWriter"><strong>cudacodec::VideoWriter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/cudacodec/doc/videoenc.html#void cudacodec::VideoWriter::write(InputArray frame, bool lastFrame) = 0"><strong>cudacodec::VideoWriter::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#CV_Assert(expr)"><strong>CV_Assert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvArr"><strong>CvArr (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat cvarrToMat(const CvArr* arr, bool copyData, bool allowND, int coiMode, AutoBuffer<double>* buf)"><strong>cvarrToMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvAttrList"><strong>CvAttrList (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvBox2D"><strong>CvBox2D (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#float angle"><strong>CvBox2D::angle (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f center"><strong>CvBox2D::center (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f size"><strong>CvBox2D::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode"><strong>CvFileNode (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#union data"><strong>CvFileNode::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* info"><strong>CvFileNode::info (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int tag"><strong>CvFileNode::tag (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileStorage"><strong>CvFileStorage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraph"><strong>CvGraph (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge"><strong>CvGraphEdge (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphScanner"><strong>CvGraphScanner (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphVtx"><strong>CvGraphVtx (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat"><strong>CvMat (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cols"><strong>CvMat::cols (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#union data"><strong>CvMat::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvMat::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int rows"><strong>CvMat::rows (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int step"><strong>CvMat::step (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvMat::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND"><strong>CvMatND (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#union data"><strong>CvMatND::data (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#array dim"><strong>CvMatND::dim (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dims"><strong>CvMatND::dims (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvMatND::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvMatND::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock"><strong>CvMemBlock (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage"><strong>CvMemStorage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int block_size"><strong>CvMemStorage::block_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock* bottom"><strong>CvMemStorage::bottom (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int free_space"><strong>CvMemStorage::free_space (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* parent"><strong>CvMemStorage::parent (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemBlock* top"><strong>CvMemStorage::top (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStoragePos"><strong>CvMemStoragePos (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint"><strong>CvPoint (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f"><strong>CvPoint2D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D64f"><strong>CvPoint2D64f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D32f"><strong>CvPoint3D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D64f"><strong>CvPoint3D64f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect"><strong>CvRect (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar"><strong>CvScalar (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double[4] val"><strong>CvScalar::val (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq"><strong>CvSeq (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int elem_size"><strong>CvSeq::elem_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeqBlock* first"><strong>CvSeq::first (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int flags"><strong>CvSeq::flags (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* h_next"><strong>CvSeq::h_next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* h_prev"><strong>CvSeq::h_prev (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int header_size"><strong>CvSeq::header_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvMemStorage* storage"><strong>CvSeq::storage (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int total"><strong>CvSeq::total (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* v_next"><strong>CvSeq::v_next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* v_prev"><strong>CvSeq::v_prev (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSet"><strong>CvSet (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem"><strong>CvSetElem (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize"><strong>CvSize (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f"><strong>CvSize2D32f (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSlice"><strong>CvSlice (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int end_index"><strong>CvSlice::end_index (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int start_index"><strong>CvSlice::start_index (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseMat"><strong>CvSparseMat (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dims"><strong>CvSparseMat::dims (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int hashsize"><strong>CvSparseMat::hashsize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void** hashtable"><strong>CvSparseMat::hashtable (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSet* heap"><strong>CvSparseMat::heap (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int* refcount"><strong>CvSparseMat::refcount (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] size"><strong>CvSparseMat::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvSparseMat::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvCvtColor(const CvArr* src, CvArr* dst, int code)"><strong>CvtColor (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvtColor(InputArray src, OutputArray dst, int code, int dstCn)"><strong>cvtColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.cvtColor"><strong>cvtColor() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvTermCriteria"><strong>CvTermCriteria (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double epsilon"><strong>CvTermCriteria::epsilon (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int max_iter"><strong>CvTermCriteria::max_iter (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int type"><strong>CvTermCriteria::type (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvTreeNodeIterator"><strong>CvTreeNodeIterator (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvCvtSeqToArray(const CvSeq* seq, void* elements, CvSlice slice)"><strong>CvtSeqToArray (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo"><strong>CvTypeInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvUseOptimized(int on_off)"><strong>cvUseOptimized (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#CylindricalWarper : public WarperCreator"><strong>CylindricalWarper (C++ class)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="D">D</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#DataType"><strong>DataType (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDCT(const CvArr* src, CvArr* dst, int flags)"><strong>DCT (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void dct(InputArray src, OutputArray dst, int flags)"><strong>dct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.dct"><strong>dct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xphoto/doc/denoising.html#void dctDenoising(const Mat &src, Mat &dst, const float sigma)"><strong>dctDenoising (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<typename _Tp> void deallocate(_Tp* ptr, size_t n)"><strong>deallocate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cvv/doc/cvv_api.html#void debugDMatch(InputArray img1, std::vector<cv::KeyPoint> keypoints1, InputArray img2, std::vector<cv::KeyPoint> keypoints2, std::vector<cv::DMatch> matches, const CallMetaData& metaData, const string& description, const string& view, bool useTrainDescriptor)"><strong>debugDMatch (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/cvv/doc/cvv_api.html#void debugFilter(InputArray original, InputArray result, const CallMetaData& metaData, const string& description, const string& view)"><strong>debugFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#IplImage* cvDecodeImage(const CvMat* buf, int iscolor)"><strong>DecodeImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#CvMat* cvDecodeImageM(const CvMat* buf, int iscolor)"><strong>DecodeImageM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/decolor.html#void decolor(InputArray src, OutputArray grayscale, OutputArray color_boost)"><strong>decolor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void decomposeEssentialMat(InputArray E, OutputArray R1, OutputArray R2, OutputArray t)"><strong>decomposeEssentialMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int decomposeHomographyMat(InputArray H, InputArray K, OutputArrayOfArrays rotations, OutputArrayOfArrays translations, OutputArrayOfArrays normals)"><strong>decomposeHomographyMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvDecomposeProjectionMatrix(const CvMat * projMatr, CvMat * calibMatr, CvMat * rotMatr, CvMat * posVect, CvMat * rotMatrX, CvMat * rotMatrY, CvMat * rotMatrZ, CvPoint3D64f * eulerAngles)"><strong>DecomposeProjectionMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void decomposeProjectionMatrix(InputArray projMatrix, OutputArray cameraMatrix, OutputArray rotMatrix, OutputArray transVect, OutputArray rotMatrixX, OutputArray rotMatrixY, OutputArray rotMatrixZ, OutputArray eulerAngles)"><strong>decomposeProjectionMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.decomposeProjectionMatrix"><strong>decomposeProjectionMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvDecRefData(CvArr* arr)"><strong>DecRefData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void denoise_TVL1(const std::vector<Mat>& observations,Mat& result, double lambda, int niters)"><strong>denoise_TVL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void DenseOpticalFlow::calc(InputArray I0, InputArray I1, InputOutputArray flow)"><strong>DenseOpticalFlow::calc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void DenseOpticalFlow::collectGarbage()"><strong>DenseOpticalFlow::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#DescriptorExtractor : public Algorithm"><strong>DescriptorExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#void DescriptorExtractor::compute(InputArray image, vector<KeyPoint>& keypoints, OutputArray descriptors) const"><strong>DescriptorExtractor::compute (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#void DescriptorExtractor::compute(InputArrayOfArrays images, vector<vector<KeyPoint> >& keypoints, OutputArrayOfArrays descriptors) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#Ptr<DescriptorExtractor> DescriptorExtractor::create(const String& descriptorExtractorType)"><strong>DescriptorExtractor::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#cv2.DescriptorExtractor_create"><strong>DescriptorExtractor_create() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_extractors.html#cv2.DescriptorExtractor_create.compute"><strong>DescriptorExtractor_create.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#DescriptorMatcher : public Algorithm"><strong>DescriptorMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::add(InputArrayOfArrays descriptors)"><strong>DescriptorMatcher::add (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::clear()"><strong>DescriptorMatcher::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#Ptr<DescriptorMatcher> DescriptorMatcher::clone(bool emptyTrainData)"><strong>DescriptorMatcher::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#Ptr<DescriptorMatcher> DescriptorMatcher::create(const String& descriptorMatcherType)"><strong>DescriptorMatcher::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#bool DescriptorMatcher::empty() const"><strong>DescriptorMatcher::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#const vector<Mat>& DescriptorMatcher::getTrainDescriptors() const"><strong>DescriptorMatcher::getTrainDescriptors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#bool DescriptorMatcher::isMaskSupported()"><strong>DescriptorMatcher::isMaskSupported (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::knnMatch(InputArray queryDescriptors, InputArray trainDescriptors, vector<vector<DMatch> >& matches, int k, InputArray mask, bool compactResult) const"><strong>DescriptorMatcher::knnMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::knnMatch(InputArray queryDescriptors, vector<vector<DMatch> >& matches, int k, InputArrayOfArrays masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::match(InputArray queryDescriptors, InputArray trainDescriptors, vector<DMatch>& matches, InputArray mask) const"><strong>DescriptorMatcher::match (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::match(InputArray queryDescriptors, vector<DMatch>& matches, InputArrayOfArrays masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::radiusMatch(InputArray queryDescriptors, InputArray trainDescriptors, vector<vector<DMatch> >& matches, float maxDistance, InputArray mask, bool compactResult) const"><strong>DescriptorMatcher::radiusMatch (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::radiusMatch(InputArray queryDescriptors, vector<vector<DMatch> >& matches, float maxDistance, InputArrayOfArrays masks, bool compactResult)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#void DescriptorMatcher::train()"><strong>DescriptorMatcher::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvDestroyAllWindows()"><strong>DestroyAllWindows (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void destroyAllWindows()"><strong>destroyAllWindows (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.destroyAllWindows"><strong>destroyAllWindows() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvDestroyWindow(const char* name)"><strong>DestroyWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void destroyWindow(const String& winname)"><strong>destroyWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.destroyWindow"><strong>destroyWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvDet(const CvArr* mat)"><strong>Det (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::BestOf2NearestMatcher : public detail::FeaturesMatcher"><strong>detail::BestOf2NearestMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::BestOf2NearestMatcher::BestOf2NearestMatcher(bool try_use_gpu , float match_conf , int num_matches_thresh1 , int num_matches_thresh2)"><strong>detail::BestOf2NearestMatcher::BestOf2NearestMatcher (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::Blender"><strong>detail::Blender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::blend(InputOutputArray dst, InputOutputArray dst_mask)"><strong>detail::Blender::blend (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::feed(InputArray img, InputArray mask, Point tl)"><strong>detail::Blender::feed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#void detail::Blender::prepare(const std::vector<Point> &corners, const std::vector<Size> &sizes)"><strong>detail::Blender::prepare (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::BlocksGainCompensator : public detail::ExposureCompensator"><strong>detail::BlocksGainCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterBase : public detail::Estimator"><strong>detail::BundleAdjusterBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterBase::BundleAdjusterBase(int num_params_per_cam, int num_errs_per_measurement)"><strong>detail::BundleAdjusterBase::BundleAdjusterBase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::calcError(Mat &err)"><strong>detail::BundleAdjusterBase::calcError (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::calcJacobian(Mat &jac)"><strong>detail::BundleAdjusterBase::calcJacobian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::obtainRefinedCameraParams(std::vector<CameraParams> &cameras) const"><strong>detail::BundleAdjusterBase::obtainRefinedCameraParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::BundleAdjusterBase::setUpInitialCameraParams(const std::vector<CameraParams> &cameras)"><strong>detail::BundleAdjusterBase::setUpInitialCameraParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterRay : public detail::BundleAdjusterBase"><strong>detail::BundleAdjusterRay (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::BundleAdjusterReproj : public detail::BundleAdjusterBase"><strong>detail::BundleAdjusterReproj (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/camera.html#detail::CameraParams"><strong>detail::CameraParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::CylindricalWarper : public detail::RotationWarperBase<CylindricalProjector>"><strong>detail::CylindricalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::CylindricalWarper::CylindricalWarper(float scale)"><strong>detail::CylindricalWarper::CylindricalWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/autocalib.html#void detail::estimateFocal(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<double> &focals)"><strong>detail::estimateFocal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::Estimator"><strong>detail::Estimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#bool detail::Estimator::estimate(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<CameraParams> &cameras)"><strong>detail::Estimator::estimate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#bool detail::Estimator::operator ()(const std::vector<ImageFeatures> &features, const std::vector<MatchesInfo> &pairwise_matches, std::vector<CameraParams> &cameras)"><strong>detail::Estimator::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::ExposureCompensator"><strong>detail::ExposureCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::apply(int index, Point corner, InputOutputArray image, InputArray mask)"><strong>detail::ExposureCompensator::apply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::feed(const std::vector<Point> &corners, const std::vector<UMat> &images, const std::vector<UMat> &masks)"><strong>detail::ExposureCompensator::feed (C++ function)</strong></a>, <a href="modules/stitching/doc/exposure_compensation.html#void detail::ExposureCompensator::feed(const std::vector<Point> &corners, const std::vector<UMat> &images, const std::vector<std::pair<UMat,uchar> > &masks)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::FeatherBlender : public detail::Blender"><strong>detail::FeatherBlender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::FeaturesFinder"><strong>detail::FeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::collectGarbage()"><strong>detail::FeaturesFinder::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::find(InputArray image, ImageFeatures &features)"><strong>detail::FeaturesFinder::find (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::operator ()(InputArray image, ImageFeatures &features)"><strong>detail::FeaturesFinder::operator() (C++ function)</strong></a>, <a href="modules/stitching/doc/matching.html#void detail::FeaturesFinder::operator ()(InputArray image, ImageFeatures &features, const std::vector<cv::Rect> &rois)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::FeaturesMatcher"><strong>detail::FeaturesMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::collectGarbage()"><strong>detail::FeaturesMatcher::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#bool detail::FeaturesMatcher::isThreadSafe() const"><strong>detail::FeaturesMatcher::isThreadSafe (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::match(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo& matches_info)"><strong>detail::FeaturesMatcher::match (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::operator ()(const ImageFeatures &features1, const ImageFeatures &features2, MatchesInfo& matches_info)"><strong>detail::FeaturesMatcher::operator() (C++ function)</strong></a>, <a href="modules/stitching/doc/matching.html#void detail::FeaturesMatcher::operator ()(const std::vector<ImageFeatures> & features, std::vector<MatchesInfo> & pairwise_matches, const UMat & mask)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/autocalib.html#void detail::focalsFromHomography(const Mat &H, double &f0, double &f1, bool &f0_ok, bool &f1_ok)"><strong>detail::focalsFromHomography (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::GainCompensator : public detail::ExposureCompensator"><strong>detail::GainCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::GraphCutSeamFinder : public detail::GraphCutSeamFinderBase, public detail::SeamFinder"><strong>detail::GraphCutSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::GraphCutSeamFinderBase"><strong>detail::GraphCutSeamFinderBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::HomographyBasedEstimator : public detail::Estimator"><strong>detail::HomographyBasedEstimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::ImageFeatures"><strong>detail::ImageFeatures (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::MatchesInfo"><strong>detail::MatchesInfo (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/blenders.html#detail::MultiBandBlender : public detail::Blender"><strong>detail::MultiBandBlender (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/exposure_compensation.html#detail::NoExposureCompensator : public detail::ExposureCompensator"><strong>detail::NoExposureCompensator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::NoSeamFinder : public detail::SeamFinder"><strong>detail::NoSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::OrbFeaturesFinder : public detail::FeaturesFinder"><strong>detail::OrbFeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::PairwiseSeamFinder : public detail::SeamFinder"><strong>detail::PairwiseSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#void detail::PairwiseSeamFinder::findInPair(size_t first, size_t second, Rect roi)"><strong>detail::PairwiseSeamFinder::findInPair (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/stitching/doc/warpers.html#detail::PlaneWarper : public detail::RotationWarperBase<PlaneProjector>"><strong>detail::PlaneWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::PlaneWarper::PlaneWarper(float scale)"><strong>detail::PlaneWarper::PlaneWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::ProjectorBase"><strong>detail::ProjectorBase (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::RotationWarper"><strong>detail::RotationWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Rect detail::RotationWarper::buildMaps(Size src_size, InputArray K, InputArray R, OutputArray xmap, OutputArray ymap)"><strong>detail::RotationWarper::buildMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Point detail::RotationWarper::warp(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, OutputArray dst)"><strong>detail::RotationWarper::warp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::RotationWarper::warpBackward(InputArray src, InputArray K, InputArray R, int interp_mode, int border_mode, Size dst_size, OutputArray dst)"><strong>detail::RotationWarper::warpBackward (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Point2f detail::RotationWarper::warpPoint(const Point2f &pt, InputArray K, InputArray R)"><strong>detail::RotationWarper::warpPoint (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#Rect detail::RotationWarper::warpRoi(Size src_size, InputArray K, InputArray R)"><strong>detail::RotationWarper::warpRoi (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::RotationWarperBase"><strong>detail::RotationWarperBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::SeamFinder"><strong>detail::SeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#void detail::SeamFinder::find(const std::vector<UMat> &src, const std::vector<Point> &corners, std::vector<UMat> &masks)"><strong>detail::SeamFinder::find (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#detail::SphericalWarper : public detail::RotationWarperBase<SphericalProjector>"><strong>detail::SphericalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/warpers.html#void detail::SphericalWarper::SphericalWarper(float scale)"><strong>detail::SphericalWarper::SphericalWarper (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/matching.html#detail::SurfFeaturesFinder : public detail::FeaturesFinder"><strong>detail::SurfFeaturesFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/seam_estimation.html#detail::VoronoiSeamFinder : public detail::PairwiseSeamFinder"><strong>detail::VoronoiSeamFinder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#void detail::waveCorrect(std::vector<Mat> &rmats, WaveCorrectKind kind)"><strong>detail::waveCorrect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/motion_estimation.html#detail::WaveCorrectKind"><strong>detail::WaveCorrectKind (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/npr.html#void detailEnhance(InputArray src, OutputArray dst, float sigma_s , float sigma_r)"><strong>detailEnhance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/binary_descriptor.html#void detect(const Mat& image, vector<KeyLine>& keylines, Mat& mask)"><strong>detect (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/binary_descriptor.html#void detect(const vector<Mat>& images, vector<vector<KeyLine> >& keylines, vector<Mat>& masks) const"><strong>[1]</strong></a>, <a href="modules/xobjdetect/doc/integral_channel_features.html#detect(const Mat& img, std::vector<Rect>& objects, float minScaleFactor, float maxScaleFactor, float factorStep, float threshold, int slidingStep, std::vector<float>& values)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/structured_edge_detection.html#void detectEdges(const Mat src, Mat dst)"><strong>detectEdges (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double determinant(InputArray mtx)"><strong>determinant (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.determinant"><strong>determinant() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDFT(const CvArr* src, CvArr* dst, int flags, int nonzero_rows)"><strong>DFT (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void dft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><strong>dft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.dft"><strong>dft() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvDilate(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)"><strong>Dilate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void dilate(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>dilate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.dilate"><strong>dilate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#index-0">displayOverlay</a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvDisplayOverlay(const char* name, const char* text, int delayms)"><strong>DisplayOverlay (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void displayOverlay(const String& winname, const String& text, int delayms)"><strong>displayOverlay (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvDisplayStatusBar(const char* name, const char* text, int delayms)"><strong>DisplayStatusBar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void displayStatusBar(const String& winname, const String& text, int delayms)"><strong>displayStatusBar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void distanceTransform(InputArray src, OutputArray dst, int distanceType, int maskSize, int dstType)"><strong>distanceTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void distanceTransform(InputArray src, OutputArray dst, OutputArray labels, int distanceType, int maskSize, int labelType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.distanceTransform"><strong>distanceTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvDistTransform(const CvArr* src, CvArr* dst, int distance_type, int mask_size, const float* mask, CvArr* labels, int labelType)"><strong>DistTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvDiv(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)"><strong>Div (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void divide(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><strong>divide (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void divide(double scale, InputArray src2, OutputArray dst, int dtype)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.divide"><strong>divide() (Python function in cv2)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#cv2.divide"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#DMatch"><strong>DMatch (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvDotProduct(const CvArr* src1, const CvArr* src2)"><strong>DotProduct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#DownhillSolver"><strong>DownhillSolver (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#Ptr<Solver::Function> DownhillSolver::getFunction()"><strong>DownhillSolver::getFunction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#TermCriteria DownhillSolver::getTermCriteria()"><strong>DownhillSolver::getTermCriteria (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#double DownhillSolver::minimize(InputOutputArray x)"><strong>DownhillSolver::minimize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void DownhillSolver::setFunction(const Ptr<Solver::Function>& f)"><strong>DownhillSolver::setFunction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void DownhillSolver::setTermCriteria(const TermCriteria& termcrit)"><strong>DownhillSolver::setTermCriteria (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvDrawChessboardCorners(CvArr* image, CvSize pattern_size, CvPoint2D32f* corners, int count, int pattern_was_found)"><strong>DrawChessboardCorners (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void drawChessboardCorners(InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound)"><strong>drawChessboardCorners (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.drawChessboardCorners"><strong>drawChessboardCorners() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvDrawContours(CvArr * img, CvSeq* contour, CvScalar external_color, CvScalar hole_color, int max_level, int thickness, int line_type, CvPoint offset)"><strong>DrawContours (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void drawContours(InputOutputArray image, InputArrayOfArrays contours, int contourIdx, const Scalar& color, int thickness, int lineType, InputArray hierarchy, int maxLevel, Point offset)"><strong>drawContours (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.drawContours"><strong>drawContours() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/drawing_functions.html#void drawKeylines(const Mat& image, const std::vector<KeyLine>& keylines, Mat& outImage, const Scalar& color, int flags)"><strong>drawKeylines (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawKeypoints(InputArray image, const vector<KeyPoint>& keypoints, InputOutputArray outImage, const Scalar& color, int flags)"><strong>drawKeypoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#cv2.drawKeypoints"><strong>drawKeypoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/drawing_functions.html#void drawLineMatches(const Mat& img1, const std::vector<KeyLine>& keylines1, const Mat& img2, const std::vector<KeyLine>& keylines2, const std::vector<DMatch>& matches1to2, Mat& outImg, const Scalar& matchColor, const Scalar& singleLineColor, const std::vector<char>& matchesMask, int flags)"><strong>drawLineMatches (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawMatches(InputArray img1, const vector<KeyPoint>& keypoints1, InputArray img2, const vector<KeyPoint>& keypoints2, const vector<DMatch>& matches1to2, InputOutputArray outImg, const Scalar& matchColor, const Scalar& singlePointColor, const vector<char>& matchesMask, int flags)"><strong>drawMatches (C++ function)</strong></a>, <a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#void drawMatches(InputArray img1, const vector<KeyPoint>& keypoints1, InputArray img2, const vector<KeyPoint>& keypoints2, const vector<vector<DMatch> >& matches1to2, InputOutputArray outImg, const Scalar& matchColor, const Scalar& singlePointColor, const vector<vector<char> >& matchesMask, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#cv2.drawMatches"><strong>drawMatches() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/drawing_function_of_keypoints_and_matches.html#cv2.drawMatchesKnn"><strong>drawMatchesKnn() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#DTFilter : public Algorithm"><strong>DTFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void dtFilter(InputArray guide, InputArray src, OutputArray dst, double sigmaSpatial, double sigmaColor, int mode , int numIters)"><strong>dtFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.dtFilter"><strong>dtFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.DTFilter.filter"><strong>DTFilter.filter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void DTFilter::filter(InputArray src, OutputArray dst, int dDepth)"><strong>DTFilter::filter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#DTrees : public StatModel"><strong>DTrees (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#Ptr<DTrees> DTrees::create(const Params& params)"><strong>DTrees::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#Params DTrees::getDParams() const"><strong>DTrees::getDParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#std::vector<Node>& DTrees::getNodes() const"><strong>DTrees::getNodes (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#std::vector<int>& DTrees::getRoots() const"><strong>DTrees::getRoots (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#std::vector<Split>& DTrees::getSplits() const"><strong>DTrees::getSplits (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#std::vector<int>& DTrees::getSubsets() const"><strong>DTrees::getSubsets (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#DTrees::Node"><strong>DTrees::Node (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int classIdx"><strong>DTrees::Node::classIdx (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int defaultDir"><strong>DTrees::Node::defaultDir (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int left"><strong>DTrees::Node::left (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int parent"><strong>DTrees::Node::parent (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int right"><strong>DTrees::Node::right (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int split"><strong>DTrees::Node::split (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#double value"><strong>DTrees::Node::value (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#DTrees::Params"><strong>DTrees::Params (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#DTrees::Params::Params()"><strong>DTrees::Params::Params (C++ function)</strong></a>, <a href="modules/ml/doc/decision_trees.html#DTrees::Params::Params(int maxDepth, int minSampleCount, double regressionAccuracy, bool useSurrogates, int maxCategories, int CVFolds, bool use1SERule, bool truncatePrunedTree, const Mat& priors)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#void DTrees::setDParams(const Params& p)"><strong>DTrees::setDParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#DTrees::Split"><strong>DTrees::Split (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#float c"><strong>DTrees::Split::c (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#bool inversed"><strong>DTrees::Split::inversed (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int next"><strong>DTrees::Split::next (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#float quality"><strong>DTrees::Split::quality (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int subsetOfs"><strong>DTrees::Split::subsetOfs (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/decision_trees.html#int varIdx"><strong>DTrees::Split::varIdx (C++ member)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="E">E</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/photo/doc/npr.html#void edgePreservingFilter(InputArray src, OutputArray dst, int flags , float sigma_s , float sigma_r)"><strong>edgePreservingFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool eigen(InputArray src, OutputArray eigenvalues, OutputArray eigenvectors)"><strong>eigen (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.eigen"><strong>eigen() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvEigenVV(CvArr* mat, CvArr* evects, CvArr* evals, double eps, int lowindex, int highindex)"><strong>EigenVV (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvEllipse(CvArr* img, CvPoint center, CvSize axes, double angle, double start_angle, double end_angle, CvScalar color, int thickness, int line_type, int shift)"><strong>Ellipse (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void ellipse(InputOutputArray img, Point center, Size axes, double angle, double startAngle, double endAngle, const Scalar& color, int thickness, int lineType, int shift)"><strong>ellipse (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#void ellipse(InputOutputArray img, const RotatedRect& box, const Scalar& color, int thickness, int lineType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.ellipse"><strong>ellipse() (Python function in cv2)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#cv2.ellipse"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void ellipse2Poly(Point center, Size axes, int angle, int arcStart, int arcEnd, int delta, vector<Point>& pts)"><strong>ellipse2Poly (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.ellipse2Poly"><strong>ellipse2Poly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvEllipseBox(CvArr* img, CvBox2D box, CvScalar color, int thickness, int line_type, int shift)"><strong>EllipseBox (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#EM : public StatModel"><strong>EM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Ptr<EM> EM::create(const Params& params)"><strong>EM::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#void EM::getCovs(std::vector<Mat>& covs) const"><strong>EM::getCovs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Mat EM::getMeans() const"><strong>EM::getMeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Mat EM::getWeights() const"><strong>EM::getWeights (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#EM::Params"><strong>EM::Params (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#EM::Params::Params(int nclusters, int covMatType,const TermCriteria& termCrit)"><strong>EM::Params::Params (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Vec2d EM::predict2(InputArray sample, OutputArray probs) const"><strong>EM::predict2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#Ptr<EM> EM::train(InputArray samples, OutputArray logLikelihoods, OutputArray labels, OutputArray probs, const Params& params)"><strong>EM::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::train_startWithE(InputArray samples, InputArray means0, InputArray covs0, InputArray weights0, OutputArray logLikelihoods, OutputArray labels, OutputArray probs, const Params& params)"><strong>EM::train_startWithE (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/expectation_maximization.html#bool EM::train_startWithM(InputArray samples, InputArray probs0, OutputArray logLikelihoods, OutputArray labels, OutputArray probs, const Params& params)"><strong>EM::train_startWithM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#float EMD(InputArray signature1, InputArray signature2, int distType, InputArray cost, float* lowerBound, OutputArray flow)"><strong>EMD (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/histogram_cost_matrix.html#EMDHistogramCostExtractor : public HistogramCostExtractor"><strong>EMDHistogramCostExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/emdL1.html#float EMDL1(InputArray signature1, InputArray signature2)"><strong>EMDL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/histogram_cost_matrix.html#EMDL1HistogramCostExtractor : public HistogramCostExtractor"><strong>EMDL1HistogramCostExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#CvMat* cvEncodeImage(const char* ext, const CvArr* image, const int* params)"><strong>EncodeImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvEndWriteSeq(CvSeqWriter* writer)"><strong>EndWriteSeq (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvEndWriteStruct(CvFileStorage* fs)"><strong>EndWriteStruct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvEqualizeHist(const CvArr* src, CvArr* dst)"><strong>EqualizeHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void equalizeHist(InputArray src, OutputArray dst)"><strong>equalizeHist (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#cv2.equalizeHist"><strong>equalizeHist() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#ERFilter : public Algorithm"><strong>ERFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#ERFilter::Callback"><strong>ERFilter::Callback (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#double ERFilter::Callback::eval(const ERStat& stat)"><strong>ERFilter::Callback::eval (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#void ERFilter::run(InputArray image, std::vector<ERStat>& regions)"><strong>ERFilter::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#void erGrouping(InputArray img, InputArrayOfArrays channels, std::vector<std::vector<ERStat> > &regions, std::vector<std::vector<Vec2i> > &groups, std::vector<Rect> &groups_rects, int method , const std::string& filename , float minProbablity)"><strong>erGrouping (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvErode(const CvArr* src, CvArr* dst, IplConvKernel* element, int iterations)"><strong>Erode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void erode(InputArray src, OutputArray dst, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>erode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.erode"><strong>erode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void cvError(int status, const char* func_name, const char* err_msg, const char* file_name, int line)"><strong>Error (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void error(const Exception& exc)"><strong>error (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#ERStat"><strong>ERStat (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int estimateAffine3D(InputArray src, InputArray dst, OutputArray out, OutputArray inliers, double ransacThreshold , double confidence)"><strong>estimateAffine3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.estimateAffine3D"><strong>estimateAffine3D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#Mat estimateRigidTransform(InputArray src, InputArray dst, bool fullAffine)"><strong>estimateRigidTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.estimateRigidTransform"><strong>estimateRigidTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#void estimateTransformation(InputArray transformingShape, InputArray targetShape, std::vector<DMatch>& matches)"><strong>estimateTransformation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#Exception : public std::exception"><strong>Exception (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvExp(const CvArr* src, CvArr* dst)"><strong>Exp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void exp(InputArray src, OutputArray dst)"><strong>exp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.exp"><strong>exp() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void extractImageCOI(const CvArr* arr, OutputArray coiimg, int coi)"><strong>extractImageCOI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#void cvExtractSURF(const CvArr* image, const CvArr* mask, CvSeq** keypoints, CvSeq** descriptors, CvMemStorage* storage, CvSURFParams params)"><strong>ExtractSURF (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="F">F</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/face/doc/facerec_api.html#FaceRecognizer : public Algorithm"><strong>FaceRecognizer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#vector<int> FaceRecognizer::getLabelsByString(const String& str)"><strong>FaceRecognizer::getLabelsByString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#void FaceRecognizer::load(const String& filename)"><strong>FaceRecognizer::load (C++ function)</strong></a>, <a href="modules/face/doc/facerec_api.html#void FaceRecognizer::load(const FileStorage& fs) = 0"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#int FaceRecognizer::predict(InputArray src) const = 0"><strong>FaceRecognizer::predict (C++ function)</strong></a>, <a href="modules/face/doc/facerec_api.html#void FaceRecognizer::predict(InputArray src, int & label, double & confidence) const = 0"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#void FaceRecognizer::save(const String& filename) const"><strong>FaceRecognizer::save (C++ function)</strong></a>, <a href="modules/face/doc/facerec_api.html#void FaceRecognizer::save(FileStorage& fs) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#void FaceRecognizer::train(InputArrayOfArrays src, InputArray labels) = 0"><strong>FaceRecognizer::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/face/doc/facerec_api.html#void FaceRecognizer::update(InputArrayOfArrays src, InputArray labels)"><strong>FaceRecognizer::update (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void FAST(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression)"><strong>FAST (C++ function)</strong></a>, <a href="modules/features2d/doc/feature_detection_and_description.html#void FAST(InputArray image, vector<KeyPoint>& keypoints, int threshold, bool nonmaxSuppression, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float cvFastArctan(float y, float x)"><strong>FastArctan (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#float fastAtan2(float y, float x)"><strong>fastAtan2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.fastAtan2"><strong>fastAtan2() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#FastFeatureDetector : public Feature2D"><strong>FastFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void fastFree(void* ptr)"><strong>fastFree (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void* fastMalloc(size_t bufSize)"><strong>fastMalloc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoising(InputArray src, OutputArray dst, float h, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoising (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#cv2.fastNlMeansDenoising"><strong>fastNlMeansDenoising() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingColored(InputArray src, OutputArray dst, float h, float hColor, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingColored (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#cv2.fastNlMeansDenoisingColored"><strong>fastNlMeansDenoisingColored() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingColoredMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h, float hColor, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingColoredMulti (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#cv2.fastNlMeansDenoisingColoredMulti"><strong>fastNlMeansDenoisingColoredMulti() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#void fastNlMeansDenoisingMulti(InputArrayOfArrays srcImgs, OutputArray dst, int imgToDenoiseIndex, int temporalWindowSize, float h, int templateWindowSize, int searchWindowSize)"><strong>fastNlMeansDenoisingMulti (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/denoising.html#cv2.fastNlMeansDenoisingMulti"><strong>fastNlMeansDenoisingMulti() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#FeatureDetector : public Algorithm"><strong>FeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void FeatureDetector::detect(InputArray image, vector<KeyPoint>& keypoints, InputArray mask) const"><strong>FeatureDetector::detect (C++ function)</strong></a>, <a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#void FeatureDetector::detect(InputArrayOfArrays images, vector<vector<KeyPoint> >& keypoints, InputArrayOfArrays masks) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#cv2.FeatureDetector_create.detect"><strong>FeatureDetector_create.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#FeatureEvaluator : public Algorithm"><strong>FeatureEvaluator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#int FeatureEvaluator::evaluate(size_t feature_ind) const"><strong>FeatureEvaluator::evaluate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void FeatureEvaluator::evaluateAll(OutputArray feature_values)"><strong>FeatureEvaluator::evaluateAll (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void FeatureEvaluator::setChannels(InputArrayOfArrays channels)"><strong>FeatureEvaluator::setChannels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void FeatureEvaluator::setPosition(Size position)"><strong>FeatureEvaluator::setPosition (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode"><strong>FileNode (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNode::begin() const"><strong>FileNode::begin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::empty() const"><strong>FileNode::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNode::end() const"><strong>FileNode::end (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode()"><strong>FileNode::FileNode (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode(const CvFileStorage* fs, const CvFileNode* node)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode::FileNode(const FileNode& node)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isInt() const"><strong>FileNode::isInt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isMap() const"><strong>FileNode::isMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isNamed() const"><strong>FileNode::isNamed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isNone() const"><strong>FileNode::isNone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isReal() const"><strong>FileNode::isReal (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isSeq() const"><strong>FileNode::isSeq (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileNode::isString() const"><strong>FileNode::isString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#String FileNode::name() const"><strong>FileNode::name (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator double() const"><strong>FileNode::operator double (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator float() const"><strong>FileNode::operator float (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator int() const"><strong>FileNode::operator int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode::operator String() const"><strong>FileNode::operator String (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#CvFileNode* FileNode::operator *()"><strong>FileNode::operator* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](const String& nodename) const"><strong>FileNode::operator[] (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](const char* nodename) const"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNode::operator[](int i) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void* FileNode::readObj() const"><strong>FileNode::readObj (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileNode::readRaw(const String& fmt, uchar* vec, size_t len) const"><strong>FileNode::readRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#size_t FileNode::size() const"><strong>FileNode::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#int FileNode::type() const"><strong>FileNode::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator"><strong>FileNodeIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator()"><strong>FileNodeIterator::FileNodeIterator (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator(const CvFileStorage* fs, const CvFileNode* node, size_t ofs)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator::FileNodeIterator(const FileNodeIterator& it)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNodeIterator::operator *() const"><strong>FileNodeIterator::operator* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator ++ ()"><strong>FileNodeIterator::operator++ (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNodeIterator::operator ++ (int)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator +=(int ofs)"><strong>FileNodeIterator::operator+= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator -- ()"><strong>FileNodeIterator::operator-- (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator FileNodeIterator::operator -- (int)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::operator -=(int ofs)"><strong>FileNodeIterator::operator-= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileNodeIterator::operator ->() const"><strong>FileNodeIterator::operator-&gt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNodeIterator& FileNodeIterator::readRaw(const String& fmt, uchar* vec, size_t maxCount=(size_t)INT_MAX)"><strong>FileNodeIterator::readRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileStorage"><strong>FileStorage (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileStorage::FileStorage()"><strong>FileStorage::FileStorage (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileStorage::FileStorage(const String& source, int flags, const String& encoding)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#static String FileStorage::getDefaultObjectName(const String& filename)"><strong>FileStorage::getDefaultObjectName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::getFirstTopLevelNode() const"><strong>FileStorage::getFirstTopLevelNode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileStorage::isOpened() const"><strong>FileStorage::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#bool FileStorage::open(const String& filename, int flags, const String& encoding)"><strong>FileStorage::open (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#CvFileStorage* FileStorage::operator *()"><strong>FileStorage::operator* (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#const CvFileStorage* FileStorage::operator *() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::operator[](const String& nodename) const"><strong>FileStorage::operator[] (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::operator[](const char* nodename) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::release()"><strong>FileStorage::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#String FileStorage::releaseAndGetString()"><strong>FileStorage::releaseAndGetString (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#FileNode FileStorage::root(int streamidx) const"><strong>FileStorage::root (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::writeObj(const String& name, const void* obj)"><strong>FileStorage::writeObj (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#void FileStorage::writeRaw(const String& fmt, const uchar* vec, size_t len)"><strong>FileStorage::writeRaw (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvFillConvexPoly(CvArr* img, const CvPoint* pts, int npts, CvScalar color, int line_type, int shift)"><strong>FillConvexPoly (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void fillConvexPoly(Mat& img, const Point* pts, int npts, const Scalar& color, int lineType, int shift)"><strong>fillConvexPoly (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#void fillConvexPoly(InputOutputArray img, InputArray points, const Scalar& color, int lineType, int shift)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.fillConvexPoly"><strong>fillConvexPoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvFillPoly(CvArr* img, CvPoint** pts, const int* npts, int contours, CvScalar color, int line_type, int shift)"><strong>FillPoly (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void fillPoly(Mat& img, const Point** pts, const int* npts, int ncontours, const Scalar& color, int lineType, int shift, Point offset)"><strong>fillPoly (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#void fillPoly(InputOutputArray img, InputArrayOfArrays pts, const Scalar& color, int lineType, int shift, Point offset)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.fillPoly"><strong>fillPoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvFilter2D(const CvArr* src, CvArr* dst, const CvMat* kernel, CvPoint anchor)"><strong>Filter2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void filter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernel, Point anchor, double delta, int borderType)"><strong>filter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.filter2D"><strong>filter2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void filterSpeckles(InputOutputArray img, double newVal, int maxSpeckleSize, double maxDiff, InputOutputArray buf)"><strong>filterSpeckles (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.filterSpeckles"><strong>filterSpeckles() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void finalize()"><strong>finalize (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void finalize()"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/cvv/doc/cvv_api.html#void finalShow()"><strong>finalShow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindChessboardCorners(const void* image, CvSize pattern_size, CvPoint2D32f* corners, int* corner_count, int flags)"><strong>FindChessboardCorners (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool findChessboardCorners(InputArray image, Size patternSize, OutputArray corners, int flags)"><strong>findChessboardCorners (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findChessboardCorners"><strong>findChessboardCorners() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool findCirclesGrid(InputArray image, Size patternSize, OutputArray centers, int flags, const Ptr<FeatureDetector> &blobDetector)"><strong>findCirclesGrid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findCirclesGrid"><strong>findCirclesGrid() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvFindContours(CvArr* image, CvMemStorage* storage, CvSeq** first_contour, int header_size, int mode, int method, CvPoint offset)"><strong>FindContours (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, OutputArray hierarchy, int mode, int method, Point offset)"><strong>findContours (C++ function)</strong></a>, <a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void findContours(InputOutputArray image, OutputArrayOfArrays contours, int mode, int method, Point offset)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.findContours"><strong>findContours() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvFindCornerSubPix(const CvArr* image, CvPoint2D32f* corners, int count, CvSize win, CvSize zero_zone, CvTermCriteria criteria)"><strong>FindCornerSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findEssentialMat(InputArray points1, InputArray points2, double focal, Point2d pp, int method, double prob, double threshold, OutputArray mask)"><strong>findEssentialMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvFindExtrinsicCameraParams2(const CvMat* object_points, const CvMat* image_points, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* rotation_vector, CvMat* translation_vector, int use_extrinsic_guess)"><strong>FindExtrinsicCameraParams2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindFundamentalMat(const CvMat* points1, const CvMat* points2, CvMat* fundamental_matrix, int method, double param1, double param2, CvMat* status)"><strong>FindFundamentalMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findFundamentalMat(InputArray points1, InputArray points2, int method, double param1, double param2, OutputArray mask)"><strong>findFundamentalMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findFundamentalMat"><strong>findFundamentalMat() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge* cvFindGraphEdge(const CvGraph* graph, int start_idx, int end_idx)"><strong>FindGraphEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphEdge* cvFindGraphEdgeByPtr(const CvGraph* graph, const CvGraphVtx* start_vtx, const CvGraphVtx* end_vtx)"><strong>FindGraphEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvFindHomography(const CvMat* src_points, const CvMat* dst_points, CvMat* homography, int method, double ransacReprojThreshold, CvMat* mask, int maxIters , double confidence)"><strong>FindHomography (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat findHomography(InputArray srcPoints, InputArray dstPoints, int method, double ransacReprojThreshold, OutputArray mask, const int maxIters , const double confidence)"><strong>findHomography (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.findHomography"><strong>findHomography() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#double findTransformECC(InputArray templateImage, InputArray inputImage, InputOutputArray warpMatrix, int motionType, TermCriteria criteria)"><strong>findTransformECC (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.findTransformECC"><strong>findTransformECC() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvFindType(const char* type_name)"><strong>FindType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvFirstType(void)"><strong>FirstType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double fisheye::calibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, const Size& image_size, InputOutputArray K, InputOutputArray D, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags , TermCriteria criteria)"><strong>fisheye::calibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::distortPoints(InputArray undistorted, OutputArray distorted, InputArray K, InputArray D, double alpha)"><strong>fisheye::distortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::estimateNewCameraMatrixForUndistortRectify(InputArray K, InputArray D, const Size &image_size, InputArray R, OutputArray P, double balance , const Size& new_size , double fov_scale)"><strong>fisheye::estimateNewCameraMatrixForUndistortRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::initUndistortRectifyMap(InputArray K, InputArray D, InputArray R, InputArray P, const cv::Size& size, int m1type, OutputArray map1, OutputArray map2)"><strong>fisheye::initUndistortRectifyMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, const Affine3d& affine, InputArray K, InputArray D, double alpha , OutputArray jacobian)"><strong>fisheye::projectPoints (C++ function)</strong></a>, <a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::projectPoints(InputArray objectPoints, OutputArray imagePoints, InputArray rvec, InputArray tvec, InputArray K, InputArray D, double alpha , OutputArray jacobian)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double fisheye::stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray K1, InputOutputArray D1, InputOutputArray K2, InputOutputArray D2, Size imageSize, OutputArray R, OutputArray T, int flags , TermCriteria criteria)"><strong>fisheye::stereoCalibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::stereoRectify(InputArray K1, InputArray D1, InputArray K2, InputArray D2, const Size &imageSize, InputArray R, InputArray tvec, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, const Size &newImageSize , double balance , double fov_scale)"><strong>fisheye::stereoRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::undistortImage(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray Knew , const Size& new_size)"><strong>fisheye::undistortImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void fisheye::undistortPoints(InputArray distorted, OutputArray undistorted, InputArray K, InputArray D, InputArray R , InputArray P)"><strong>fisheye::undistortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect fitEllipse(InputArray points)"><strong>fitEllipse (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.fitEllipse"><strong>fitEllipse() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvBox2D cvFitEllipse2(const CvArr* points)"><strong>FitEllipse2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvFitLine(const CvArr* points, int dist_type, double param, double reps, double aeps, float* line)"><strong>FitLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void fitLine(InputArray points, OutputArray line, int distType, double param, double reps, double aeps)"><strong>fitLine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.fitLine"><strong>fitLine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_clustering.html#template<typename Distance> int flann::hierarchicalClustering(const Mat& features, Mat& centers, const cvflann::KMeansIndexParams& params, Distance d)"><strong>flann::hierarchicalClustering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#flann::Index_"><strong>flann::Index_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#const IndexParams* flann::Index_<T>::getIndexParameters()"><strong>flann::Index_&lt;T&gt;::getIndexParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#flann::Index_<T>::Index_(const Mat& features, const IndexParams& params)"><strong>flann::Index_&lt;T&gt;::Index_ (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::knnSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& params)"><strong>flann::Index_&lt;T&gt;::knnSearch (C++ function)</strong></a>, <a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::knnSearch(const Mat& queries, Mat& indices, Mat& dists, int knn, const SearchParams& params)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#int flann::Index_<T>::radiusSearch(const vector<T>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& params)"><strong>flann::Index_&lt;T&gt;::radiusSearch (C++ function)</strong></a>, <a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#int flann::Index_<T>::radiusSearch(const Mat& query, Mat& indices, Mat& dists, float radius, const SearchParams& params)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/flann/doc/flann_fast_approximate_nearest_neighbor_search.html#void flann::Index_<T>::save(String filename)"><strong>flann::Index_&lt;T&gt;::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_descriptor_matchers.html#FlannBasedMatcher : public DescriptorMatcher"><strong>FlannBasedMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvFlip(const CvArr* src, CvArr* dst, int flip_mode)"><strong>Flip (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void flip(InputArray src, OutputArray dst, int flipCode)"><strong>flip (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.flip"><strong>flip() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvFloodFill(CvArr* image, CvPoint seed_point, CvScalar new_val, CvScalar lo_diff, CvScalar up_diff, CvConnectedComp* comp, int flags, CvArr* mask)"><strong>FloodFill (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#int floodFill(InputOutputArray image, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)"><strong>floodFill (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#int floodFill(InputOutputArray image, InputOutputArray mask, Point seedPoint, Scalar newVal, Rect* rect, Scalar loDiff, Scalar upDiff, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.floodFill"><strong>floodFill() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvFloor(double value)"><strong>Floor (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvFlushSeqWriter(CvSeqWriter* writer)"><strong>FlushSeqWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#CvFont cvFontQt(const char* nameFont, int pointSize, CvScalar color, int weight, int style, int spacing)"><strong>FontQt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#QtFont fontQt(const String& nameFont, int pointSize, Scalar color, int weight, int style, int spacing)"><strong>fontQt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#String format(const char* fmt, ...)"><strong>format (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/fr_adience.html#FR_adience"><strong>FR_adience (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/fr_lfw.html#FR_lfw"><strong>FR_lfw (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/extra_features.html#FREAK : public DescriptorExtractor"><strong>FREAK (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/extra_features.html#FREAK::FREAK(bool orientationNormalized, bool scaleNormalized, float patternScale, int nOctaves, const vector<int>& selectedPairs)"><strong>FREAK::FREAK (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/extra_features.html#vector<int> FREAK::selectPairs(const vector<Mat>& images, vector<vector<KeyPoint> >& keypoints, const double corrThresh , bool verbose)"><strong>FREAK::selectPairs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void cvFree(void** pptr)"><strong>Free (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static Widget fromPlyFile(const String &file_name)"><strong>fromPlyFile (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="G">G</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/filtering.html#void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY, int borderType)"><strong>GaussianBlur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.GaussianBlur"><strong>GaussianBlur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvGEMM(const CvArr* src1, const CvArr* src2, double alpha, const CvArr* src3, double beta, CvArr* dst, int tABC)"><strong>GEMM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void gemm(InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags)"><strong>gemm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.gemm"><strong>gemm() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#vector<vector<int> > generateFeatures(Size window_size, const string& type, int count, int channel_count)"><strong>generateFeatures (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet1D(const CvArr* arr, int idx0)"><strong>Get1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet2D(const CvArr* arr, int idx0, int idx1)"><strong>Get2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGet3D(const CvArr* arr, int idx0, int idx1, int idx2)"><strong>Get3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cvGetAffineTransform(const CvPoint2D32f * src, const CvPoint2D32f * dst, CvMat * map_matrix)"><strong>GetAffineTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getAffineTransform(InputArray src, InputArray dst)"><strong>getAffineTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/geometric_transformations.html#Mat getAffineTransform(const Point2f src[], const Point2f dst[])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getAffineTransform"><strong>getAffineTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#const String& getBuildInformation()"><strong>getBuildInformation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Camera getCamera() const"><strong>getCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#double cvGetCaptureProperty(CvCapture* capture, int property_id)"><strong>GetCaptureProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetCol(const CvArr* arr, CvMat* submat, int col)"><strong>GetCol (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetCols(const CvArr* arr, CvMat* submat, int start_col, int end_col)"><strong>GetCols (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int64 getCPUTickCount()"><strong>getCPUTickCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getCPUTickCount"><strong>getCPUTickCount() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getDefaultNewCameraMatrix(InputArray cameraMatrix, Size imgsize, bool centerPrincipalPoint)"><strong>getDefaultNewCameraMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getDefaultNewCameraMatrix"><strong>getDefaultNewCameraMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void getDerivKernels(OutputArray kx, OutputArray ky, int dx, int dy, int ksize, bool normalize, int ktype)"><strong>getDerivKernels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getDerivKernels"><strong>getDerivKernels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetDiag(const CvArr* arr, CvMat* submat, int diag)"><strong>GetDiag (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetDims(const CvArr* arr, int* sizes)"><strong>GetDims (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetDimSize(const CvArr* arr, int index)"><strong>GetDimSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetElemType(const CvArr* arr)"><strong>GetElemType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetFileNode(CvFileStorage* fs, CvFileNode* map, const CvStringHashNode* key, int create_missing)"><strong>GetFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetFileNodeByName(const CvFileStorage* fs, const CvFileNode* map, const char* name)"><strong>GetFileNodeByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvGetFileNodeName(const CvFileNode* node)"><strong>GetFileNodeName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Mat getGaborKernel(Size ksize, double sigma, double theta, double lambd, double gamma, double psi , int ktype)"><strong>getGaborKernel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getGaborKernel"><strong>getGaborKernel() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Mat getGaussianKernel(int ksize, double sigma, int ktype)"><strong>getGaussianKernel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getGaussianKernel"><strong>getGaussianKernel() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvGraphVtx* cvGetGraphVtx(CvGraph* graph, int vtx_idx)"><strong>GetGraphVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvStringHashNode* cvGetHashedKey(CvFileStorage* fs, const char* name, int len, int create_missing)"><strong>GetHashedKey (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvGetHuMoments(CvMoments* moments, CvHuMoments* hu_moments)"><strong>GetHuMoments (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvGetImage(const CvArr* arr, IplImage* image_header)"><strong>GetImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvGetImageCOI(const IplImage* image)"><strong>GetImageCOI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect cvGetImageROI(const IplImage* image)"><strong>GetImageROI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void getInitStep(OutputArray step)"><strong>getInitStep (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetMat(const CvArr* arr, CvMat* header, int* coi, int allowND)"><strong>GetMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvGetMinMaxHistValue(const CvHistogram* hist, float* min_value, float* max_value, int* min_idx, int* max_idx)"><strong>GetMinMaxHistValue (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int getMouseWheelDelta(int flags)"><strong>getMouseWheelDelta (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvScalar cvGetND(const CvArr* arr, const int* idx)"><strong>GetND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseNode* cvGetNextSparseNode(CvSparseMatIterator* mat_iterator)"><strong>GetNextSparseNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getNumberOfCPUs()"><strong>getNumberOfCPUs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getNumThreads()"><strong>getNumThreads (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvGetOptimalDFTSize(int size0)"><strong>GetOptimalDFTSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int getOptimalDFTSize(int vecsize)"><strong>getOptimalDFTSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.getOptimalDFTSize"><strong>getOptimalDFTSize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvGetOptimalNewCameraMatrix(const CvMat* camera_matrix, const CvMat* dist_coeffs, CvSize image_size, double alpha, CvMat* new_camera_matrix, CvSize new_imag_size, CvRect* valid_pixel_ROI, int center_principal_point)"><strong>GetOptimalNewCameraMatrix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat getOptimalNewCameraMatrix(InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, double alpha, Size newImgSize, Rect* validPixROI, bool centerPrincipalPoint)"><strong>getOptimalNewCameraMatrix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.getOptimalNewCameraMatrix"><strong>getOptimalNewCameraMatrix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#CvMat* cvGetPerspectiveTransform(const CvPoint2D32f* src, const CvPoint2D32f* dst, CvMat* map_matrix)"><strong>GetPerspectiveTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(InputArray src, InputArray dst)"><strong>getPerspectiveTransform (C++ function)</strong></a>, <a href="modules/imgproc/doc/geometric_transformations.html#Mat getPerspectiveTransform(const Point2f src[], const Point2f dst[])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getPerspectiveTransform"><strong>getPerspectiveTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static vtkSmartPointer<vtkProp> getProp(const Widget &widget)"><strong>getProp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvGetQuadrangleSubPix(const CvArr* src, CvArr* dst, const CvMat* map_matrix)"><strong>GetQuadrangleSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvGetRawData(const CvArr* arr, uchar** data, int* step, CvSize* roi_size)"><strong>GetRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal1D(const CvArr* arr, int idx0)"><strong>GetReal1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal2D(const CvArr* arr, int idx0, int idx1)"><strong>GetReal2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetReal3D(const CvArr* arr, int idx0, int idx1, int idx2)"><strong>GetReal3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvGetRealND(const CvArr* arr, const int* idx)"><strong>GetRealND (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvGetRectSubPix(const CvArr* src, CvArr* dst, CvPoint2D32f center)"><strong>GetRectSubPix (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void getRectSubPix(InputArray image, Size patchSize, Point2f center, OutputArray patch, int patchType)"><strong>getRectSubPix (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getRectSubPix"><strong>getRectSubPix() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#double getRenderingProperty(int property) const"><strong>getRenderingProperty (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#double getRenderingProperty(const String &id, int property)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileNode* cvGetRootFileNode(const CvFileStorage* fs, int stream_index)"><strong>GetRootFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#Mat getRotationMatrix2D(Point2f center, double angle, double scale)"><strong>getRotationMatrix2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.getRotationMatrix2D"><strong>getRotationMatrix2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetRow(const CvArr* arr, CvMat* submat, int row)"><strong>GetRow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetRows(const CvArr* arr, CvMat* submat, int start_row, int end_row, int delta_row)"><strong>GetRows (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvGetSeqElem(const CvSeq* seq, int index)"><strong>GetSeqElem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGetSeqReaderPos(CvSeqReader* reader)"><strong>GetSeqReaderPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem* cvGetSetElem(const CvSet* set_header, int idx)"><strong>GetSetElem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize cvGetSize(const CvArr* arr)"><strong>GetSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#Mat getStructuringElement(int shape, Size ksize, Point anchor)"><strong>getStructuringElement (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.getStructuringElement"><strong>getStructuringElement() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvGetSubRect(const CvArr* arr, CvMat* submat, CvRect rect)"><strong>GetSubRect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#String getText() const"><strong>getText (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#String getText() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvGetTextSize(const char* text_string, const CvFont* font, CvSize* text_size, int* baseline)"><strong>GetTextSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#Size getTextSize(const String& text, int fontFace, double fontScale, int thickness, int* baseLine)"><strong>getTextSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.getTextSize"><strong>getTextSize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int getThreadNum()"><strong>getThreadNum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int64 getTickCount()"><strong>getTickCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getTickCount"><strong>getTickCount() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#double getTickFrequency()"><strong>getTickFrequency (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.getTickFrequency"><strong>getTickFrequency() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvGetTrackbarPos(const char* trackbar_name, const char* window_name)"><strong>GetTrackbarPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int getTrackbarPos(const String& trackbarname, const String& winname)"><strong>getTrackbarPos (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.getTrackbarPos"><strong>getTrackbarPos() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Widget getWidget(const String &id) const"><strong>getWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#Affine3d getWidgetPose() const"><strong>getWidgetPose (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#Affine3d getWidgetPose(const String &id) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d getWindowByName(const String &window_name)"><strong>getWindowByName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#String getWindowName() const"><strong>getWindowName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#double cvGetWindowProperty(const char* name, int prop_id)"><strong>GetWindowProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#double getWindowProperty(const String& winname, int prop_id)"><strong>getWindowProperty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#cv2.getWindowProperty"><strong>getWindowProperty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Size getWindowSize() const"><strong>getWindowSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#GFTTDetector : public FeatureDetector"><strong>GFTTDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvGoodFeaturesToTrack(const CvArr* image, CvArr* eig_image, CvArr* temp_image, CvPoint2D32f* corners, int* corner_count, double quality_level, double min_distance, const CvArr* mask, int block_size, int use_harris, double k)"><strong>GoodFeaturesToTrack (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void goodFeaturesToTrack(InputArray image, OutputArray corners, int maxCorners, double qualityLevel, double minDistance, InputArray mask, int blockSize, bool useHarrisDetector, double k)"><strong>goodFeaturesToTrack (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.goodFeaturesToTrack"><strong>goodFeaturesToTrack() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/gr_chalearn.html#GR_chalearn"><strong>GR_chalearn (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/gr_skig.html#GR_skig"><strong>GR_skig (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void grabCut(InputArray img, InputOutputArray mask, Rect rect, InputOutputArray bgdModel, InputOutputArray fgdModel, int iterCount, int mode)"><strong>grabCut (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.grabCut"><strong>grabCut() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#int cvGrabFrame(CvCapture* capture)"><strong>GrabFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddEdge(CvGraph* graph, int start_idx, int end_idx, const CvGraphEdge* edge, CvGraphEdge** inserted_edge)"><strong>GraphAddEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddEdgeByPtr(CvGraph* graph, CvGraphVtx* start_vtx, CvGraphVtx* end_vtx, const CvGraphEdge* edge, CvGraphEdge** inserted_edge)"><strong>GraphAddEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphAddVtx(CvGraph* graph, const CvGraphVtx* vtx, CvGraphVtx** inserted_vtx)"><strong>GraphAddVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphEdgeIdx(CvGraph* graph, CvGraphEdge* edge)"><strong>GraphEdgeIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvGraphRemoveEdge(CvGraph* graph, int start_idx, int end_idx)"><strong>GraphRemoveEdge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvGraphRemoveEdgeByPtr(CvGraph* graph, CvGraphVtx* start_vtx, CvGraphVtx* end_vtx)"><strong>GraphRemoveEdgeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphRemoveVtx(CvGraph* graph, int index)"><strong>GraphRemoveVtx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphRemoveVtxByPtr(CvGraph* graph, CvGraphVtx* vtx)"><strong>GraphRemoveVtxByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxDegree(const CvGraph* graph, int vtx_idx)"><strong>GraphVtxDegree (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxDegreeByPtr(const CvGraph* graph, const CvGraphVtx* vtx)"><strong>GraphVtxDegreeByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvGraphVtxIdx(CvGraph* graph, CvGraphVtx* vtx)"><strong>GraphVtxIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#void groupRectangles(vector<Rect>& rectList, int groupThreshold, double eps)"><strong>groupRectangles (C++ function)</strong></a>, <a href="modules/objdetect/doc/cascade_classification.html#void groupRectangles(vector<Rect>& rectList, vector<int>& weights, int groupThreshold, double eps)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#cv2.groupRectangles"><strong>groupRectangles() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#GuidedFilter : public Algorithm"><strong>GuidedFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void guidedFilter(InputArray guide, InputArray src, OutputArray dst, int radius, double eps, int dDepth)"><strong>guidedFilter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.guidedFilter"><strong>guidedFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.GuidedFilter.filter"><strong>GuidedFilter.filter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void GuidedFilter::filter(InputArray src, OutputArray dst, int dDepth)"><strong>GuidedFilter::filter (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="H">H</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/objdetect/doc/cascade_classification.html#CvSeq* cvHaarDetectObjects(const CvArr* image, CvHaarClassifierCascade* cascade, CvMemStorage* storage, double scale_factor, int min_neighbors, int flags, CvSize min_size, CvSize max_size)"><strong>HaarDetectObjects (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#HausdorffDistanceExtractor : public ShapeDistanceExtractor"><strong>HausdorffDistanceExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/histogram_cost_matrix.html#HistogramCostExtractor : public Algorithm"><strong>HistogramCostExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#CvSeq* cvHoughCircles(CvArr* image, void* circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius)"><strong>HoughCircles (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughCircles(InputArray image, OutputArray circles, int method, double dp, double minDist, double param1, double param2, int minRadius, int maxRadius)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughCircles"><strong>HoughCircles() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughLines(InputArray image, OutputArray lines, double rho, double theta, int threshold, double srn, double stn, double min_theta, double max_theta)"><strong>HoughLines (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughLines"><strong>HoughLines() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#CvSeq* cvHoughLines2(CvArr* image, void* line_storage, int method, double rho, double theta, int threshold, double param1, double param2, double min_theta, double max_theta)"><strong>HoughLines2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void HoughLinesP(InputArray image, OutputArray lines, double rho, double theta, int threshold, double minLineLength, double maxLineGap)"><strong>HoughLinesP (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.HoughLinesP"><strong>HoughLinesP() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/hpe_humaneva.html#HPE_humaneva"><strong>HPE_humaneva (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/hpe_parse.html#HPE_parse"><strong>HPE_parse (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/ipp_async_converters.html#void hpp::copyHppToMat(hppiMatrix* src, Mat& dst, hppAccel accel, int cn)"><strong>hpp::copyHppToMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/ipp_async_converters.html#hppiMatrix* hpp::getHpp(const Mat& src, hppAccel accel)"><strong>hpp::getHpp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/ipp_async_converters.html#Mat hpp::getMat(hppiMatrix* src, hppAccel accel, int cn)"><strong>hpp::getMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void HuMoments(const Moments& m, OutputArray hu)"><strong>HuMoments (C++ function)</strong></a>, <a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void HuMoments(const Moments& moments, double hu[7])"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.HuMoments"><strong>HuMoments() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="I">I</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#ICFDetector"><strong>ICFDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void ICFDetector::detect(const Mat& image, vector<Rect>& objects, float scaleFactor, Size minSize, Size maxSize, float threshold, int slidingStep, std::vector<float>& values)"><strong>ICFDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void ICFDetector::read(const FileNode& node)"><strong>ICFDetector::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void ICFDetector::train(const std::vector<String>& pos_filenames, const std::vector<String>& bg_filenames, ICFDetectorParams params)"><strong>ICFDetector::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void ICFDetector::write(FileStorage& fs) const"><strong>ICFDetector::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void idct(InputArray src, OutputArray dst, int flags)"><strong>idct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.idct"><strong>idct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void idft(InputArray src, OutputArray dst, int flags, int nonzeroRows)"><strong>idft (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.idft"><strong>idft() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/cloning.html#void illuminationChange(InputArray src, InputArray mask, OutputArray dst, float alpha , float beta)"><strong>illuminationChange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#Mat imdecode(InputArray buf, int flags)"><strong>imdecode (C++ function)</strong></a>, <a href="modules/imgcodecs/doc/reading_and_writing_images.html#Mat imdecode(InputArray buf, int flags, Mat* dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#cv2.imdecode"><strong>imdecode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#bool imencode(const String& ext, InputArray img, vector<uchar>& buf, const vector<int>& params)"><strong>imencode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#cv2.imencode"><strong>imencode() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#Mat imread(const String& filename, int flags)"><strong>imread (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#cv2.imread"><strong>imread() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void imshow(const String& winname, InputArray mat)"><strong>imshow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.imshow"><strong>imshow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#bool imwrite(const String& filename, InputArray img, const vector<int>& params)"><strong>imwrite (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#cv2.imwrite"><strong>imwrite() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INCOMPATIBLE_MANAGER_VERSION">INCOMPATIBLE_MANAGER_VERSION (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int cvIncRefData(CvArr* arr)"><strong>IncRefData (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INIT_FAILED">INIT_FAILED (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Mat initCameraMatrix2D(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, double aspectRatio)"><strong>initCameraMatrix2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.initCameraMatrix2D"><strong>initCameraMatrix2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvInitFont(CvFont* font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type)"><strong>InitFont (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* cvInitImageHeader(IplImage* image, CvSize size, int depth, int channels, int origin, int align)"><strong>InitImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvInitIntrinsicParams2D(const CvMat* object_points, const CvMat* image_points, const CvMat* npoints, CvSize image_size, CvMat* camera_matrix, double aspect_ratio)"><strong>InitIntrinsicParams2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvInitMatHeader(CvMat* mat, int rows, int cols, int type, void* data, int step)"><strong>InitMatHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMatND* cvInitMatNDHeader(CvMatND* mat, int dims, const int* sizes, int type, void* data)"><strong>InitMatNDHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSparseNode* cvInitSparseMatIterator(const CvSparseMat* mat, CvSparseMatIterator* mat_iterator)"><strong>InitSparseMatIterator (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvInitTreeNodeIterator(CvTreeNodeIterator* tree_iterator, const void* first, int max_level)"><strong>InitTreeNodeIterator (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvInitUndistortMap(const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvArr* mapx, CvArr* mapy)"><strong>InitUndistortMap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvInitUndistortRectifyMap(const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat * R, const CvMat* new_camera_matrix, CvArr* mapx, CvArr* mapy)"><strong>InitUndistortRectifyMap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void initUndistortRectifyMap(InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2)"><strong>initUndistortRectifyMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.initUndistortRectifyMap"><strong>initUndistortRectifyMap() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#void cvInpaint(const CvArr* src, const CvArr* inpaint_mask, CvArr* dst, double inpaintRange, int flags)"><strong>Inpaint (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#void inpaint(InputArray src, InputArray inpaintMask, OutputArray dst, double inpaintRadius, int flags)"><strong>inpaint (C++ function)</strong></a>, <a href="modules/xphoto/doc/inpainting.html#void inpaint(const Mat &src, const Mat &mask, Mat &dst, const int algorithmType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/inpainting.html#cv2.inpaint"><strong>inpaint() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#InputArray"><strong>InputArray (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvInRange(const CvArr* src, const CvArr* lower, const CvArr* upper, CvArr* dst)"><strong>InRange (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void inRange(InputArray src, InputArray lowerb, InputArray upperb, OutputArray dst)"><strong>inRange (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.inRange"><strong>inRange() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvInRangeS(const CvArr* src, CvScalar lower, CvScalar upper, CvArr* dst)"><strong>InRangeS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void insertImageCOI(InputArray coiimg, CvArr* arr, int coi)"><strong>insertImageCOI (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvInsertNodeIntoTree(void* node, void* parent, void* frame)"><strong>InsertNodeIntoTree (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#INSTALL_CANCELED">INSTALL_CANCELED (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/InstallCallbackInterface.html#InstallCallbackInterface">InstallCallbackInterface (built-in class)</a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvIntegral(const CvArr* image, CvArr* sum, CvArr* sqsum, CvArr* tilted_sum)"><strong>Integral (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, int sdepth)"><strong>integral (C++ function)</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, OutputArray sqsum, int sdepth, int sqdepth)"><strong>[1]</strong></a>, <a href="modules/imgproc/doc/miscellaneous_transformations.html#void integral(InputArray src, OutputArray sum, OutputArray sqsum, OutputArray tilted, int sdepth, int sqdepth)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral"><strong>integral() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral2"><strong>integral2() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.integral3"><strong>integral3() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvInvert(const CvArr* src, CvArr* dst, int method)"><strong>Invert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double invert(InputArray src, OutputArray dst, int flags)"><strong>invert (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.invert"><strong>invert() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void invertAffineTransform(InputArray M, OutputArray iM)"><strong>invertAffineTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.invertAffineTransform"><strong>invertAffineTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage"><strong>IplImage (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int align"><strong>IplImage::align (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int alphaChannel"><strong>IplImage::alphaChannel (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] BorderConst"><strong>IplImage::BorderConst (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int[] BorderMode"><strong>IplImage::BorderMode (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char[] channelSeq"><strong>IplImage::channelSeq (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char[] colorModel"><strong>IplImage::colorModel (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int dataOrder"><strong>IplImage::dataOrder (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int depth"><strong>IplImage::depth (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int height"><strong>IplImage::height (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int ID"><strong>IplImage::ID (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char* imageData"><strong>IplImage::imageData (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#char* imageDataOrigin"><strong>IplImage::imageDataOrigin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void* imageId"><strong>IplImage::imageId (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int imageSize"><strong>IplImage::imageSize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplImage* maskROI"><strong>IplImage::maskROI (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int nChannels"><strong>IplImage::nChannels (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int nSize"><strong>IplImage::nSize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int origin"><strong>IplImage::origin (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#IplROI* roi"><strong>IplImage::roi (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void* tileInfo"><strong>IplImage::tileInfo (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int width"><strong>IplImage::width (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#int widthStep"><strong>IplImage::widthStep (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/ir_affine.html#IR_affine"><strong>IR_affine (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/ir_robot.html#IR_robot"><strong>IR_robot (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/is_bsds.html#IS_bsds"><strong>IS_bsds (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/is_weizmann.html#IS_weizmann"><strong>IS_weizmann (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#bool isContourConvex(InputArray contour)"><strong>isContourConvex (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.isContourConvex"><strong>isContourConvex() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvIsInf(double value)"><strong>IsInf (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvIsNaN(double value)"><strong>IsNaN (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#bool isNan(float x)"><strong>isNan (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(double x)"><strong>[1]</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(const Vec<_Tp, cn>& v)"><strong>[2]</strong></a>, <a href="modules/viz/doc/viz3d.html#bool isNan(const Point3_<_Tp>& p)"><strong>[3]</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="J">J</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#void jointBilateralFilter(InputArray joint, InputArray src, OutputArray dst, int d, double sigmaColor, double sigmaSpace, int borderType)"><strong>jointBilateralFilter (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ximgproc/doc/edge_aware_filters.html#cv2.jointBilateralFilter"><strong>jointBilateralFilter() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="K">K</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const CvMat* cvKalmanCorrect(CvKalman* kalman, const CvMat* measurement)"><strong>KalmanCorrect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter"><strong>KalmanFilter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter"><strong>KalmanFilter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter.correct"><strong>KalmanFilter.correct() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.KalmanFilter.predict"><strong>KalmanFilter.predict() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const Mat& KalmanFilter::correct(const Mat& measurement)"><strong>KalmanFilter::correct (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#void KalmanFilter::init(int dynamParams, int measureParams, int controlParams, int type)"><strong>KalmanFilter::init (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter::KalmanFilter()"><strong>KalmanFilter::KalmanFilter (C++ function)</strong></a>, <a href="modules/video/doc/motion_analysis_and_object_tracking.html#KalmanFilter::KalmanFilter(int dynamParams, int measureParams, int controlParams, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const Mat& KalmanFilter::predict(const Mat& control)"><strong>KalmanFilter::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#const CvMat* cvKalmanPredict(CvKalman* kalman, const CvMat* control)"><strong>KalmanPredict (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#KAZE : public Feature2D"><strong>KAZE (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#KAZE::KAZE(bool extended, bool upright, float threshold, int octaves, int sublevels, int diffusivity)"><strong>KAZE::KAZE (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#KeyboardEvent"><strong>KeyboardEvent (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#KeyboardEvent (Action action, const String& symbol, unsigned char code, Modifiers modifiers)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/line_descriptor/doc/line_descriptor.html#KeyLine"><strong>KeyLine (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#KeyPoint"><strong>KeyPoint (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#cv2.KeyPoint"><strong>KeyPoint() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#float angle"><strong>KeyPoint::angle (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int class_id"><strong>KeyPoint::class_id (C++ member)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#void KeyPoint::convert(const std::vector<KeyPoint>& keypoints, std::vector<Point2f>& points2f, const std::vector<int>& keypointIndexes)"><strong>KeyPoint::convert (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void KeyPoint::convert(const std::vector<Point2f>& points2f, std::vector<KeyPoint>& keypoints, float size, float response, int octave, int class_id)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#KeyPoint::KeyPoint()"><strong>KeyPoint::KeyPoint (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#KeyPoint::KeyPoint(Point2f _pt, float _size, float _angle, float _response, int _octave, int _class_id)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#KeyPoint::KeyPoint(float x, float y, float _size, float _angle, float _response, int _octave, int _class_id)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int octave"><strong>KeyPoint::octave (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#float KeyPoint::overlap(const KeyPoint& kp1, const KeyPoint& kp2)"><strong>KeyPoint::overlap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Point2f pt"><strong>KeyPoint::pt (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#float response"><strong>KeyPoint::response (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#float size"><strong>KeyPoint::size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#cv2.KeyPoint_convert"><strong>KeyPoint_convert() (Python function in cv2)</strong></a>, <a href="modules/core/doc/basic_structures.html#cv2.KeyPoint_convert"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#cv2.KeyPoint_overlap"><strong>KeyPoint_overlap() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#static Camera KinectCamera(const Size &window_size)"><strong>KinectCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#double kmeans(InputArray data, int K, InputOutputArray bestLabels, TermCriteria criteria, int attempts, int flags, OutputArray centers)"><strong>kmeans (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#cv2.kmeans"><strong>kmeans() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#int cvKMeans2(const CvArr* samples, int cluster_count, CvArr* labels, CvTermCriteria termcrit, int attempts, CvRNG* rng, int flags, CvArr* _centers, double* compactness)"><strong>KMeans2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#KNearest : public StatModel"><strong>KNearest (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#Ptr<KNearest> KNearest::create(const Params& params)"><strong>KNearest::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#float KNearest::findNearest(InputArray samples, int k, OutputArray results, OutputArray neighborResponses, OutputArray dist) const"><strong>KNearest::findNearest (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#int KNearest::getDefaultK() const"><strong>KNearest::getDefaultK (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/k_nearest_neighbors.html#void KNearest::setDefaultK(int k)"><strong>KNearest::setDefaultK (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="L">L</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvLaplace(const CvArr* src, CvArr* dst, int aperture_size)"><strong>Laplace (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void Laplacian(InputArray src, OutputArray dst, int ddepth, int ksize, double scale, double delta, int borderType)"><strong>Laplacian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Laplacian"><strong>Laplacian() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvLine(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)"><strong>Line (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void line(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)"><strong>line (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.line"><strong>line() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvLinearPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double maxRadius, int flags)"><strong>LinearPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#LineIterator"><strong>LineIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#LineSegmentDetector : public Algorithm"><strong>LineSegmentDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#int LineSegmentDetector::compareSegments(const Size& size, InputArray lines1, InputArray lines2, InputOutputArray _image)"><strong>LineSegmentDetector::compareSegments (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void LineSegmentDetector::detect(const InputArray _image, OutputArray _lines, OutputArray width , OutputArray prec , OutputArray nfa)"><strong>LineSegmentDetector::detect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void LineSegmentDetector::drawSegments(InputOutputArray _image, InputArray lines)"><strong>LineSegmentDetector::drawSegments (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvLoad(const char* filename, CvMemStorage* memstorage, const char* name, const char** real_name)"><strong>Load (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#static Mesh load(const String& file)"><strong>load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#Ptr<ERFilter::Callback> loadClassifierNM1(const std::string& filename)"><strong>loadClassifierNM1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#Ptr<ERFilter::Callback> loadClassifierNM2(const std::string& filename)"><strong>loadClassifierNM2 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#LoaderCallbackInterface">LoaderCallbackInterface (built-in class)</a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Ptr<TrainData> loadFromCSV(const String& filename, int headerLineCount, int responseStartIdx, int responseEndIdx, const String& varTypeSpec, char delimiter,', char missch)"><strong>loadFromCSV (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#IplImage* cvLoadImage(const char* filename, int iscolor)"><strong>LoadImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#CvMat* cvLoadImageM(const char* filename, int iscolor)"><strong>LoadImageM (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#Ptr<OCRHMMDecoder::ClassifierCallback> loadOCRHMMClassifierNM(const std::string& filename)"><strong>loadOCRHMMClassifierNM (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvLoadWindowParameters(const char* name)"><strong>LoadWindowParameters (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void loadWindowParameters(const String& windowName)"><strong>loadWindowParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvLog(const CvArr* src, CvArr* dst)"><strong>Log (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void log(InputArray src, OutputArray dst)"><strong>log (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.log"><strong>log() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#LogisticRegression : public StatModel"><strong>LogisticRegression (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#Ptr<LogisticRegression> LogisticRegression::create(const Params& params)"><strong>LogisticRegression::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#Mat LogisticRegression::get_learnt_thetas() const"><strong>LogisticRegression::get_learnt_thetas (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#LogisticRegression::Params"><strong>LogisticRegression::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#double alpha"><strong>LogisticRegression::Params::alpha (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#int mini_batch_size"><strong>LogisticRegression::Params::mini_batch_size (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#int norm"><strong>LogisticRegression::Params::norm (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#int num_iters"><strong>LogisticRegression::Params::num_iters (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#LogisticRegression::Params::Params(double learning_rate , int iters , int method , int normlization , int reg , int batch_size)"><strong>LogisticRegression::Params::Params (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#int regularized"><strong>LogisticRegression::Params::regularized (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#cv::TermCriteria term_crit"><strong>LogisticRegression::Params::term_crit (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#int train_method"><strong>LogisticRegression::Params::train_method (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#void LogisticRegression::predict(InputArray samples, OutputArray results, int flags) const"><strong>LogisticRegression::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#void LogisticRegression::read(const FileNode& fn)"><strong>LogisticRegression::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#bool LogisticRegression::train(const Ptr<TrainData>& trainData, int flags)"><strong>LogisticRegression::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/logistic_regression.html#void LogisticRegression::write(FileStorage& fs) const"><strong>LogisticRegression::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvLogPolar(const CvArr* src, CvArr* dst, CvPoint2D32f center, double M, int flags)"><strong>LogPolar (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/LSDDetector.html#Ptr<LSDDetector> LSDDetector::createLSDDetector()"><strong>LSDDetector::createLSDDetector (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/line_descriptor/doc/LSDDetector.html#void LSDDetector::detect(const Mat& image, std::vector<KeyLine>& keylines, int scale, int numOctaves, const Mat& mask)"><strong>LSDDetector::detect (C++ function)</strong></a>, <a href="modules/line_descriptor/doc/LSDDetector.html#void LSDDetector::detect(const std::vector<Mat>& images, std::vector<std::vector<KeyLine> >& keylines, int scale, int numOctaves, const std::vector<Mat>& masks) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvLUT(const CvArr* src, CvArr* dst, const CvArr* lut)"><strong>LUT (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#void LUT(InputArray src, InputArray lut, OutputArray dst)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.LUT"><strong>LUT() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="M">M</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void magnitude(InputArray x, InputArray y, OutputArray magnitude)"><strong>magnitude (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.magnitude"><strong>magnitude() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvMahalanobis(const CvArr* vec1, const CvArr* vec2, const CvArr* mat)"><strong>Mahalanobis (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#double Mahalanobis(InputArray v1, InputArray v2, InputArray icovar)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.Mahalanobis"><strong>Mahalanobis() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Affine3d makeCameraPose(const Vec3f& position, const Vec3f& focal_point, const Vec3f& y_dir)"><strong>makeCameraPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#CvHistogram* cvMakeHistHeaderForArray(int dims, int* sizes, CvHistogram* hist, float* data, float** ranges, int uniform)"><strong>MakeHistHeaderForArray (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> Ptr<T> makePtr()"><strong>makePtr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, typename A1> Ptr<T> makePtr(const A1& a1)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, typename A1, typename A2> Ptr<T> makePtr(const A1& a1, const A2& a2)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, typename A1, typename A2, typename A3> Ptr<T> makePtr(const A1& a1, const A2& a2, const A3& a3)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvMakeSeqHeaderForArray(int seq_type, int header_size, int elem_size, void* elements, int total, CvSeq* seq, CvSeqBlock* block)"><strong>MakeSeqHeaderForArray (C function)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#MARKET_ERROR">MARKET_ERROR (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat cvMat(int rows, int cols, int type, void* data)"><strong>Mat (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/basic_structures.html#Mat"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::addref()"><strong>Mat::addref (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::adjustROI(int dtop, int dbottom, int dleft, int dright)"><strong>Mat::adjustROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::assignTo(Mat& m, int type) const"><strong>Mat::assignTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i) const"><strong>Mat::at (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i, int j)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i, int j) const"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(Point pt)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(Point pt) const"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(int i, int j, int k)"><strong>[6]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(int i, int j, int k) const"><strong>[7]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> T& Mat::at(const int* idx)"><strong>[8]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> const T& Mat::at(const int* idx) const"><strong>[9]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatIterator_<_Tp> Mat::begin()"><strong>Mat::begin (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatConstIterator_<_Tp> Mat::begin() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::channels() const"><strong>Mat::channels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::clone() const"><strong>Mat::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::col(int x) const"><strong>Mat::col (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::colRange(int startcol, int endcol) const"><strong>Mat::colRange (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::colRange(const Range& r) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::convertTo(OutputArray m, int rtype, double alpha, double beta) const"><strong>Mat::convertTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::copyTo(OutputArray m) const"><strong>Mat::copyTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::copyTo(OutputArray m, InputArray mask) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::create(int rows, int cols, int type)"><strong>Mat::create (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::create(Size size, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::create(int ndims, const int* sizes, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::cross(InputArray m) const"><strong>Mat::cross (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::depth() const"><strong>Mat::depth (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::diag(int d) const"><strong>Mat::diag (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static Mat Mat::diag(const Mat& d)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#double Mat::dot(InputArray m) const"><strong>Mat::dot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::elemSize() const"><strong>Mat::elemSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::elemSize1() const"><strong>Mat::elemSize1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#bool Mat::empty() const"><strong>Mat::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatIterator_<_Tp> Mat::end()"><strong>Mat::end (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> MatConstIterator_<_Tp> Mat::end() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::eye(int rows, int cols, int type)"><strong>Mat::eye (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::eye(Size size, int type)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename _Tp, typename Functor> void Mat::forEach(Functor operation)"><strong>Mat::forEach (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp, typename Functor> void Mat::forEach(Functor operation) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::inv(int method) const"><strong>Mat::inv (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#bool Mat::isContinuous() const"><strong>Mat::isContinuous (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::locateROI(Size& wholeSize, Point& ofs) const"><strong>Mat::locateROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::Mat()"><strong>Mat::Mat (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type, const Scalar& s)"><strong>[3]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type, const Scalar& s)"><strong>[4]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m)"><strong>[5]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int rows, int cols, int type, void* data, size_t step)"><strong>[6]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(Size size, int type, void* data, size_t step)"><strong>[7]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Range& rowRange, const Range& colRange)"><strong>[8]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Rect& roi)"><strong>[9]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, int n> explicit Mat::Mat(const Vec<T, n>& vec, bool copyData)"><strong>[10]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T, int m, int n> explicit Mat::Mat(const Matx<T, m, n>& vec, bool copyData)"><strong>[11]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename T> explicit Mat::Mat(const vector<T>& vec, bool copyData)"><strong>[12]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type)"><strong>[13]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type, const Scalar& s)"><strong>[14]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps)"><strong>[15]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat::Mat(const Mat& m, const Range* ranges)"><strong>[16]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::mul(InputArray m, double scale) const"><strong>Mat::mul (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(int rows, int cols, int type)"><strong>Mat::ones (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(Size size, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::ones(int ndims, const int* sz, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(Range rowRange, Range colRange) const"><strong>Mat::operator() (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(const Rect& roi) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::operator()(const Range* ranges) const"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::operator = (const Mat& m)"><strong>Mat::operator= (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat& Mat::operator =(const MatExpr& expr)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat& Mat::operator = (const Scalar& s)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> void Mat::pop_back(size_t nelems)"><strong>Mat::pop_back (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#uchar* Mat::ptr(int i0)"><strong>Mat::ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#const uchar* Mat::ptr(int i0) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> _Tp* Mat::ptr(int i0)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename _Tp> const _Tp* Mat::ptr(int i0) const"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> void Mat::push_back(const T& elem)"><strong>Mat::push_back (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::push_back(const Mat& m)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::release()"><strong>Mat::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::reserve(size_t sz)"><strong>Mat::reserve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::reshape(int cn, int rows) const"><strong>Mat::reshape (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Mat::resize(size_t sz)"><strong>Mat::resize (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void Mat::resize(size_t sz, const Scalar& s)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::row(int y) const"><strong>Mat::row (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat Mat::rowRange(int startrow, int endrow) const"><strong>Mat::rowRange (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Mat Mat::rowRange(const Range& r) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat& Mat::setTo(InputArray value, InputArray mask)"><strong>Mat::setTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Size Mat::size() const"><strong>Mat::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::step1(int i) const"><strong>Mat::step1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#MatExpr Mat::t() const"><strong>Mat::t (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t Mat::total() const"><strong>Mat::total (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int Mat::type() const"><strong>Mat::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(int rows, int cols, int type)"><strong>Mat::zeros (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(Size size, int type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#static MatExpr Mat::zeros(int ndims, const int* sz, int type)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat::~Mat()"><strong>Mat::~Mat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Mat_"><strong>Mat_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvMatchShapes(const void* object1, const void* object2, int method, double parameter)"><strong>MatchShapes (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double matchShapes(InputArray contour1, InputArray contour2, int method, double parameter)"><strong>matchShapes (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.matchShapes"><strong>matchShapes() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#void cvMatchTemplate(const CvArr* image, const CvArr* templ, CvArr* result, int method)"><strong>MatchTemplate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#void matchTemplate(InputArray image, InputArray templ, OutputArray result, int method)"><strong>matchTemplate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/object_detection.html#cv2.matchTemplate"><strong>matchTemplate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void matMulDeriv(InputArray A, InputArray B, OutputArray dABdA, OutputArray dABdB)"><strong>matMulDeriv (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.matMulDeriv"><strong>matMulDeriv() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Matx"><strong>Matx (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMax(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>Max (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr max(const Mat& a, const Mat& b)"><strong>max (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr max(const Mat& a, double s)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr max(double s, const Mat& a)"><strong>[2]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void max(InputArray src1, InputArray src2, OutputArray dst)"><strong>[3]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void max(const Mat& src1, const Mat& src2, Mat& dst)"><strong>[4]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.max"><strong>max() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMaxS(const CvArr* src, double value, CvArr* dst)"><strong>MaxS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar mean(InputArray src, InputArray mask)"><strong>mean (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mean"><strong>mean() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int cvMeanShift(const CvArr* prob_image, CvRect window, CvTermCriteria criteria, CvConnectedComp* comp)"><strong>MeanShift (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#int meanShift(InputArray probImage, Rect& window, TermCriteria criteria)"><strong>meanShift (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/video/doc/motion_analysis_and_object_tracking.html#cv2.meanShift"><strong>meanShift() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void meanStdDev(InputArray src, OutputArray mean, OutputArray stddev, InputArray mask)"><strong>meanStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.meanStdDev"><strong>meanStdDev() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void medianBlur(InputArray src, OutputArray dst, int ksize)"><strong>medianBlur (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.medianBlur"><strong>medianBlur() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvMemStorageAlloc(CvMemStorage* storage, size_t size)"><strong>MemStorageAlloc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvString cvMemStorageAllocString(CvMemStorage* storage, const char* ptr, int len)"><strong>MemStorageAllocString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMerge(const CvArr* src0, const CvArr* src1, const CvArr* src2, const CvArr* src3, CvArr* dst)"><strong>Merge (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void merge(const Mat* mv, size_t count, OutputArray dst)"><strong>merge (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void merge(InputArrayOfArrays mv, OutputArray dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.merge"><strong>merge() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#MergeDebevec : public MergeExposures"><strong>MergeDebevec (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#MergeExposures : public Algorithm"><strong>MergeExposures (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void MergeExposures::process(InputArrayOfArrays src, OutputArray dst, InputArray times, InputArray response)"><strong>MergeExposures::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#MergeMertens : public MergeExposures"><strong>MergeMertens (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void MergeMertens::process(InputArrayOfArrays src, OutputArray dst)"><strong>MergeMertens::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#MergeRobertson : public MergeExposures"><strong>MergeRobertson (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Mesh"><strong>Mesh (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvmGet(const CvMat* mat, int row, int col)"><strong>mGet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMin(const CvArr* src1, const CvArr* src2, CvArr* dst)"><strong>Min (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#MatExpr min(const Mat& a, const Mat& b)"><strong>min (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr min(const Mat& a, double s)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#MatExpr min(double s, const Mat& a)"><strong>[2]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void min(InputArray src1, InputArray src2, OutputArray dst)"><strong>[3]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void min(const Mat& src1, const Mat& src2, Mat& dst)"><strong>[4]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.min"><strong>min() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#RotatedRect minAreaRect(InputArray points)"><strong>minAreaRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.minAreaRect"><strong>minAreaRect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#CvBox2D cvMinAreaRect2(const CvArr* points, CvMemStorage* storage)"><strong>MinAreaRect2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int cvMinEnclosingCircle(const CvArr* points, CvPoint2D32f* center, float* radius)"><strong>MinEnclosingCircle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void minEnclosingCircle(InputArray points, Point2f& center, float& radius)"><strong>minEnclosingCircle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.minEnclosingCircle"><strong>minEnclosingCircle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double minEnclosingTriangle(InputArray points, OutputArray triangle)"><strong>minEnclosingTriangle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.minEnclosingTriangle"><strong>minEnclosingTriangle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void minMaxIdx(InputArray src, double* minVal, double* maxVal , int* minIdx, int* maxIdx, InputArray mask)"><strong>minMaxIdx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMinMaxLoc(const CvArr* arr, double* min_val, double* max_val, CvPoint* min_loc, CvPoint* max_loc, const CvArr* mask)"><strong>MinMaxLoc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void minMaxLoc(InputArray src, double* minVal, double* maxVal, Point* minLoc, Point* maxLoc, InputArray mask)"><strong>minMaxLoc (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void minMaxLoc(const SparseMat& a, double* minVal, double* maxVal, int* minIdx, int* maxIdx)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.minMaxLoc"><strong>minMaxLoc() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMinS(const CvArr* src, double value, CvArr* dst)"><strong>MinS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMixChannels(const CvArr** src, int src_count, CvArr** dst, int dst_count, const int* from_to, int pair_count)"><strong>MixChannels (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mixChannels(const Mat* src, size_t nsrcs, Mat* dst, size_t ndsts, const int* fromTo, size_t npairs)"><strong>mixChannels (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const int* fromTo, size_t npairs)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void mixChannels(InputArrayOfArrays src, InputOutputArrayOfArrays dst, const std::vector<int>& fromTo)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mixChannels"><strong>mixChannels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#void cvMoments(const CvArr* arr, CvMoments* moments, int binary)"><strong>Moments (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#Moments moments(InputArray array, bool binaryImage)"><strong>moments (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.moments"><strong>moments() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvMorphologyEx(const CvArr* src, CvArr* dst, CvArr* temp, IplConvKernel* element, int operation, int iterations)"><strong>MorphologyEx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void morphologyEx(InputArray src, OutputArray dst, int op, InputArray kernel, Point anchor, int iterations, int borderType, const Scalar& borderValue)"><strong>morphologyEx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.morphologyEx"><strong>morphologyEx() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/saliency_categories.html#MotionSaliency"><strong>MotionSaliency (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/motion_saliency_algorithms.html#MotionSaliencyBinWangApr2014"><strong>MotionSaliencyBinWangApr2014 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/motion_saliency_algorithms.html#bool MotionSaliencyBinWangApr2014::computeSaliencyImpl(const InputArray image, OutputArray saliencyMap)"><strong>MotionSaliencyBinWangApr2014::computeSaliencyImpl (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/motion_saliency_algorithms.html#bool MotionSaliencyBinWangApr2014::init()"><strong>MotionSaliencyBinWangApr2014::init (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/motion_saliency_algorithms.html#MotionSaliencyBinWangApr2014::MotionSaliencyBinWangApr2014()"><strong>MotionSaliencyBinWangApr2014::MotionSaliencyBinWangApr2014 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/motion_saliency_algorithms.html#void MotionSaliencyBinWangApr2014::setImagesize(int W, int H)"><strong>MotionSaliencyBinWangApr2014::setImagesize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#MouseEvent"><strong>MouseEvent (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/viz3d.html#MouseEvent (const Type& type, const MouseButton& button, const Point& p, Modifiers modifiers)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvMoveWindow(const char* name, int x, int y)"><strong>MoveWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void moveWindow(const String& winname, int x, int y)"><strong>moveWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.moveWindow"><strong>moveWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#MSER : public Feature2D"><strong>MSER (C++ class)</strong></a>, <a href="modules/features2d/doc/feature_detection_and_description.html#MSER : public FeatureDetector"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/erfilter.html#void MSERsToERStats(InputArray image, vector< vector<Point> > &contours, vector< vector<ERStat> > &regions)"><strong>MSERsToERStats (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvmSet(CvMat* mat, int row, int col, double value)"><strong>mSet (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/msm_epfl.html#MSM_epfl"><strong>MSM_epfl (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/msm_middlebury.html#MSM_middlebury"><strong>MSM_middlebury (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMul(const CvArr* src1, const CvArr* src2, CvArr* dst, double scale)"><strong>Mul (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMulSpectrums(const CvArr* src1, const CvArr* src2, CvArr* dst, int flags)"><strong>MulSpectrums (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mulSpectrums(InputArray a, InputArray b, OutputArray c, int flags, bool conjB)"><strong>mulSpectrums (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mulSpectrums"><strong>mulSpectrums() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void multiply(InputArray src1, InputArray src2, OutputArray dst, double scale, int dtype)"><strong>multiply (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.multiply"><strong>multiply() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvMultiplyAcc(const CvArr* image1, const CvArr* image2, CvArr* acc, const CvArr* mask)"><strong>MultiplyAcc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvMulTransposed(const CvArr* src, CvArr* dst, int order, const CvArr* delta, double scale)"><strong>MulTransposed (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void mulTransposed(InputArray src, OutputArray dst, bool aTa, InputArray delta, double scale, int dtype)"><strong>mulTransposed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.mulTransposed"><strong>mulTransposed() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="N">N</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvNamedWindow(const char* name, int flags)"><strong>NamedWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void namedWindow(const String& winname, int flags)"><strong>namedWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.namedWindow"><strong>namedWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#NAryMatIterator"><strong>NAryMatIterator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvNextGraphItem(CvGraphScanner* scanner)"><strong>NextGraphItem (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvNextTreeNode(CvTreeNodeIterator* tree_iterator)"><strong>NextTreeNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double cvNorm(const CvArr* arr1, const CvArr* arr2, int norm_type, const CvArr* mask)"><strong>Norm (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double norm(InputArray src1, int normType, InputArray mask)"><strong>norm (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#double norm(InputArray src1, InputArray src2, int normType, InputArray mask)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#double norm(const SparseMat& src, int normType)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.norm"><strong>norm() (Python function in cv2)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#cv2.norm"><strong>[1]</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#NormalBayesClassifier : public StatModel"><strong>NormalBayesClassifier (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#Ptr<NormalBayesClassifier> NormalBayesClassifier::create(const NormalBayesClassifier::Params& params)"><strong>NormalBayesClassifier::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/normal_bayes_classifier.html#float NormalBayesClassifier::predictProb(InputArray inputs, OutputArray outputs, OutputArray outputProbs, int flags) const"><strong>NormalBayesClassifier::predictProb (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void normalize(InputArray src, InputOutputArray dst, double alpha, double beta, int norm_type, int dtype, InputArray mask)"><strong>normalize (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void normalize(const SparseMat& src, SparseMat& dst, double alpha, int normType)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.normalize"><strong>normalize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvNormalizeHist(CvHistogram* hist, double factor)"><strong>NormalizeHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/histogram_cost_matrix.html#NormHistogramCostExtractor : public HistogramCostExtractor"><strong>NormHistogramCostExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvNot(const CvArr* src, CvArr* dst)"><strong>Not (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="O">O</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/saliency/doc/saliency_categories.html#Objectness"><strong>Objectness (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#ObjectnessBING"><strong>ObjectnessBING (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#bool ObjectnessBING::computeSaliencyImpl(const InputArray image, OutputArray objectnessBoundingBox)"><strong>ObjectnessBING::computeSaliencyImpl (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#vector<float> ObjectnessBING::getobjectnessValues()"><strong>ObjectnessBING::getobjectnessValues (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#ObjectnessBING::ObjectnessBING()"><strong>ObjectnessBING::ObjectnessBING (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#void ObjectnessBING::setBBResDir(string resultsDir)"><strong>ObjectnessBING::setBBResDir (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/objectness_algorithms.html#void ObjectnessBING::setTrainingPath(string trainingPath)"><strong>ObjectnessBING::setTrainingPath (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#OCRHMMDecoder : public BaseOCR"><strong>OCRHMMDecoder (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#OCRHMMDecoder::ClassifierCallback"><strong>OCRHMMDecoder::ClassifierCallback (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#void OCRHMMDecoder::ClassifierCallback::eval(InputArray image, std::vector<int>& out_class, std::vector<double>& out_confidence)"><strong>OCRHMMDecoder::ClassifierCallback::eval (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#Ptr<OCRHMMDecoder> OCRHMMDecoder::create(const Ptr<OCRHMMDecoder::ClassifierCallback> classifier, const std::string& vocabulary, InputArray transition_probabilities_table, InputArray emission_probabilities_table, decoder_mode mode)"><strong>OCRHMMDecoder::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#void OCRHMMDecoder::run(Mat& image, string& output_text, vector<Rect>* component_rects, vector<string>* component_texts, vector<float>* component_confidences, int component_level)"><strong>OCRHMMDecoder::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#OCRTesseract : public BaseOCR"><strong>OCRTesseract (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#Ptr<OCRTesseract> OCRTesseract::create(const char* datapath, const char* language, const char* char_whitelist, int oem=(int)tesseract::OEM_DEFAULT, int psmode=(int)tesseract::PSM_AUTO)"><strong>OCRTesseract::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/text/doc/ocr.html#void OCRTesseract::run(Mat& image, string& output_text, vector<Rect>* component_rects, vector<string>* component_texts, vector<float>* component_confidences, int component_level)"><strong>OCRTesseract::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Arrays"><strong>ogl::Arrays (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::bind() const"><strong>ogl::Arrays::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::release()"><strong>ogl::Arrays::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetColorArray()"><strong>ogl::Arrays::resetColorArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetNormalArray()"><strong>ogl::Arrays::resetNormalArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetTexCoordArray()"><strong>ogl::Arrays::resetTexCoordArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::resetVertexArray()"><strong>ogl::Arrays::resetVertexArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setAutoRelease(bool flag)"><strong>ogl::Arrays::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setColorArray(InputArray color)"><strong>ogl::Arrays::setColorArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setNormalArray(InputArray normal)"><strong>ogl::Arrays::setNormalArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setTexCoordArray(InputArray texCoord)"><strong>ogl::Arrays::setTexCoordArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Arrays::setVertexArray(InputArray vertex)"><strong>ogl::Arrays::setVertexArray (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#int ogl::Arrays::size() const"><strong>ogl::Arrays::size (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer"><strong>ogl::Buffer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::bind(Target target) const"><strong>ogl::Buffer::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer()"><strong>ogl::Buffer::Buffer (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(int arows, int acols, int atype, unsigned int abufId, bool autoRelease)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(Size asize, int atype, unsigned int abufId, bool autoRelease)"><strong>[2]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(int arows, int acols, int atype, Target target , bool autoRelease)"><strong>[3]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(Size asize, int atype, Target target , bool autoRelease)"><strong>[4]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Buffer(InputArray arr, Target target , bool autoRelease)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#Buffer ogl::Buffer::clone(Target target , bool autoRelease) const"><strong>ogl::Buffer::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::copyFrom(InputArray arr, Target target , bool autoRelease)"><strong>ogl::Buffer::copyFrom (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::copyTo(OutputArray arr) const"><strong>ogl::Buffer::copyTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::create(int arows, int acols, int atype, Target target , bool autoRelease)"><strong>ogl::Buffer::create (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::create(Size asize, int atype, Target target , bool autoRelease)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#cuda::GpuMat ogl::Buffer::mapDevice()"><strong>ogl::Buffer::mapDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#Mat ogl::Buffer::mapHost(Access access)"><strong>ogl::Buffer::mapHost (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::release()"><strong>ogl::Buffer::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::setAutoRelease(bool flag)"><strong>ogl::Buffer::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Buffer::Target"><strong>ogl::Buffer::Target (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#static void ogl::Buffer::unbind(Target target)"><strong>ogl::Buffer::unbind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::unmapDevice()"><strong>ogl::Buffer::unmapDevice (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Buffer::unmapHost()"><strong>ogl::Buffer::unmapHost (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::render(const Texture2D& tex, Rect_<double> wndRect , Rect_<double> texRect)"><strong>ogl::render (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::render(const Arrays& arr, int mode , Scalar color)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::render(const Arrays& arr, InputArray indices, int mode , Scalar color)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D"><strong>ogl::Texture2D (C++ class)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::bind() const"><strong>ogl::Texture2D::bind (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::copyFrom(InputArray arr, bool autoRelease)"><strong>ogl::Texture2D::copyFrom (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::copyTo(OutputArray arr, int ddepth , bool autoRelease) const"><strong>ogl::Texture2D::copyTo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::create(int arows, int acols, Format aformat, bool autoRelease)"><strong>ogl::Texture2D::create (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::create(Size asize, Format aformat, bool autoRelease)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Format"><strong>ogl::Texture2D::Format (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::release()"><strong>ogl::Texture2D::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#void ogl::Texture2D::setAutoRelease(bool flag)"><strong>ogl::Texture2D::setAutoRelease (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D()"><strong>ogl::Texture2D::Texture2D (C++ function)</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(int arows, int acols, Format aformat, unsigned int atexId, bool autoRelease)"><strong>[1]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(Size asize, Format aformat, unsigned int atexId, bool autoRelease)"><strong>[2]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(int arows, int acols, Format aformat, bool autoRelease)"><strong>[3]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(Size asize, Format aformat, bool autoRelease)"><strong>[4]</strong></a>, <a href="modules/core/doc/opengl_interop.html#ogl::Texture2D::Texture2D(InputArray arr, bool autoRelease)"><strong>[5]</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_2">OPENCV_VERSION_2_4_2 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_3">OPENCV_VERSION_2_4_3 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_4">OPENCV_VERSION_2_4_4 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_5">OPENCV_VERSION_2_4_5 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_6">OPENCV_VERSION_2_4_6 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_7">OPENCV_VERSION_2_4_7 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OPENCV_VERSION_2_4_8">OPENCV_VERSION_2_4_8 (built-in variable)</a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/JavaHelper.html#OpenCVLoader">OpenCVLoader (built-in class)</a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvFileStorage* cvOpenFileStorage(const char* filename, CvMemStorage* memstorage, int flags, const char* encoding)"><strong>OpenFileStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> bool operator != (const Ptr<T>& ptr1, const Ptr<T>& ptr2)"><strong>operator!= (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const _Tp& value)"><strong>operator&lt;&lt; (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileStorage& operator << (FileStorage& fs, const vector<_Tp>& vec)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> bool operator == (const Ptr<T>& ptr1, const Ptr<T>& ptr2)"><strong>operator== (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> void operator >> (const FileNode& n, _Tp& value)"><strong>operator&gt;&gt; (C++ function)</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> void operator >> (const FileNode& n, vector<_Tp>& vec)"><strong>[1]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, _Tp& value)"><strong>[2]</strong></a>, <a href="modules/core/doc/xml_yaml_persistence.html#template<typename _Tp> FileNodeIterator& operator >> (FileNodeIterator& it, vector<_Tp>& vec)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#Ptr<DenseOpticalFlow> optflow::createOptFlow_DeepFlow()"><strong>optflow::createOptFlow_DeepFlow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#optflow::OpticalFlowDeepFlow: public DenseOpticalFlow"><strong>optflow::OpticalFlowDeepFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float alpha"><strong>optflow::OpticalFlowDeepFlow::alpha (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float delta"><strong>optflow::OpticalFlowDeepFlow::delta (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float downscaleFactor"><strong>optflow::OpticalFlowDeepFlow::downscaleFactor (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#int fixedPointIterations"><strong>optflow::OpticalFlowDeepFlow::fixedPointIterations (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float gamma"><strong>optflow::OpticalFlowDeepFlow::gamma (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#int minSize"><strong>optflow::OpticalFlowDeepFlow::minSize (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float omega"><strong>optflow::OpticalFlowDeepFlow::omega (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#float sigma"><strong>optflow::OpticalFlowDeepFlow::sigma (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/dense_optflow.html#int sorIterations"><strong>optflow::OpticalFlowDeepFlow::sorIterations (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvOr(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Or (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/or_imagenet.html#OR_imagenet"><strong>OR_imagenet (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/or_mnist.html#OR_mnist"><strong>OR_mnist (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/or_sun.html#OR_sun"><strong>OR_sun (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#ORB : public Feature2D"><strong>ORB (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.ORB"><strong>ORB() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.ORB.compute"><strong>ORB.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.ORB.detect"><strong>ORB.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#cv2.ORB.detectAndCompute"><strong>ORB.detectAndCompute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#void ORB::operator()(InputArray image, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints) const"><strong>ORB::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#ORB::ORB(int nfeatures , float scaleFactor , int nlevels , int edgeThreshold , int firstLevel , int WTA_K, int scoreType, int patchSize)"><strong>ORB::ORB (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvOrS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>OrS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#OutputArray : public InputArray"><strong>OutputArray (C++ class)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="P">P</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/ml/doc/support_vector_machines.html#ParamGrid"><strong>ParamGrid (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#ParamGrid::ParamGrid()"><strong>ParamGrid::ParamGrid (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#ParamGrid::ParamGrid(double minVal, double maxVal, double logStep)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double ParamGrid::logStep"><strong>ParamGrid::ParamGrid::logStep (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double ParamGrid::maxVal"><strong>ParamGrid::ParamGrid::maxVal (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double ParamGrid::minVal"><strong>ParamGrid::ParamGrid::minVal (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/clustering.html#template<typename _Tp, class _EqPredicate> int partition(const vector<_Tp>& vec, vector<int>& labels, _EqPredicate predicate)"><strong>partition (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA"><strong>PCA (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat PCA::backProject(InputArray vec) const"><strong>PCA::backProject (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void PCA::backProject(InputArray vec, OutputArray result) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA& PCA::operator()(InputArray data, InputArray mean, int flags, int maxComponents)"><strong>PCA::operator() (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#PCA& PCA::operator()(InputArray data, InputArray mean, int flags, double retainedVariance)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#PCA::PCA()"><strong>PCA::PCA (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#PCA::PCA(InputArray data, InputArray mean, int flags, int maxComponents)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#PCA::PCA(InputArray data, InputArray mean, int flags, double retainedVariance)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Mat PCA::project(InputArray vec) const"><strong>PCA::project (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void PCA::project(InputArray vec, OutputArray result) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCABackProject"><strong>PCABackProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCACompute"><strong>PCACompute() (Python function in cv2)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#cv2.PCACompute"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.PCAProject"><strong>PCAProject() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/pd_caltech.html#PD_caltech"><strong>PD_caltech (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/npr.html#void pencilSketch(InputArray src, OutputArray dst1, OutputArray dst2, float sigma_s , float sigma_r , float shade_factor)"><strong>pencilSketch (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPerspectiveTransform(const CvArr* src, CvArr* dst, const CvMat* mat)"><strong>PerspectiveTransform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void perspectiveTransform(InputArray src, OutputArray dst, InputArray m)"><strong>perspectiveTransform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.perspectiveTransform"><strong>perspectiveTransform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void phase(InputArray x, InputArray y, OutputArray angle, bool angleInDegrees)"><strong>phase (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.phase"><strong>phase() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#Point2d phaseCorrelate(InputArray src1, InputArray src2, InputArray window , double* response)"><strong>phaseCorrelate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#PlaneWarper : public WarperCreator"><strong>PlaneWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint cvPoint(int x, int y)"><strong>Point (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f cvPoint2D32f(double x, double y)"><strong>Point2D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D64f cvPoint2D64f(double x, double y)"><strong>Point2D64f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Point3_"><strong>Point3_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D32f cvPoint3D32f(double x, double y, double z)"><strong>Point3D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint3D64f cvPoint3D64f(double x, double y, double z)"><strong>Point3D64f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Point_"><strong>Point_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint cvPointFrom32f(CvPoint2D32f point)"><strong>PointFrom32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double cvPointPolygonTest(const CvArr* contour, CvPoint2D32f pt, int measure_dist)"><strong>PointPolygonTest (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#double pointPolygonTest(InputArray contour, Point2f pt, bool measureDist)"><strong>pointPolygonTest (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.pointPolygonTest"><strong>pointPolygonTest() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvPoint2D32f cvPointTo32f(CvPoint point)"><strong>PointTo32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPolarToCart(const CvArr* magnitude, const CvArr* angle, CvArr* x, CvArr* y, int angle_in_degrees)"><strong>PolarToCart (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void polarToCart(InputArray magnitude, InputArray angle, OutputArray x, OutputArray y, bool angleInDegrees)"><strong>polarToCart (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.polarToCart"><strong>polarToCart() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvPolyLine(CvArr* img, CvPoint** pts, const int* npts, int contours, int is_closed, CvScalar color, int thickness, int line_type, int shift)"><strong>PolyLine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void polylines(Mat& img, const Point* const* pts, const int* npts, int ncontours, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"><strong>polylines (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#void polylines(InputOutputArray img, InputArrayOfArrays pts, bool isClosed, const Scalar& color, int thickness, int lineType, int shift)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.polylines"><strong>polylines() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvPow(const CvArr* src, CvArr* dst, double power)"><strong>Pow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void pow(InputArray src, double power, OutputArray dst)"><strong>pow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.pow"><strong>pow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void cvPreCornerDetect(const CvArr* image, CvArr* corners, int aperture_size)"><strong>PreCornerDetect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#void preCornerDetect(InputArray src, OutputArray dst, int ksize, int borderType)"><strong>preCornerDetect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/feature_detection.html#cv2.preCornerDetect"><strong>preCornerDetect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void* cvPrevTreeNode(CvTreeNodeIterator* tree_iterator)"><strong>PrevTreeNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian, double aspectRatio)"><strong>projectPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.projectPoints"><strong>projectPoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvProjectPoints2(const CvMat* object_points, const CvMat* rotation_vector, const CvMat* translation_vector, const CvMat* camera_matrix, const CvMat* distortion_coeffs, CvMat* image_points, CvMat* dpdrot, CvMat* dpdt, CvMat* dpdf, CvMat* dpdc, CvMat* dpddist, double aspect_ratio)"><strong>ProjectPoints2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr"><strong>Ptr (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr1D(const CvArr* arr, int idx0, int* type)"><strong>Ptr1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr2D(const CvArr* arr, int idx0, int idx1, int* type)"><strong>Ptr2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtr3D(const CvArr* arr, int idx0, int idx1, int idx2, int* type)"><strong>Ptr3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr<Y> Ptr::constCast() const"><strong>Ptr::constCast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr<Y> Ptr::dynamicCast() const"><strong>Ptr::dynamicCast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#bool Ptr::empty() const"><strong>Ptr::empty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#T* Ptr::get() const"><strong>Ptr::get (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr::operator T* () const"><strong>Ptr::operator T* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#T& Ptr::operator * () const"><strong>Ptr::operator* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#T* Ptr::operator -> () const"><strong>Ptr::operator-&gt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr& Ptr::operator = (const Ptr& o)"><strong>Ptr::operator= (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr& Ptr::operator = (const Ptr<Y>& o)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr::Ptr()"><strong>Ptr::Ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#Ptr::Ptr(const Ptr& o)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Ptr::release()"><strong>Ptr::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y> void Ptr::reset(Y* p)"><strong>Ptr::reset (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename Y, typename D> void Ptr::reset(Y* p, D d)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr<Y> Ptr::staticCast() const"><strong>Ptr::staticCast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void Ptr::swap(Ptr& o)"><strong>Ptr::swap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Ptr::~Ptr()"><strong>Ptr::~Ptr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#uchar* cvPtrND(const CvArr* arr, const int* idx, int* type, int create_node, unsigned* precalc_hashval)"><strong>PtrND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvPutText(CvArr* img, const char* text, CvPoint org, const CvFont* font, CvScalar color)"><strong>PutText (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void putText(InputOutputArray img, const String& text, Point org, int fontFace, double fontScale, Scalar color, int thickness, int lineType, bool bottomLeftOrigin)"><strong>putText (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.putText"><strong>putText() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvPyrDown(const CvArr* src, CvArr* dst, int filter)"><strong>PyrDown (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrDown(InputArray src, OutputArray dst, const Size& dstsize, int borderType)"><strong>pyrDown (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrDown"><strong>pyrDown() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvPyrMeanShiftFiltering(const CvArr* src, CvArr* dst, double sp, double sr, int max_level, CvTermCriteria termcrit)"><strong>PyrMeanShiftFiltering (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrMeanShiftFiltering(InputArray src, OutputArray dst, double sp, double sr, int maxLevel, TermCriteria termcrit)"><strong>pyrMeanShiftFiltering (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrMeanShiftFiltering"><strong>pyrMeanShiftFiltering() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cvPyrUp(const CvArr* src, CvArr* dst, int filter)"><strong>PyrUp (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void pyrUp(InputArray src, OutputArray dst, const Size& dstsize, int borderType)"><strong>pyrUp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.pyrUp"><strong>pyrUp() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="Q">Q</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#IplImage* cvQueryFrame(CvCapture* capture)"><strong>QueryFrame (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="R">R</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvRandArr(CvRNG* rng, CvArr* arr, int dist_type, CvScalar param1, CvScalar param2)"><strong>RandArr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#unsigned cvRandInt(CvRNG* rng)"><strong>RandInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void randn(InputOutputArray dst, InputArray mean, InputArray stddev)"><strong>randn (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randn"><strong>randn() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#double cvRandReal(CvRNG* rng)"><strong>RandReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void randShuffle(InputOutputArray dst, double iterFactor, RNG* rng)"><strong>randShuffle (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randShuffle"><strong>randShuffle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#template<typename _Tp> _Tp randu()"><strong>randu (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void randu(InputOutputArray dst, InputArray low, InputArray high)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.randu"><strong>randu() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Range"><strong>Range (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvRead(CvFileStorage* fs, CvFileNode* node, CvAttrList* attributes)"><strong>Read (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void* cvReadByName(CvFileStorage* fs, const CvFileNode* map, const char* name, CvAttrList* attributes)"><strong>ReadByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int cvReadInt(const CvFileNode* node, int default_value)"><strong>ReadInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#int cvReadIntByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, int default_value)"><strong>ReadIntByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/optflow_io.html#Mat readOpticalFlow(const String& path)"><strong>readOpticalFlow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReadRawData(const CvFileStorage* fs, const CvFileNode* src, void* dst, const char* dt)"><strong>ReadRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReadRawDataSlice(const CvFileStorage* fs, CvSeqReader* reader, int count, void* dst, const char* dt)"><strong>ReadRawDataSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#double cvReadReal(const CvFileNode* node, double default_value)"><strong>ReadReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#double cvReadRealByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, double default_value)"><strong>ReadRealByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvReadString(const CvFileNode* node, const char* default_value)"><strong>ReadString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#const char* cvReadStringByName(const CvFileStorage* fs, const CvFileNode* map, const char* name, const char* default_value)"><strong>ReadStringByName (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int recoverPose(InputArray E, InputArray points1, InputArray points2, OutputArray R, OutputArray t, double focal , Point2d pp , InputOutputArray mask)"><strong>recoverPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRect cvRect(int x, int y, int width, int height)"><strong>Rect (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Rect_"><strong>Rect_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void cvRectangle(CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness, int line_type, int shift)"><strong>Rectangle (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#void rectangle(InputOutputArray img, Point pt1, Point pt2, const Scalar& color, int thickness, int lineType, int shift)"><strong>rectangle (C++ function)</strong></a>, <a href="modules/imgproc/doc/drawing_functions.html#void rectangle(Mat& img, Rect rec, const Scalar& color, int thickness, int lineType, int shift)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/drawing_functions.html#cv2.rectangle"><strong>rectangle() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvReduce(const CvArr* src, CvArr* dst, int dim, int op)"><strong>Reduce (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void reduce(InputArray src, OutputArray dst, int dim, int rtype, int dtype)"><strong>reduce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.reduce"><strong>reduce() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/reg/doc/registration.html#reg::Map"><strong>reg::Map (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/reg/doc/registration.html#reg::Mapper"><strong>reg::Mapper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void registerKeyboardCallback(KeyboardCallback callback, void* cookie)"><strong>registerKeyboardCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void registerMouseCallback(MouseCallback callback, void* cookie)"><strong>registerMouseCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvRegisterType(const CvTypeInfo* info)"><strong>RegisterType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvRelease(void** struct_ptr)"><strong>Release (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#void cvReleaseCapture(CvCapture** capture)"><strong>ReleaseCapture (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseData(CvArr* arr)"><strong>ReleaseData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvReleaseFileStorage(CvFileStorage** fs)"><strong>ReleaseFileStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvReleaseGraphScanner(CvGraphScanner** scanner)"><strong>ReleaseGraphScanner (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvReleaseHist(CvHistogram** hist)"><strong>ReleaseHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseImage(IplImage** image)"><strong>ReleaseImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseImageHeader(IplImage** image)"><strong>ReleaseImageHeader (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseMat(CvMat** mat)"><strong>ReleaseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseMatND(CvMatND** mat)"><strong>ReleaseMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvReleaseMemStorage(CvMemStorage** storage)"><strong>ReleaseMemStorage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvReleaseSparseMat(CvSparseMat** mat)"><strong>ReleaseSparseMat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#void cvReleaseVideoWriter(CvVideoWriter** writer)"><strong>ReleaseVideoWriter (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvRemap(const CvArr* src, CvArr* dst, const CvArr* mapx, const CvArr* mapy, int flags, CvScalar fillval)"><strong>Remap (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void remap(InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode, const Scalar& borderValue)"><strong>remap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.remap"><strong>remap() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void removeAllWidgets()"><strong>removeAllWidgets (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void removeWidget(const String &id)"><strong>removeWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvRepeat(const CvArr* src, CvArr* dst)"><strong>Repeat (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void repeat(InputArray src, int ny, int nx, OutputArray dst)"><strong>repeat (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#Mat repeat(const Mat& src, int ny, int nx)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.repeat"><strong>repeat() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvReprojectImageTo3D(const CvArr* disparityImage, CvArr* _3dImage, const CvMat* Q, int handleMissingValues)"><strong>ReprojectImageTo3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void reprojectImageTo3D(InputArray disparity, OutputArray _3dImage, InputArray Q, bool handleMissingValues, int ddepth)"><strong>reprojectImageTo3D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.reprojectImageTo3D"><strong>reprojectImageTo3D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void resetCamera()"><strong>resetCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void resetCameraViewpoint (const String &id)"><strong>resetCameraViewpoint (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvResetImageROI(IplImage* image)"><strong>ResetImageROI (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvMat* cvReshape(const CvArr* arr, CvMat* header, int new_cn, int new_rows)"><strong>Reshape (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvArr* cvReshapeMatND(const CvArr* arr, int sizeof_header, CvArr* header, int new_cn, int new_dims, int* new_sizes)"><strong>ReshapeMatND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvResize(const CvArr* src, CvArr* dst, int interpolation)"><strong>Resize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void resize(InputArray src, OutputArray dst, Size dsize, double fx, double fy, int interpolation)"><strong>resize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.resize"><strong>resize() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvResizeWindow(const char* name, int width, int height)"><strong>ResizeWindow (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void resizeWindow(const String& winname, int width, int height)"><strong>resizeWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.resizeWindow"><strong>resizeWindow() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvRestoreMemStoragePos(CvMemStorage* storage, CvMemStoragePos* pos)"><strong>RestoreMemStoragePos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#Retina : public Algorithm"><strong>Retina (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::activateContoursProcessing(const bool activate)"><strong>Retina::activateContoursProcessing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::activateMovingContoursProcessing(const bool activate)"><strong>Retina::activateMovingContoursProcessing (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::applyFastToneMapping(InputArray inputImage, OutputArray outputToneMappedImage)"><strong>Retina::applyFastToneMapping (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::clearBuffers()"><strong>Retina::clearBuffers (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#Size Retina::getInputSize()"><strong>Retina::getInputSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::getMagno(OutputArray retinaOutput_magno)"><strong>Retina::getMagno (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::getMagnoRAW(OutputArray retinaOutput_magno)"><strong>Retina::getMagnoRAW (C++ function)</strong></a>, <a href="modules/bioinspired/doc/retina.html#const Mat Retina::getMagnoRAW() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#Size Retina::getOutputSize()"><strong>Retina::getOutputSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::getParvo(OutputArray retinaOutput_parvo)"><strong>Retina::getParvo (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::getParvoRAW(OutputArray retinaOutput_parvo)"><strong>Retina::getParvoRAW (C++ function)</strong></a>, <a href="modules/bioinspired/doc/retina.html#const Mat Retina::getParvoRAW() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#const String Retina::printSetup()"><strong>Retina::printSetup (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#Retina::RetinaParameters"><strong>Retina::RetinaParameters (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::run(InputArray inputImage)"><strong>Retina::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::setColorSaturation(const bool saturateColors , const float colorSaturationValue)"><strong>Retina::setColorSaturation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::setup(String retinaParameterFile , const bool applyDefaultSetupOnFailure)"><strong>Retina::setup (C++ function)</strong></a>, <a href="modules/bioinspired/doc/retina.html#void Retina::setup(FileStorage & fs, const bool applyDefaultSetupOnFailure)"><strong>[1]</strong></a>, <a href="modules/bioinspired/doc/retina.html#void Retina::setup(RetinaParameters newParameters)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::setupIPLMagnoChannel(const bool normaliseOutput , const float parasolCells_beta , const float parasolCells_tau , const float parasolCells_k , const float amacrinCellsTemporalCutFrequency , const float V0CompressionParameter , const float localAdaptintegration_tau , const float localAdaptintegration_k)"><strong>Retina::setupIPLMagnoChannel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::setupOPLandIPLParvoChannel(const bool colorMode , const bool normaliseOutput , const float photoreceptorsLocalAdaptationSensitivity , const float photoreceptorsTemporalConstant , const float photoreceptorsSpatialConstant , const float horizontalCellsGain , const float HcellsTemporalConstant , const float HcellsSpatialConstant , const float ganglionCellsSensitivity)"><strong>Retina::setupOPLandIPLParvoChannel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/bioinspired/doc/retina.html#void Retina::write(String fs) const"><strong>Retina::write (C++ function)</strong></a>, <a href="modules/bioinspired/doc/retina.html#void Retina::write(FileStorage& fs) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#IplImage* cvRetrieveFrame(CvCapture* capture, int streamIdx)"><strong>RetrieveFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvRNG cvRNG(int64 seed)"><strong>RNG (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void RNG::fill(InputOutputArray mat, int distType, InputArray a, InputArray b, bool saturateRange)"><strong>RNG::fill (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double RNG::gaussian(double sigma)"><strong>RNG::gaussian (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::next()"><strong>RNG::next (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator double()"><strong>RNG::operator double (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator float()"><strong>RNG::operator float (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator int()"><strong>RNG::operator int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator schar()"><strong>RNG::operator schar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator short()"><strong>RNG::operator short int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator uchar()"><strong>RNG::operator uchar (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator unsigned()"><strong>RNG::operator unsigned int (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::operator ushort()"><strong>RNG::operator ushort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::operator ()()"><strong>RNG::operator() (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#unsigned RNG::operator ()(unsigned N)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG::RNG()"><strong>RNG::RNG (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#RNG::RNG(uint64 state)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int RNG::uniform(int a, int b)"><strong>RNG::uniform (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#float RNG::uniform(float a, float b)"><strong>[1]</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#double RNG::uniform(double a, double b)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void Rodrigues(InputArray src, OutputArray dst, OutputArray jacobian)"><strong>Rodrigues (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.Rodrigues"><strong>Rodrigues() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvRodrigues2(const CvMat* src, CvMat* dst, CvMat* jacobian)"><strong>Rodrigues2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#RotatedRect"><strong>RotatedRect (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Rect RotatedRect::boundingRect() const"><strong>RotatedRect::boundingRect (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void RotatedRect::points(Point2f pts[]) const"><strong>RotatedRect::points (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect()"><strong>RotatedRect::RotatedRect (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect(const Point2f& center, const Size2f& size, float angle)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#RotatedRect::RotatedRect(const Point2f& point1, const Point2f& point2, const Point2f& point3)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#int rotatedRectangleIntersection(const RotatedRect& rect1, const RotatedRect& rect2, OutputArray intersectingRegion)"><strong>rotatedRectangleIntersection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/structural_analysis_and_shape_descriptors.html#cv2.rotatedRectangleIntersection"><strong>rotatedRectangleIntersection() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvRound(double value)"><strong>Round (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvRQDecomp3x3(const CvMat * matrixM, CvMat * matrixR, CvMat * matrixQ, CvMat * matrixQx, CvMat * matrixQy, CvMat * matrixQz, CvPoint3D64f * eulerAngles)"><strong>RQDecomp3x3 (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#Vec3d RQDecomp3x3(InputArray src, OutputArray mtxR, OutputArray mtxQ, OutputArray Qx, OutputArray Qy, OutputArray Qz)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.RQDecomp3x3"><strong>RQDecomp3x3() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#RTrees : public DTrees"><strong>RTrees (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#bool RTrees::create(const RTrees::Params& params)"><strong>RTrees::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#Mat RTrees::getVarImportance() const"><strong>RTrees::getVarImportance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#RTrees::Params : public DTrees::Params"><strong>RTrees::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/random_trees.html#RTrees::Params::Params()"><strong>RTrees::Params::Params (C++ function)</strong></a>, <a href="modules/ml/doc/random_trees.html#RTrees::Params::Params(int maxDepth, int minSampleCount, double regressionAccuracy, bool useSurrogates, int maxCategories, const Mat& priors, bool calcVarImportance, int nactiveVars, TermCriteria termCrit)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvRunningAvg(const CvArr* image, CvArr* acc, double alpha, const CvArr* mask)"><strong>RunningAvg (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="S">S</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/saliency/doc/common_interfaces_saliency.html#Saliency"><strong>Saliency (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/common_interfaces_saliency.html#bool Saliency::computeSaliency(const InputArray image, OutputArray saliencyMap)"><strong>Saliency::computeSaliency (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/common_interfaces_saliency.html#static Ptr<Saliency> Saliency::create(const String& saliencyType)"><strong>Saliency::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/common_interfaces_saliency.html#String Saliency::getClassName() const"><strong>Saliency::getClassName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#template<...> _Tp saturate_cast(_Tp2 v)"><strong>saturate_cast (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvSave(const char* filename, const void* struct_ptr, const char* name, const char* comment, CvAttrList attributes)"><strong>Save (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgcodecs/doc/reading_and_writing_images.html#int cvSaveImage(const char* filename, const CvArr* image, const int* params)"><strong>SaveImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSaveMemStoragePos(const CvMemStorage* storage, CvMemStoragePos* pos)"><strong>SaveMemStoragePos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void saveScreenshot(const String &file)"><strong>saveScreenshot (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSaveWindowParameters(const char* name)"><strong>SaveWindowParameters (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void saveWindowParameters(const String& windowName)"><strong>saveWindowParameters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Scalar_"><strong>Scalar_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvScaleAdd(const CvArr* src1, CvScalar scale, const CvArr* src2, CvArr* dst)"><strong>ScaleAdd (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void scaleAdd(InputArray src1, double alpha, InputArray src2, OutputArray dst)"><strong>scaleAdd (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.scaleAdd"><strong>scaleAdd() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void Scharr(InputArray src, OutputArray dst, int ddepth, int dx, int dy, double scale, double delta, int borderType)"><strong>Scharr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Scharr"><strong>Scharr() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/cloning.html#void seamlessClone(InputArray src, InputArray dst, InputArray mask, Point p, OutputArray blend, int flags)"><strong>seamlessClone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#void segmentMotion(InputArray mhi, OutputArray segmask, vector<Rect>& boundingRects, double timestamp, double segThresh)"><strong>segmentMotion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#cv2.segmentMotion"><strong>segmentMotion() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void sepFilter2D(InputArray src, OutputArray dst, int ddepth, InputArray kernelX, InputArray kernelY, Point anchor, double delta, int borderType)"><strong>sepFilter2D (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.sepFilter2D"><strong>sepFilter2D() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSeqElemIdx(const CvSeq* seq, const void* element, CvSeqBlock** block)"><strong>SeqElemIdx (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqInsert(CvSeq* seq, int before_index, const void* element)"><strong>SeqInsert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqInsertSlice(CvSeq* seq, int before_index, const CvArr* from_arr)"><strong>SeqInsertSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqInvert(CvSeq* seq)"><strong>SeqInvert (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPop(CvSeq* seq, void* element)"><strong>SeqPop (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPopFront(CvSeq* seq, void* element)"><strong>SeqPopFront (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPopMulti(CvSeq* seq, void* elements, int count, int in_front)"><strong>SeqPopMulti (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqPush(CvSeq* seq, const void* element)"><strong>SeqPush (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqPushFront(CvSeq* seq, const void* element)"><strong>SeqPushFront (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqPushMulti(CvSeq* seq, const void* elements, int count, int in_front)"><strong>SeqPushMulti (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqRemove(CvSeq* seq, int index)"><strong>SeqRemove (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqRemoveSlice(CvSeq* seq, CvSlice slice)"><strong>SeqRemoveSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#schar* cvSeqSearch(CvSeq* seq, const void* elem, CvCmpFunc func, int is_sorted, int* elem_idx, void* userdata)"><strong>SeqSearch (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvSeqSlice(const CvSeq* seq, CvSlice slice, CvMemStorage* storage, int copy_data)"><strong>SeqSlice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSeqSort(CvSeq* seq, CvCmpFunc func, void* userdata)"><strong>SeqSort (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet(CvArr* arr, CvScalar value, const CvArr* mask)"><strong>Set (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet1D(CvArr* arr, int idx0, CvScalar value)"><strong>Set1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet2D(CvArr* arr, int idx0, int idx1, CvScalar value)"><strong>Set2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSet3D(CvArr* arr, int idx0, int idx1, int idx2, CvScalar value)"><strong>Set3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSetAdd(CvSet* set_header, CvSetElem* elem, CvSetElem** inserted_elem)"><strong>SetAdd (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setAngularBins(int nAngularBins)"><strong>setAngularBins (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setBackgroundColor(const Color& color)"><strong>setBackgroundColor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setBendingEnergyWeight(float bendingEnergyWeight)"><strong>setBendingEnergyWeight (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setCamera(const Camera &camera)"><strong>setCamera (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#int cvSetCaptureProperty(CvCapture* capture, int property_id, double value)"><strong>SetCaptureProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setColor(const Color &color)"><strong>setColor (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setColor(const Color &color)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setCostExtractor(Ptr<HistogramCostExtractor> comparer)"><strong>setCostExtractor (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetData(CvArr* arr, void* data, int step)"><strong>SetData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/cvv/doc/cvv_api.html#void setDebugFlag(bool active)"><strong>setDebugFlag (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setDistanceFlag(int distanceFlag)"><strong>setDistanceFlag (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setFullScreen(bool mode)"><strong>setFullScreen (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvSetHistBinRanges(CvHistogram* hist, float** ranges, int uniform)"><strong>SetHistBinRanges (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSetIdentity(CvArr* mat, CvScalar value)"><strong>SetIdentity (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void setIdentity(InputOutputArray mtx, const Scalar& s)"><strong>setIdentity (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.setIdentity"><strong>setIdentity() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setImage(InputArray image)"><strong>setImage (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setImage(InputArray image)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setImageAppearanceWeight(float imageAppearanceWeight)"><strong>setImageAppearanceWeight (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetImageCOI(IplImage* image, int coi)"><strong>SetImageCOI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetImageROI(IplImage* image, CvRect rect)"><strong>SetImageROI (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setImages(InputArray image1, InputArray image2)"><strong>setImages (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#void setInitStep(InputArray step)"><strong>setInitStep (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setInnerRadius(float innerRadius)"><strong>setInnerRadius (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetIPLAllocators(Cv_iplCreateImageHeader create_header, Cv_iplAllocateImageData allocate_data, Cv_iplDeallocate deallocate, Cv_iplCreateROI create_roi, Cv_iplCloneImage clone_image)"><strong>SetIPLAllocators (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvSetMouseCallback(const char* window_name, CvMouseCallback on_mouse, void* param)"><strong>SetMouseCallback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setMouseCallback(const String& winname, MouseCallback onMouse, void* userdata)"><strong>setMouseCallback (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.setMouseCallback"><strong>setMouseCallback() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetND(CvArr* arr, const int* idx, CvScalar value)"><strong>SetND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSetElem* cvSetNew(CvSet* set_header)"><strong>SetNew (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#void setNumThreads(int nthreads)"><strong>setNumThreads (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setOpenGlContext(const String& winname)"><strong>setOpenGlContext (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSetOpenGlDrawCallback(const char* window_name, CvOpenGlDrawCallback callback, void* userdata)"><strong>SetOpenGlDrawCallback (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void setOpenGlDrawCallback(const String& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata)"><strong>setOpenGlDrawCallback (C++ function)</strong></a>, <a href="modules/highgui/doc/user_interface.html#void setOpenGlDrawCallback(const string& winname, OpenGlDrawCallback onOpenGlDraw, void* userdata)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setOuterRadius(float outerRadius)"><strong>setOuterRadius (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setPose(const Affine3d &pose)"><strong>setPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#static void setProp(Widget &widget, vtkSmartPointer<vtkProp> prop)"><strong>setProp (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setRadialBins(int nRadialBins)"><strong>setRadialBins (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setRankProportion(float rankProportion)"><strong>setRankProportion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal1D(CvArr* arr, int idx0, double value)"><strong>SetReal1D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal2D(CvArr* arr, int idx0, int idx1, double value)"><strong>SetReal2D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetReal3D(CvArr* arr, int idx0, int idx1, int idx2, double value)"><strong>SetReal3D (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetRealND(CvArr* arr, const int* idx, double value)"><strong>SetRealND (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#void setRegularizationParameter(double beta)"><strong>setRegularizationParameter (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetRemove(CvSet* set_header, int index)"><strong>SetRemove (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetRemoveByPtr(CvSet* set_header, void* elem)"><strong>SetRemoveByPtr (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setRenderingProperty(int property, double value)"><strong>setRenderingProperty (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#void setRenderingProperty(const String &id, int property, double value)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setRepresentation(int representation)"><strong>setRepresentation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetSeqBlockSize(CvSeq* seq, int delta_elems)"><strong>SetSeqBlockSize (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvSetSeqReaderPos(CvSeqReader* reader, int index, int is_relative)"><strong>SetSeqReaderPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setShapeContextWeight(float shapeContextWeight)"><strong>setShapeContextWeight (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setStdDev(float sigma)"><strong>setStdDev (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void setText(const String &text)"><strong>setText (C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#void setText(const String &text)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvSetTrackbarPos(const char* trackbar_name, const char* window_name, int pos)"><strong>SetTrackbarPos (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void setTrackbarPos(const String& trackbarname, const String& winname, int pos)"><strong>setTrackbarPos (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.setTrackbarPos"><strong>setTrackbarPos() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#void setTransformAlgorithm(Ptr<ShapeTransformer> transformer)"><strong>setTransformAlgorithm (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.setUseOptimized"><strong>setUseOptimized() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setViewerPose(const Affine3d &pose)"><strong>setViewerPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWidgetPose(const String &id, const Affine3d &pose)"><strong>setWidgetPose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWindowPosition(int x, int y)"><strong>setWindowPosition (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void cvSetWindowProperty(const char* name, int prop_id, double prop_value)"><strong>SetWindowProperty (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#void setWindowProperty(const String& winname, int prop_id, double prop_value)"><strong>setWindowProperty (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/qt_new_functions.html#cv2.setWindowProperty"><strong>setWindowProperty() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void setWindowSize(const Size &window_size)"><strong>setWindowSize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/static_saliency_algorithms.html#StaticSaliencySpectralResidual::void setWsize(const Ptr<Size> &newSize)"><strong>setWsize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#void cvSetZero(CvArr* arr)"><strong>SetZero (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#ShapeContextDistanceExtractor : public ShapeDistanceExtractor"><strong>ShapeContextDistanceExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#ShapeDistanceExtractor : public Algorithm"><strong>ShapeDistanceExtractor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_distances.html#float ShapeDistanceExtractor::computeDistance(InputArray contour1, InputArray contour2)"><strong>ShapeDistanceExtractor::computeDistance (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#ShapeTransformer : public Algorithm"><strong>ShapeTransformer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void cvShowImage(const char* name, const CvArr* image)"><strong>ShowImage (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/cvv/doc/cvv_api.html#void showImage(InputArray img, const CallMetaData& metaData, const string& description, const string& view)"><strong>showImage (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#void showImage(InputArray image, const Size& window_size)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/feature_detection_and_description.html#SIFT : public Feature2D"><strong>SIFT (C++ class)</strong></a>, <a href="modules/xfeatures2d/doc/nonfree_features.html#SIFT : public Feature2D"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SIFT"><strong>SIFT() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SIFT.compute"><strong>SIFT.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SIFT.detect"><strong>SIFT.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SIFT.detectAndCompute"><strong>SIFT.detectAndCompute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#void SIFT::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints)"><strong>SIFT::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#SIFT::SIFT(int nfeatures, int nOctaveLayers, double contrastThreshold, double edgeThreshold, double sigma)"><strong>SIFT::SIFT (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/features2d/doc/common_interfaces_of_feature_detectors.html#SimpleBlobDetector : public FeatureDetector"><strong>SimpleBlobDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize cvSize(int width, int height)"><strong>Size (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_basic_structures.html#CvSize2D32f cvSize2D32f(double width, double height)"><strong>Size2D32f (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#Size_"><strong>Size_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/slam_kitti.html#SLAM_kitti"><strong>SLAM_kitti (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/slam_tumindoor.html#SLAM_tumindoor"><strong>SLAM_tumindoor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSlice cvSlice(int start, int end)"><strong>Slice (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#int cvSliceLength(CvSlice slice, const CvSeq* seq)"><strong>SliceLength (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvSmooth(const CvArr* src, CvArr* dst, int smoothtype, int size1, int size2, double sigma1, double sigma2)"><strong>Smooth (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/filtering.html#void cvSobel(const CvArr* src, CvArr* dst, int xorder, int yorder, int aperture_size)"><strong>Sobel (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/imgproc/doc/filtering.html#void Sobel(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int borderType)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/imgproc/doc/filtering.html#cv2.Sobel"><strong>Sobel() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvSolve(const CvArr* src1, const CvArr* src2, CvArr* dst, int method)"><strong>Solve (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#bool solve(InputArray src1, InputArray src2, OutputArray dst, int flags)"><strong>solve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solve"><strong>solve() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int cvSolveCubic(const CvMat* coeffs, CvMat* roots)"><strong>SolveCubic (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#int solveCubic(InputArray coeffs, OutputArray roots)"><strong>solveCubic (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solveCubic"><strong>solveCubic() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/optim.html#int solveLP(const Mat& Func, const Mat& Constr, Mat& z)"><strong>solveLP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int flags)"><strong>solvePnP (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.solvePnP"><strong>solvePnP() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool solvePnPRansac(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess, int iterationsCount , float reprojectionError , double confidence , OutputArray inliers , int flags)"><strong>solvePnPRansac (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.solvePnPRansac"><strong>solvePnPRansac() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#double solvePoly(InputArray coeffs, OutputArray roots, int maxIters)"><strong>solvePoly (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.solvePoly"><strong>solvePoly() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sort(InputArray src, OutputArray dst, int flags)"><strong>sort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sort"><strong>sort() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sortIdx(InputArray src, OutputArray dst, int flags)"><strong>sortIdx (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sortIdx"><strong>sortIdx() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat"><strong>SparseMat (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::addref()"><strong>SparseMat::addref (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::channels() const"><strong>SparseMat::channels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::clear()"><strong>SparseMat::clear (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat SparseMat::clone() const"><strong>SparseMat::clone (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::convertTo(SparseMat& m, int rtype, double alpha) const"><strong>SparseMat::convertTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::convertTo(Mat& m, int rtype, double alpha, double beta) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::copyTo(SparseMat& m) const"><strong>SparseMat::copyTo (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::copyTo(Mat& m) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::create(int dims, const int* _sizes, int _type)"><strong>SparseMat::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::depth() const"><strong>SparseMat::depth (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::dims() const"><strong>SparseMat::dims (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::elemSize() const"><strong>SparseMat::elemSize (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::elemSize() const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::erase(int i0, int i1, size_t* hashval)"><strong>SparseMat::erase (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::erase(int i0, int i1, int i2, size_t* hashval)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#void SparseMat::erase(const int* idx, size_t* hashval)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0) const"><strong>SparseMat::hash (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0, int i1) const"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(int i0, int i1, int i2) const"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#size_t SparseMat::hash(const int* idx) const"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#size_t SparseMat::nzcount() const"><strong>SparseMat::nzcount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::operator CvSparseMat*() const"><strong>SparseMat::operator CvSparseMat* (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat& SparseMat::operator = (const SparseMat& m)"><strong>SparseMat::operator= (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat& SparseMat::operator = (const Mat& m)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, bool createMissing, size_t* hashval)"><strong>SparseMat::ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, int i1, bool createMissing, size_t* hashval)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#uchar* SparseMat::ptr(const int* idx, bool createMissing, size_t* hashval)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#void SparseMat::release()"><strong>SparseMat::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#const int* SparseMat::size() const"><strong>SparseMat::size (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#int SparseMat::size(int i) const"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat()"><strong>SparseMat::SparseMat (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(int dims, const int* _sizes, int _type)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(const SparseMat& m)"><strong>[2]</strong></a>, <a href="modules/core/doc/basic_structures.html#SparseMat::SparseMat(const Mat& m)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#int SparseMat::type() const"><strong>SparseMat::type (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat::~SparseMat()"><strong>SparseMat::~SparseMat (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#SparseMat_"><strong>SparseMat_ (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#SphericalWarper : public WarperCreator"><strong>SphericalWarper (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void spin()"><strong>spin (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void spinOnce(int time , bool force_redraw)"><strong>spinOnce (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSplit(const CvArr* src, CvArr* dst0, CvArr* dst1, CvArr* dst2, CvArr* dst3)"><strong>Split (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void split(const Mat& src, Mat* mvbegin)"><strong>split (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#void split(InputArray m, OutputArrayOfArrays mv)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.split"><strong>split() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#float cvSqrt(float value)"><strong>Sqrt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void sqrt(InputArray src, OutputArray dst)"><strong>sqrt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sqrt"><strong>sqrt() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/motion_analysis_and_object_tracking.html#void cvSquareAcc(const CvArr* image, CvArr* sqsum, const CvArr* mask)"><strong>SquareAcc (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/extra_features.html#StarFeatureDetector : public FeatureDetector"><strong>StarFeatureDetector (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartAppendToSeq(CvSeq* seq, CvSeqWriter* writer)"><strong>StartAppendToSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartNextStream(CvFileStorage* fs)"><strong>StartNextStream (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartReadRawData(const CvFileStorage* fs, const CvFileNode* src, CvSeqReader* reader)"><strong>StartReadRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartReadSeq(const CvSeq* seq, CvSeqReader* reader, int reverse)"><strong>StartReadSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#void cvStartWriteSeq(int seq_flags, int header_size, int elem_size, CvMemStorage* storage, CvSeqWriter* writer)"><strong>StartWriteSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvStartWriteStruct(CvFileStorage* fs, const char* name, int struct_flags, const char* type_name, CvAttrList attributes)"><strong>StartWriteStruct (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/saliency_categories.html#StaticSaliency"><strong>StaticSaliency (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/static_saliency_algorithms.html#StaticSaliencySpectralResidual"><strong>StaticSaliencySpectralResidual (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/static_saliency_algorithms.html#bool StaticSaliencySpectralResidual::computeSaliency(const InputArray image, OutputArray saliencyMap)"><strong>StaticSaliencySpectralResidual::computeSaliency (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/static_saliency_algorithms.html#Ptr<Size> StaticSaliencySpectralResidual::getWsize()"><strong>StaticSaliencySpectralResidual::getWsize (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/saliency/doc/static_saliency_algorithms.html#StaticSaliencySpectralResidual::StaticSaliencySpectralResidual()"><strong>StaticSaliencySpectralResidual::StaticSaliencySpectralResidual (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#index-0">StatModel</a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/ml/doc/statistical_models.html#StatModel"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/ml/doc/statistical_models.html#float StatModel::calcError(const Ptr<TrainData>& data, bool test, OutputArray resp) const"><strong>StatModel::calcError (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#int StatModel::getVarCount()"><strong>StatModel::getVarCount (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#bool StatModel::isClassifier()"><strong>StatModel::isClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#bool StatModel::isTrained()"><strong>StatModel::isTrained (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#Ptr<_Tp> StatModel::load(const String& filename)"><strong>StatModel::load (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#float StatModel::predict(InputArray samples, OutputArray results, int flags) const"><strong>StatModel::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#void StatModel::save(const String& filename)"><strong>StatModel::save (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/statistical_models.html#bool StatModel::train(const Ptr<TrainData>& trainData, int flags)"><strong>StatModel::train (C++ function)</strong></a>, <a href="modules/ml/doc/statistical_models.html#bool StatModel::train(InputArray samples, int layout, InputArray responses)"><strong>[1]</strong></a>, <a href="modules/ml/doc/statistical_models.html#Ptr<_Tp> StatModel::train(const Ptr<TrainData>& data, const _Tp::Params& p, int flags)"><strong>[2]</strong></a>, <a href="modules/ml/doc/statistical_models.html#Ptr<_Tp> StatModel::train(InputArray samples, int layout, InputArray responses, const _Tp::Params& p, int flags)"><strong>[3]</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoBM : public StereoMatcher"><strong>StereoBM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.StereoBM.compute"><strong>StereoBM.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double cvStereoCalibrate(const CvMat* object_points, const CvMat* image_points1, const CvMat* image_points2, const CvMat* npoints, CvMat* camera_matrix1, CvMat* dist_coeffs1, CvMat* camera_matrix2, CvMat* dist_coeffs2, CvSize image_size, CvMat* R, CvMat* T, CvMat* E, CvMat* F, int flags, CvTermCriteria term_crit)"><strong>StereoCalibrate (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1, InputArrayOfArrays imagePoints2, InputOutputArray cameraMatrix1, InputOutputArray distCoeffs1, InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, Size imageSize, OutputArray R, OutputArray T, OutputArray E, OutputArray F, int flags,TermCriteria criteria)"><strong>stereoCalibrate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.stereoCalibrate"><strong>stereoCalibrate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoMatcher : public Algorithm"><strong>StereoMatcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void StereoMatcher::compute(InputArray left, InputArray right, OutputArray disparity)"><strong>StereoMatcher::compute (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvStereoRectify(const CvMat* camera_matrix1, const CvMat* camera_matrix2, const CvMat* dist_coeffs1, const CvMat* dist_coeffs2, CvSize image_size, const CvMat* R, const CvMat* T, CvMat* R1, CvMat* R2, CvMat* P1, CvMat* P2, CvMat* Q, int flags, double alpha, CvSize new_image_size, CvRect* valid_pix_ROI1, CvRect* valid_pix_ROI2)"><strong>StereoRectify (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T, OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2, OutputArray Q, int flags, double alpha, Size newImageSize, Rect* validPixROI1, Rect* validPixROI2)"><strong>stereoRectify (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#int cvStereoRectifyUncalibrated(const CvMat* points1, const CvMat* points2, const CvMat* F, CvSize img_size, CvMat* H1, CvMat* H2, double threshold)"><strong>StereoRectifyUncalibrated (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#bool stereoRectifyUncalibrated(InputArray points1, InputArray points2, InputArray F, Size imgSize, OutputArray H1, OutputArray H2, double threshold)"><strong>stereoRectifyUncalibrated (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.stereoRectifyUncalibrated"><strong>stereoRectifyUncalibrated() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#StereoSGBM : public StereoMatcher"><strong>StereoSGBM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Stitcher"><strong>Stitcher (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::composePanorama(OutputArray pano)"><strong>Stitcher::composePanorama (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::composePanorama(InputArrayOfArrays images, OutputArray pano)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Stitcher Stitcher::createDefault(bool try_use_gpu)"><strong>Stitcher::createDefault (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::estimateTransform(InputArrayOfArrays images)"><strong>Stitcher::estimateTransform (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::estimateTransform(InputArrayOfArrays images, const std::vector<std::vector<Rect> > &rois)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#Status Stitcher::stitch(InputArrayOfArrays images, OutputArray pano)"><strong>Stitcher::stitch (C++ function)</strong></a>, <a href="modules/stitching/doc/high_level.html#Status Stitcher::stitch(InputArrayOfArrays images, const std::vector<std::vector<Rect> > &rois, OutputArray pano)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/structured_edge_detection.html#StructuredEdgeDetection : public Algorithm"><strong>StructuredEdgeDetection (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/npr.html#void stylization(InputArray src, OutputArray dst, float sigma_s , float sigma_r)"><strong>stylization (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSub(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Sub (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSubRS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>SubRS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSubS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>SubS (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void subtract(InputArray src1, InputArray src2, OutputArray dst, InputArray mask, int dtype)"><strong>subtract (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.subtract"><strong>subtract() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="platforms/android/service/doc/LoaderCallbackInterface.html#SUCCESS">SUCCESS (built-in variable)</a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvSum(const CvArr* arr)"><strong>Sum (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar sum(InputArray src)"><strong>sum (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.sumElems"><strong>sumElems() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#SuperpixelSEEDS : public Algorithm"><strong>SuperpixelSEEDS (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#cv2.SuperpixelSEEDS.createSuperpixelSEEDS"><strong>SuperpixelSEEDS.createSuperpixelSEEDS() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#cv2.SuperpixelSEEDS.getLabelContourMask"><strong>SuperpixelSEEDS.getLabelContourMask() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#cv2.SuperpixelSEEDS.getLabels"><strong>SuperpixelSEEDS.getLabels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#cv2.SuperpixelSEEDS.getNumberOfSuperpixels"><strong>SuperpixelSEEDS.getNumberOfSuperpixels() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#cv2.SuperpixelSEEDS.iterate"><strong>SuperpixelSEEDS.iterate() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#SuperpixelSEEDS::createSuperpixelSEEDS(int image_width, int image_height, int image_channels, int num_superpixels, int num_levels, int use_prior , int histogram_bins, bool double_step)"><strong>SuperpixelSEEDS::createSuperpixelSEEDS (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#void SuperpixelSEEDS::getLabelContourMask(OutputArray image, bool thick_line)"><strong>SuperpixelSEEDS::getLabelContourMask (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#void SuperpixelSEEDS::getLabels(OutputArray labels_out)"><strong>SuperpixelSEEDS::getLabels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#void SuperpixelSEEDS::getNumberOfSuperpixels(InputArray img, int num_iterations)"><strong>SuperpixelSEEDS::getNumberOfSuperpixels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ximgproc/doc/superpixels.html#void SuperpixelSEEDS::iterate(InputArray img, int num_iterations)"><strong>SuperpixelSEEDS::iterate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#Ptr<SuperResolution> superres::createSuperResolution_BTVL1()"><strong>superres::createSuperResolution_BTVL1 (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#Ptr<SuperResolution> superres::createSuperResolution_BTVL1_CUDA()"><strong>superres::createSuperResolution_BTVL1_CUDA (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#superres::SuperResolution : public Algorithm, public superres::FrameSource"><strong>superres::SuperResolution (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::collectGarbage()"><strong>superres::SuperResolution::collectGarbage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::nextFrame(OutputArray frame)"><strong>superres::SuperResolution::nextFrame (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/superres/doc/super_resolution.html#void superres::SuperResolution::setInput(const Ptr<FrameSource>& frameSource)"><strong>superres::SuperResolution::setInput (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#SURF : public Feature2D"><strong>SURF (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SURF"><strong>SURF() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SURF.compute"><strong>SURF.compute() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SURF.detect"><strong>SURF.detect() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SURF.detectAndCompute"><strong>SURF.detectAndCompute() (Python function in cv2)</strong></a>, <a href="modules/xfeatures2d/doc/nonfree_features.html#cv2.SURF.detectAndCompute"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#int extended"><strong>SURF::extended (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#double hessianThreshold"><strong>SURF::hessianThreshold (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#int nOctaveLayers"><strong>SURF::nOctaveLayers (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#int nOctaves"><strong>SURF::nOctaves (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#void SURF::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints) const"><strong>SURF::operator() (C++ function)</strong></a>, <a href="modules/xfeatures2d/doc/nonfree_features.html#void SURF::operator()(InputArray img, InputArray mask, vector<KeyPoint>& keypoints, OutputArray descriptors, bool useProvidedKeypoints)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#SURF::SURF()"><strong>SURF::SURF (C++ function)</strong></a>, <a href="modules/xfeatures2d/doc/nonfree_features.html#SURF::SURF(double hessianThreshold, int nOctaves, int nOctaveLayers, bool extended, bool upright)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/xfeatures2d/doc/nonfree_features.html#int upright"><strong>SURF::upright (C++ member)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.SVBackSubst"><strong>SVBackSubst() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSVBkSb(const CvArr* W, const CvArr* U, const CvArr* V, const CvArr* B, CvArr* X, int flags)"><strong>SVBkSb (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvSVD(CvArr* A, CvArr* W, CvArr* U, CvArr* V, int flags)"><strong>SVD (C function)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD"><strong>(C++ class)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void SVD::backSubst(InputArray rhs, OutputArray dst) const"><strong>SVD::backSubst (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#static void SVD::backSubst(InputArray w, InputArray u, InputArray vt, InputArray rhs, OutputArray dst)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#static void SVD::compute(InputArray src, OutputArray w, OutputArray u, OutputArray vt, int flags)"><strong>SVD::compute (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#static void SVD::compute(InputArray src, OutputArray w, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD& SVD::operator()(InputArray src, int flags)"><strong>SVD::operator() (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#static void SVD::solveZ(InputArray src, OutputArray dst)"><strong>SVD::solveZ (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#SVD::SVD()"><strong>SVD::SVD (C++ function)</strong></a>, <a href="modules/core/doc/operations_on_arrays.html#SVD::SVD(InputArray src, int flags)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.SVDecomp"><strong>SVDecomp() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#SVM : public StatModel"><strong>SVM (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#Ptr<SVM> SVM::create(const Params& p, const Ptr<Kernel>& customKernel)"><strong>SVM::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#double SVM::getDecisionFunction(int i, OutputArray alpha, OutputArray svidx) const"><strong>SVM::getDecisionFunction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#ParamGrid SVM::getDefaulltGrid(int param_id)"><strong>SVM::getDefaulltGrid (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#SVM::Params SVM::getParams() const"><strong>SVM::getParams (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#Mat SVM::getSupportVectors() const"><strong>SVM::getSupportVectors (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#SVM::Params"><strong>SVM::Params (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#SVM::Params::Params()"><strong>SVM::Params::Params (C++ function)</strong></a>, <a href="modules/ml/doc/support_vector_machines.html#SVM::Params::Params(int svmType, int kernelType, double degree, double gamma, double coef0, double Cvalue, double nu, double p, const Mat& classWeights, TermCriteria termCrit)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/support_vector_machines.html#bool SVM::trainAuto(const Ptr<TrainData>& data, int kFold , ParamGrid Cgrid , ParamGrid gammaGrid , ParamGrid pGrid , ParamGrid nuGrid , ParamGrid coeffGrid , ParamGrid degreeGrid , bool balanced)"><strong>SVM::trainAuto (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename T> void swap(Ptr<T>& ptr1, Ptr<T>& ptr2)"><strong>swap (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="T">T</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y, typename D> Ptr::Ptr(Y* p, D d)"><strong>template&lt;typename Y, typename D&gt; Ptr::Ptr (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr::Ptr(Y* p)"><strong>template&lt;typename Y&gt; Ptr::Ptr (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr::Ptr(const Ptr<Y>& o)"><strong>[1]</strong></a>, <a href="modules/core/doc/basic_structures.html#template<typename Y> Ptr::Ptr(const Ptr<Y>& o, T* p)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#TermCriteria"><strong>TermCriteria (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/basic_structures.html#TermCriteria::TermCriteria()"><strong>TermCriteria::TermCriteria (C++ function)</strong></a>, <a href="modules/core/doc/basic_structures.html#TermCriteria::TermCriteria(int type, int maxCount, double epsilon)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/cloning.html#void textureFlattening(InputArray src, InputArray mask, OutputArray dst, double low_threshold, double high_threshold, int kernel_size)"><strong>textureFlattening (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#RNG& theRNG()"><strong>theRNG (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#ThinPlateSplineShapeTransformer : public Algorithm"><strong>ThinPlateSplineShapeTransformer (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/histograms.html#void cvThreshHist(CvHistogram* hist, double threshold)"><strong>ThreshHist (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#double cvThreshold(const CvArr* src, CvArr* dst, double threshold, double max_value, int threshold_type)"><strong>Threshold (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type)"><strong>threshold (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.threshold"><strong>threshold() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#Tonemap : public Algorithm"><strong>Tonemap (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#void Tonemap::process(InputArray src, OutputArray dst)"><strong>Tonemap::process (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#TonemapDrago : public Tonemap"><strong>TonemapDrago (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#TonemapDurand : public Tonemap"><strong>TonemapDurand (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#TonemapMantiuk : public Tonemap"><strong>TonemapMantiuk (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/photo/doc/hdr_imaging.html#TonemapReinhard : public Tonemap"><strong>TonemapReinhard (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/tr_chars.html#TR_chars"><strong>TR_chars (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/datasets/doc/tr_svt.html#TR_svt"><strong>TR_svt (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#CvScalar cvTrace(const CvArr* mat)"><strong>Trace (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#Scalar trace(InputArray mtx)"><strong>trace (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.trace"><strong>trace() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker.html#Tracker"><strong>Tracker (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker.html#static Ptr<Tracker> Tracker::create(const String& trackerType)"><strong>Tracker::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker.html#bool Tracker::init(const Mat& image, const Rect2d& boundingBox)"><strong>Tracker::init (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker.html#bool Tracker::update(const Mat& image, Rect2d& boundingBox)"><strong>Tracker::update (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerAdaBoostingTargetState"><strong>TrackerAdaBoostingTargetState (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerBoosting"><strong>TrackerBoosting (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#Ptr<trackerBoosting> TrackerBoosting::createTracker(const trackerBoosting::Params &parameters)"><strong>TrackerBoosting::createTracker (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerBoosting::Params"><strong>TrackerBoosting::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#TrackerFeature"><strong>TrackerFeature (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeature::compute(const std::vector<Mat>& images, Mat& response)"><strong>TrackerFeature::compute (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#static Ptr<TrackerFeature> TrackerFeature::create(const String& trackerFeatureType)"><strong>TrackerFeature::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#String TrackerFeature::getClassName() const"><strong>TrackerFeature::getClassName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeature::selection(Mat& response, int npoints)"><strong>TrackerFeature::selection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#TrackerFeatureHAAR"><strong>TrackerFeatureHAAR (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#bool TrackerFeatureHAAR::extractSelected(const std::vector<int> selFeatures, const std::vector<Mat>& images, Mat& response)"><strong>TrackerFeatureHAAR::extractSelected (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#CvHaarEvaluator::FeatureHaar& TrackerFeatureHAAR::getFeatureAt(int id)"><strong>TrackerFeatureHAAR::getFeatureAt (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#std::vector<std::pair<float, float> >& TrackerFeatureHAAR::getMeanSigmaPairs()"><strong>TrackerFeatureHAAR::getMeanSigmaPairs (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#TrackerFeatureHAAR::Params"><strong>TrackerFeatureHAAR::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeatureHAAR::selection(Mat& response, int npoints)"><strong>TrackerFeatureHAAR::selection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#bool TrackerFeatureHAAR::swapFeature(int source, int target)"><strong>TrackerFeatureHAAR::swapFeature (C++ function)</strong></a>, <a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#bool TrackerFeatureHAAR::swapFeature(int id, CvHaarEvaluator::FeatureHaar& feature)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#TrackerFeatureHAAR::TrackerFeatureHAAR(const TrackerFeatureHAAR::Params &parameters)"><strong>TrackerFeatureHAAR::TrackerFeatureHAAR (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#TrackerFeatureSet"><strong>TrackerFeatureSet (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#bool TrackerFeatureSet::addTrackerFeature(String trackerFeatureType)"><strong>TrackerFeatureSet::addTrackerFeature (C++ function)</strong></a>, <a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#bool TrackerFeatureSet::addTrackerFeature(Ptr<TrackerFeature>& feature)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeatureSet::extraction(const std::vector<Mat>& images)"><strong>TrackerFeatureSet::extraction (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#const std::vector<Mat>& TrackerFeatureSet::getResponses() const"><strong>TrackerFeatureSet::getResponses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#const std::vector<std::pair<String, Ptr<TrackerFeature> > >& TrackerFeatureSet::getTrackerFeature() const"><strong>TrackerFeatureSet::getTrackerFeature (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeatureSet::removeOutliers()"><strong>TrackerFeatureSet::removeOutliers (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_feature_set.html#void TrackerFeatureSet::selection()"><strong>TrackerFeatureSet::selection (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerMedianFlow"><strong>TrackerMedianFlow (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#Ptr<trackerMedianFlow> TrackerMedianFlow::createTracker(const trackerMedianFlow::Params &parameters)"><strong>TrackerMedianFlow::createTracker (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerMedianFlow::Params"><strong>TrackerMedianFlow::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerMIL"><strong>TrackerMIL (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#Ptr<trackerMIL> TrackerMIL::createTracker(const trackerMIL::Params &parameters)"><strong>TrackerMIL::createTracker (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerMIL::Params"><strong>TrackerMIL::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerMILTargetState"><strong>TrackerMILTargetState (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerModel"><strong>TrackerModel (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#const std::vector<ConfidenceMap>& TrackerModel::getConfidenceMaps() const"><strong>TrackerModel::getConfidenceMaps (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#const ConfidenceMap& TrackerModel::getLastConfidenceMap() const"><strong>TrackerModel::getLastConfidenceMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#Ptr<TrackerTargetState> TrackerModel::getLastTargetState() const"><strong>TrackerModel::getLastTargetState (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#Ptr<TrackerStateEstimator> TrackerModel::getTrackerStateEstimator() const"><strong>TrackerModel::getTrackerStateEstimator (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerModel::modelEstimation(const std::vector<Mat>& responses)"><strong>TrackerModel::modelEstimation (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerModel::modelUpdate()"><strong>TrackerModel::modelUpdate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#bool TrackerModel::runStateEstimator()"><strong>TrackerModel::runStateEstimator (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerModel::setLastTargetState(const Ptr<TrackerTargetState>& lastTargetState)"><strong>TrackerModel::setLastTargetState (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#bool TrackerModel::setTrackerStateEstimator(Ptr<TrackerStateEstimator> trackerStateEstimator)"><strong>TrackerModel::setTrackerStateEstimator (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSampler"><strong>TrackerSampler (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#bool TrackerSampler::addTrackerSamplerAlgorithm(String trackerSamplerAlgorithmType)"><strong>TrackerSampler::addTrackerSamplerAlgorithm (C++ function)</strong></a>, <a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#bool TrackerSampler::addTrackerSamplerAlgorithm(Ptr<TrackerSamplerAlgorithm>& sampler)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#const std::vector<std::pair<String, Ptr<TrackerSamplerAlgorithm> > >& TrackerSampler::getSamplers() const"><strong>TrackerSampler::getSamplers (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#const std::vector<Mat>& TrackerSampler::getSamples() const"><strong>TrackerSampler::getSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#void TrackerSampler::sampling(const Mat& image, Rect boundingBox)"><strong>TrackerSampler::sampling (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerAlgorithm"><strong>TrackerSamplerAlgorithm (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#static Ptr<TrackerSamplerAlgorithm> TrackerSamplerAlgorithm::create(const String& trackerSamplerType)"><strong>TrackerSamplerAlgorithm::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#String TrackerSamplerAlgorithm::getClassName() const"><strong>TrackerSamplerAlgorithm::getClassName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#bool TrackerSamplerAlgorithm::sampling(const Mat& image, Rect boundingBox, std::vector<Mat>& sample)"><strong>TrackerSamplerAlgorithm::sampling (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCS"><strong>TrackerSamplerCS (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCS::Params"><strong>TrackerSamplerCS::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#void TrackerSamplerCS::setMode(int samplingMode)"><strong>TrackerSamplerCS::setMode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCS::TrackerSamplerCS(const TrackerSamplerCS::Params &parameters)"><strong>TrackerSamplerCS::TrackerSamplerCS (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCSC"><strong>TrackerSamplerCSC (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCSC::Params"><strong>TrackerSamplerCSC::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#void TrackerSamplerCSC::setMode(int samplingMode)"><strong>TrackerSamplerCSC::setMode (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerCSC::TrackerSamplerCSC(const TrackerSamplerCSC::Params &parameters)"><strong>TrackerSamplerCSC::TrackerSamplerCSC (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerPF"><strong>TrackerSamplerPF (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerPF(const Mat& chosenRect,const TrackerSamplerPF::Params &parameters)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_sampler.html#TrackerSamplerPF::Params"><strong>TrackerSamplerPF::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerStateEstimator"><strong>TrackerStateEstimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#static Ptr<TrackerStateEstimator> TrackerStateEstimator::create(const String& trackeStateEstimatorType)"><strong>TrackerStateEstimator::create (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#Ptr<TrackerTargetState> TrackerStateEstimator::estimate(const std::vector<ConfidenceMap>& confidenceMaps)"><strong>TrackerStateEstimator::estimate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#String TrackerStateEstimator::getClassName() const"><strong>TrackerStateEstimator::getClassName (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimator::update(std::vector<ConfidenceMap>& confidenceMaps)"><strong>TrackerStateEstimator::update (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerStateEstimatorAdaBoosting"><strong>TrackerStateEstimatorAdaBoosting (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#std::vector<int> TrackerStateEstimatorAdaBoosting::computeReplacedClassifier()"><strong>TrackerStateEstimatorAdaBoosting::computeReplacedClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#std::vector<int> TrackerStateEstimatorAdaBoosting::computeSelectedWeakClassifier()"><strong>TrackerStateEstimatorAdaBoosting::computeSelectedWeakClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#std::vector<int> TrackerStateEstimatorAdaBoosting::computeSwappedClassifier()"><strong>TrackerStateEstimatorAdaBoosting::computeSwappedClassifier (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#Rect TrackerStateEstimatorAdaBoosting::getSampleROI() const"><strong>TrackerStateEstimatorAdaBoosting::getSampleROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorAdaBoosting::setCurrentConfidenceMap(ConfidenceMap& confidenceMap)"><strong>TrackerStateEstimatorAdaBoosting::setCurrentConfidenceMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorAdaBoosting::setMeanSigmaPair(const std::vector<std::pair<float, float> >& meanSigmaPair)"><strong>TrackerStateEstimatorAdaBoosting::setMeanSigmaPair (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorAdaBoosting::setSampleROI(const Rect& ROI)"><strong>TrackerStateEstimatorAdaBoosting::setSampleROI (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#Mat TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::getTargetResponses()"><strong>TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::getTargetResponses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#bool TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::isTargetFg() const"><strong>TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::isTargetFg (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::setTargetFg(bool foreground)"><strong>TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::setTargetFg (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::setTargetResponses(const Mat& responses)"><strong>TrackerStateEstimatorAdaBoosting::TrackerAdaBoostingTargetState::setTargetResponses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerStateEstimatorAdaBoosting::TrackerStateEstimatorAdaBoosting(int numClassifer, int initIterations, int nFeatures, Size patchSize, const Rect& ROI, const std::vector<std::pair<float, float> >& meanSigma)"><strong>TrackerStateEstimatorAdaBoosting::TrackerStateEstimatorAdaBoosting (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerStateEstimatorMILBoosting"><strong>TrackerStateEstimatorMILBoosting (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorMILBoosting::setCurrentConfidenceMap(ConfidenceMap& confidenceMap)"><strong>TrackerStateEstimatorMILBoosting::setCurrentConfidenceMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#bool TrackerStateEstimatorMILBoosting::TrackerMILTargetState::isTargetFg() const"><strong>TrackerStateEstimatorMILBoosting::TrackerMILTargetState::isTargetFg (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorMILBoosting::TrackerMILTargetState::setFeatures(const Mat& features)"><strong>TrackerStateEstimatorMILBoosting::TrackerMILTargetState::setFeatures (C++ function)</strong></a>, <a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorMILBoosting::TrackerMILTargetState::setFeatures(const Mat& features)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#void TrackerStateEstimatorMILBoosting::TrackerMILTargetState::setTargetFg(bool foreground)"><strong>TrackerStateEstimatorMILBoosting::TrackerMILTargetState::setTargetFg (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerStateEstimatorMILBoosting::TrackerStateEstimatorMILBoosting(int nFeatures)"><strong>TrackerStateEstimatorMILBoosting::TrackerStateEstimatorMILBoosting (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#TrackerTargetState"><strong>TrackerTargetState (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerTLD"><strong>TrackerTLD (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#Ptr<trackerTLD> TrackerTLD::createTracker(const trackerTLD::Params &parameters)"><strong>TrackerTLD::createTracker (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/tracker_algorithms.html#TrackerTLD::Params"><strong>TrackerTLD::Params (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#TrainData"><strong>TrainData (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Mat TrainData::getClassLabels() const"><strong>TrainData::getClassLabels (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Mat TrainData::getTrainNormCatResponses() const"><strong>TrainData::getTrainNormCatResponses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Mat TrainData::getTrainResponses() const"><strong>TrainData::getTrainResponses (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#Mat TrainData::getTrainSamples(int layout, bool compressSamples, bool compressVars) const"><strong>TrainData::getTrainSamples (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/ml/doc/mldata.html#void TrainData::setTrainTestSplitRatio(double ratio, bool shuffle)"><strong>TrainData::setTrainTestSplitRatio (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/tracking/doc/common_interfaces_tracker_model.html#c.Trajectory">Trajectory (C type)</a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvTransform(const CvArr* src, CvArr* dst, const CvMat* transmat, const CvMat* shiftvec)"><strong>Transform (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void transform(InputArray src, OutputArray dst, InputArray m)"><strong>transform (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.transform"><strong>transform() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvTranspose(const CvArr* src, CvArr* dst)"><strong>Transpose (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void transpose(InputArray src, OutputArray dst)"><strong>transpose (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/operations_on_arrays.html#cv2.transpose"><strong>transpose() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/dynamic_structures.html#CvSeq* cvTreeToNodeSeq(const void* first, int header_size, CvMemStorage* storage)"><strong>TreeToNodeSeq (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void cvTriangulatePoints(CvMat* projMatr1, CvMat* projMatr2, CvMat* projPoints1, CvMat* projPoints2, CvMat* points4D)"><strong>TriangulatePoints (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#void triangulatePoints(InputArray projMatr1, InputArray projMatr2, InputArray projPoints1, InputArray projPoints2, OutputArray points4D)"><strong>triangulatePoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#cv2.triangulatePoints"><strong>triangulatePoints() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#CvTypeInfo* cvTypeOf(const void* struct_ptr)"><strong>TypeOf (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="U">U</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void undistort(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray newCameraMatrix)"><strong>undistort (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.undistort"><strong>undistort() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvUndistort2(const CvArr* src, CvArr* dst, const CvMat* camera_matrix, const CvMat* distortion_coeffs, const CvMat* new_camera_matrix)"><strong>Undistort2 (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvUndistortPoints(const CvMat* src, CvMat* dst, const CvMat* camera_matrix, const CvMat* dist_coeffs, const CvMat* R, const CvMat* P)"><strong>UndistortPoints (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void undistortPoints(InputArray src, OutputArray dst, InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray P)"><strong>undistortPoints (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvUnregisterType(const char* type_name)"><strong>UnregisterType (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/motion_templates.html#void updateMotionHistory(InputArray silhouette, InputOutputArray mhi, double timestamp, double duration)"><strong>updateMotionHistory (C++ function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/optflow/doc/motion_templates.html#cv2.updateMotionHistory"><strong>updateMotionHistory() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#void updateWidgetPose(const Affine3d &pose)"><strong>updateWidgetPose (C++ function)</strong></a>, <a href="modules/viz/doc/viz3d.html#void updateWidgetPose(const String &id, const Affine3d &pose)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#void updateWindow(const String& winname)"><strong>updateWindow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#int cvUseOptimized(int on_off)"><strong>UseOptimized (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#bool useOptimized()"><strong>useOptimized (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/utility_and_system_functions_and_macros.html#cv2.useOptimized"><strong>useOptimized() (Python function in cv2)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="V">V</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/basic_structures.html#Vec"><strong>Vec (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture"><strong>VideoCapture (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture"><strong>VideoCapture() (Python function in cv2)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture"><strong>[1]</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.get"><strong>VideoCapture.get() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.grab"><strong>VideoCapture.grab() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.isOpened"><strong>VideoCapture.isOpened() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.open"><strong>VideoCapture.open() (Python function in cv2)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.open"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.read"><strong>VideoCapture.read() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.release"><strong>VideoCapture.release() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.retrieve"><strong>VideoCapture.retrieve() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoCapture.set"><strong>VideoCapture.set() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#double VideoCapture::get(int propId)"><strong>VideoCapture::get (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::grab()"><strong>VideoCapture::grab (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::isOpened()"><strong>VideoCapture::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::open(const String& filename)"><strong>VideoCapture::open (C++ function)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::open(int device)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture& VideoCapture::operator >> (Mat& image)"><strong>VideoCapture::operator&gt;&gt; (C++ function)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture& VideoCapture::operator >> (UMat& image)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::read(OutputArray image)"><strong>VideoCapture::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#void VideoCapture::release()"><strong>VideoCapture::release (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::retrieve(OutputArray image, int flag)"><strong>VideoCapture::retrieve (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoCapture::set(int propId, double value)"><strong>VideoCapture::set (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture::VideoCapture()"><strong>VideoCapture::VideoCapture (C++ function)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture::VideoCapture(const String& filename)"><strong>[1]</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#VideoCapture::VideoCapture(int device)"><strong>[2]</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#Mat videostab::estimateGlobalMotionLeastSquares(InputOutputArray points0, InputOutputArray points1, int model , float *rmse)"><strong>videostab::estimateGlobalMotionLeastSquares (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#Mat videostab::estimateGlobalMotionRansac(InputArray points0, InputArray points1, int model , const RansacParams &params , float *rmse , int *ninliers)"><strong>videostab::estimateGlobalMotionRansac (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/fast_marching.html#videostab::FastMarchingMethod"><strong>videostab::FastMarchingMethod (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/fast_marching.html#Mat videostab::FastMarchingMethod::distanceMap() const"><strong>videostab::FastMarchingMethod::distanceMap (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/fast_marching.html#videostab::FastMarchingMethod::FastMarchingMethod()"><strong>videostab::FastMarchingMethod::FastMarchingMethod (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/fast_marching.html#template<typename Inpaint> Inpaint videostab::FastMarchingMethod::run(const Mat &mask, Inpaint inpaint)"><strong>videostab::FastMarchingMethod::run (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#Mat videostab::getMotion(int from, int to, const std::vector<Mat> &motions)"><strong>videostab::getMotion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::ImageMotionEstimatorBase"><strong>videostab::ImageMotionEstimatorBase (C++ class)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::KeypointBasedMotionEstimator : public videostab::ImageMotionEstimatorBase"><strong>videostab::KeypointBasedMotionEstimator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::MotionEstimatorBase"><strong>videostab::MotionEstimatorBase (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#Mat videostab::MotionEstimatorBase::estimate(InputArray points0, InputArray points1, bool *ok)"><strong>videostab::MotionEstimatorBase::estimate (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#MotionModel videostab::MotionEstimatorBase::motionModel() const"><strong>videostab::MotionEstimatorBase::motionModel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#void videostab::MotionEstimatorBase::setMotionModel(MotionModel val)"><strong>videostab::MotionEstimatorBase::setMotionModel (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::MotionEstimatorL1 : public videostab::MotionEstimatorBase"><strong>videostab::MotionEstimatorL1 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::MotionEstimatorRansacL2 : public videostab::MotionEstimatorBase"><strong>videostab::MotionEstimatorRansacL2 (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::MotionModel"><strong>videostab::MotionModel (enum)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::RansacParams"><strong>videostab::RansacParams (C++ structure)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#static RansacParams videostab::RansacParams::default2dMotion(MotionModel model)"><strong>videostab::RansacParams::default2dMotion (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#int videostab::RansacParams::niters() const"><strong>videostab::RansacParams::niters (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videostab/doc/global_motion.html#videostab::RansacParams::RansacParams()"><strong>videostab::RansacParams::RansacParams (C++ function)</strong></a>, <a href="modules/videostab/doc/global_motion.html#videostab::RansacParams::RansacParams(int size, float thresh, float eps, float prob)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoWriter"><strong>VideoWriter (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter"><strong>VideoWriter() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.isOpened"><strong>VideoWriter.isOpened() (Python function in cv2)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.isOpened"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.open"><strong>VideoWriter.open() (Python function in cv2)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.open"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.write"><strong>VideoWriter.write() (Python function in cv2)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter.write"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#static int VideoWriter::fourcc(char c1, char c2, char c3, char c4)"><strong>VideoWriter::fourcc (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoWriter::isOpened()"><strong>VideoWriter::isOpened (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#bool VideoWriter::open(const String& filename, int fourcc, double fps, Size frameSize, bool isColor)"><strong>VideoWriter::open (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoWriter& VideoWriter::operator << (const Mat& image)"><strong>VideoWriter::operator&lt;&lt; (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#VideoWriter::VideoWriter()"><strong>VideoWriter::VideoWriter (C++ function)</strong></a>, <a href="modules/videoio/doc/reading_and_writing_video.html#VideoWriter::VideoWriter(const String& filename, int fourcc, double fps, Size frameSize, bool isColor)"><strong>[1]</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#void VideoWriter::write(const Mat& image)"><strong>VideoWriter::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#cv2.VideoWriter_fourcc"><strong>VideoWriter_fourcc() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d"><strong>Viz3d (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#void Viz3d::showWidget(const String &id, const Widget &widget, const Affine3d &pose)"><strong>Viz3d::showWidget (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Viz3d::Viz3d(const String& window_name)"><strong>Viz3d::Viz3d (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/viz3d.html#Affine3d viz::makeTransformToGlobal(const Vec3f& axis_x, const Vec3f& axis_y, const Vec3f& axis_z, const Vec3f& origin)"><strong>viz::makeTransformToGlobal (C++ function)</strong></a>
  </dt>

  </dl></td>
</tr></table>

<h2 id="W">W</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/highgui/doc/user_interface.html#int cvWaitKey(int delay)"><strong>WaitKey (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#int waitKey(int delay)"><strong>waitKey (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/highgui/doc/user_interface.html#cv2.waitKey"><strong>waitKey() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#WaldBoost : public Algorithm"><strong>WaldBoost (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#float WaldBoost::predict(const Ptr<FeatureEvaluator>& feature_evaluator) const"><strong>WaldBoost::predict (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void WaldBoost::read(const FileNode& node)"><strong>WaldBoost::read (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#vector<int> WaldBoost::train(const Mat& data, const Mat& labels)"><strong>WaldBoost::train (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/xobjdetect/doc/integral_channel_features.html#void WaldBoost::write(FileStorage& fs)"><strong>WaldBoost::write (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvWarpAffine(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)"><strong>WarpAffine (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void warpAffine(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)"><strong>warpAffine (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.warpAffine"><strong>warpAffine() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/stitching/doc/high_level.html#WarperCreator"><strong>WarperCreator (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/shape/doc/shape_transformers.html#void warpImage(InputArray transformingImage, OutputArray output, int flags, int borderMode, const Scalar& borderValue)"><strong>warpImage (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void cvWarpPerspective(const CvArr* src, CvArr* dst, const CvMat* map_matrix, int flags, CvScalar fillval)"><strong>WarpPerspective (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#void warpPerspective(InputArray src, OutputArray dst, InputArray M, Size dsize, int flags, int borderMode, const Scalar& borderValue)"><strong>warpPerspective (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/geometric_transformations.html#cv2.warpPerspective"><strong>warpPerspective() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WArrow"><strong>WArrow (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WArrow(const Point3f& pt1, const Point3f& pt2, double thickness , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/viz3d.html#bool wasStopped()"><strong>wasStopped (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void cvWatershed(const CvArr* image, CvArr* markers)"><strong>Watershed (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#void watershed(InputArray image, InputOutputArray markers)"><strong>watershed (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/imgproc/doc/miscellaneous_transformations.html#cv2.watershed"><strong>watershed() (Python function in cv2)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WCameraPosition"><strong>WCameraPosition (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCameraPosition(double scale)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Matx33d &K, double scale , const Color &color)"><strong>[1]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Vec2d &fov, double scale , const Color &color)"><strong>[2]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Matx33d &K, InputArray image, double scale , const Color &color)"><strong>[3]</strong></a>, <a href="modules/viz/doc/widget.html#WCameraPosition(const Vec2d &fov, InputArray image, double scale , const Color &color)"><strong>[4]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCircle"><strong>WCircle (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCircle(double radius, double thickness , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCircle(double radius, const Point3d& center, const Vec3d& normal, double thickness , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloud"><strong>WCloud (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, InputArray colors)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, const Color &color)"><strong>[1]</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, InputArray colors, InputArray normals)"><strong>[2]</strong></a>, <a href="modules/viz/doc/widget.html#WCloud(InputArray cloud, const Color &color, InputArray normals)"><strong>[3]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloudCollection"><strong>WCloudCollection (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloudCollection()"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCloudNormals"><strong>WCloudNormals (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCloudNormals(InputArray cloud, InputArray normals, int level , double scale , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCone"><strong>WCone (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCone(double length, double radius, int resolution , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WCone(double radius, const Point3d& center, const Point3d& tip, int resolution , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCoordinateSystem"><strong>WCoordinateSystem (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCoordinateSystem(double scale)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WCube"><strong>WCube (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCube(const Point3f& pt_min, const Point3f& pt_max, bool wire_frame , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/viz/doc/widget.html#WCylinder"><strong>WCylinder (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WCylinder(const Point3f& pt_on_axis, const Point3f& axis_direction, double radius, int numsides , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WGrid"><strong>WGrid (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WGrid(const Vec2i &cells , const Vec2d &cells_spacing , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#Widget"><strong>Widget (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#Widget2D"><strong>Widget2D (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#Widget3D"><strong>Widget3D (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WidgetAccessor"><strong>WidgetAccessor (C++ class)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WImage3D"><strong>WImage3D (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WImage3D(InputArray image, const Size2d &size)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WImage3D(InputArray image, const Size2d &size, const Vec3d &position, const Vec3d &normal, const Vec3d &up_vector)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WImageOverlay"><strong>WImageOverlay (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WImageOverlay(InputArray image, const Rect &rect)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WLine"><strong>WLine (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WLine(const Point3f &pt1, const Point3f &pt2, const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WMesh"><strong>WMesh (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WMesh(const Mesh &mesh)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WMesh(InputArray cloud, InputArray polygons, InputArray colors , InputArray normals)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WPlane"><strong>WPlane (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WPlane(const Size2d& size , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WPlane(const Point3d& center, const Vec3d& normal, const Vec3d& new_yaxis,const Size2d& size , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WPolyLine"><strong>WPolyLine (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WPolyLine(InputArray points, const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWrite(CvFileStorage* fs, const char* name, const void* ptr, CvAttrList attributes)"><strong>Write (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteComment(CvFileStorage* fs, const char* comment, int eol_comment)"><strong>WriteComment (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteFileNode(CvFileStorage* fs, const char* new_node_name, const CvFileNode* node, int embed)"><strong>WriteFileNode (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/videoio/doc/reading_and_writing_video.html#int cvWriteFrame(CvVideoWriter* writer, const IplImage* image)"><strong>WriteFrame (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteInt(CvFileStorage* fs, const char* name, int value)"><strong>WriteInt (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/optflow/doc/optflow_io.html#bool writeOpticalFlow(const String& path, InputArray flow)"><strong>writeOpticalFlow (C++ function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteRawData(CvFileStorage* fs, const void* src, int len, const char* dt)"><strong>WriteRawData (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteReal(CvFileStorage* fs, const char* name, double value)"><strong>WriteReal (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/core/doc/old_xml_yaml_persistence.html#void cvWriteString(CvFileStorage* fs, const char* name, const char* str, int quote)"><strong>WriteString (C function)</strong></a>
  </dt>

      
  <dt><a href="modules/viz/doc/widget.html#WSphere"><strong>WSphere (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WSphere(const cv::Point3f &center, double radius, int sphere_resolution , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WText"><strong>WText (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WText(const String &text, const Point2i &pos, int font_size , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WText3D"><strong>WText3D (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WText3D(const String &text, const Point3f &position, double text_scale , bool face_camera , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectory"><strong>WTrajectory (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectory(InputArray path, int display_mode , double scale , const Color &color)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectoryFrustums"><strong>WTrajectoryFrustums (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectoryFrustums(const std::vector<Affine3d> &path, const Matx33d &K, double scale , const Color &color)"><strong>(C++ function)</strong></a>, <a href="modules/viz/doc/widget.html#WTrajectoryFrustums(const std::vector<Affine3d> &path, const Vec2d &fov, double scale , const Color &color)"><strong>[1]</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WTrajectorySpheres"><strong>WTrajectorySpheres (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WTrajectorySpheres(InputArray path, double line_length , double radius , const Color &from , const Color &to)"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
      
  <dt><a href="modules/viz/doc/widget.html#WWidgetMerger"><strong>WWidgetMerger (C++ class)</strong></a>
  </dt>

      <dd><dl>
        
  <dt><a href="modules/viz/doc/widget.html#WWidgetMerger()"><strong>(C++ function)</strong></a>
  </dt>

      </dl></dd>
  </dl></td>
</tr></table>

<h2 id="X">X</h2>
<table style="width: 100%" class="indextable genindextable"><tr>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvXor(const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask)"><strong>Xor (C function)</strong></a>
  </dt>

  </dl></td>
  <td style="width: 33%" valign="top"><dl>
      
  <dt><a href="modules/core/doc/operations_on_arrays.html#void cvXorS(const CvArr* src, CvScalar value, CvArr* dst, const CvArr* mask)"><strong>XorS (C function)</strong></a>
  </dt>

  </dl></td>
</tr></table>



          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="#" title="General Index"
             >index</a></li>
        <li><a href="index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>

<!-- Mirrored from docs.opencv.org/3.0-last-rst/genindex.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 06:57:27 GMT -->
</html>