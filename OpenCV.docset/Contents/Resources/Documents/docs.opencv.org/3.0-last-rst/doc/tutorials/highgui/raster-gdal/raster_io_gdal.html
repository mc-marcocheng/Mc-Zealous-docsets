<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33108845-1']);
  _gaq.push(['_setDomainName', 'opencv.org']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/raster-gdal/raster_io_gdal.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 07:06:01 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Reading Geospatial Raster files with GDAL</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '3.0.0-dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 3.0.0-dev documentation" href="../../../../index.html" />
    <link rel="up" title="highgui module. High Level GUI and Media" href="../table_of_content_highgui/table_of_content_highgui.html" />
    <link rel="next" title="calib3d module. Camera calibration and 3D reconstruction" href="../../calib3d/table_of_content_calib3d/table_of_content_calib3d.html" />
    <link rel="prev" title="Creating a video with OpenCV" href="../video-write/video-write.html" />
    <link href='../../../../../../fonts.googleapis.com/css8a7c.css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../calib3d/table_of_content_calib3d/table_of_content_calib3d.html" title="calib3d module. Camera calibration and 3D reconstruction"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../video-write/video-write.html" title="Creating a video with OpenCV"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li>
          <li><a href="../../tutorials.html" >OpenCV Tutorials</a> &raquo;</li>
          <li><a href="../table_of_content_highgui/table_of_content_highgui.html" accesskey="U"><em>highgui</em> module. High Level GUI and Media</a> &raquo;</li> 
      </ul>
    </div>  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/opencv-logo2.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="http://docs.opencv.org/3.0-last-rst/search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Reading Geospatial Raster files with GDAL</a><ul>
<li><a class="reference internal" href="#goals">Goals</a></li>
<li><a class="reference internal" href="#code">Code</a></li>
<li><a class="reference internal" href="#how-to-read-raster-data-using-gdal">How to Read Raster Data using GDAL</a></li>
<li><a class="reference internal" href="#notes">Notes</a><ul>
<li><a class="reference internal" href="#lat-lon-geodetic-coordinates-should-normally-be-avoided">Lat/Lon (Geodetic) Coordinates should normally be avoided</a></li>
<li><a class="reference internal" href="#finding-the-corner-coordinates">Finding the corner coordinates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#results">Results</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../video-write/video-write.html"
                        title="previous chapter">Creating a video with OpenCV</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../../calib3d/table_of_content_calib3d/table_of_content_calib3d.html"
                        title="next chapter"><em>calib3d</em> module. Camera calibration and 3D reconstruction</a></p>
        </div>
      </div>
  <body>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="reading-geospatial-raster-files-with-gdal">
<span id="raster-io-gdal"></span><h1>Reading Geospatial Raster files with GDAL<a class="headerlink" href="#reading-geospatial-raster-files-with-gdal" title="Permalink to this headline">¶</a></h1>
<p>Geospatial raster data is a heavily used product in Geographic Information
Systems and Photogrammetry.  Raster data typically can represent imagery
and Digital Elevation Models (DEM).  The standard library for loading
GIS imagery is the Geographic Data Abstraction Library (GDAL).  In this example, we
will show techniques for loading GIS raster formats using native OpenCV functions.
In addition, we will show some an example of how OpenCV can use this data for
novel and interesting purposes.</p>
<div class="section" id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<p>The primary objectives for this tutorial:</p>
<div class="enumeratevisibleitemswithsquare container">
<ul class="simple">
<li>How to use OpenCV imread to load satellite imagery.</li>
<li>How to use OpenCV imread to load SRTM Digital Elevation Models</li>
<li>Given the corner coordinates of both the image and DEM, correllate the elevation data to the image to find elevations for each pixel.</li>
<li>Show a basic, easy-to-implement example of a terrain heat map.</li>
<li>Show a basic use of DEM data coupled with ortho-rectified imagery.</li>
</ul>
</div>
<p>To implement these goals, the following code takes a Digital Elevation Model as well as a GeoTiff image of San Francisco as input.
The image and DEM data is processed and generates a terrain heat map of the image as well as labels areas of the city which would
be affected should the water level of the bay rise 10, 50, and 100 meters.</p>
</div>
<div class="section" id="code">
<h2>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * gdal_image.cpp -- Load GIS data into OpenCV Containers using the Geospatial Data Abstraction Library</span>
<span class="cm">*/</span>

<span class="c1">/// OpenCV Headers</span>
<span class="cp">#include &quot;opencv2/core/core.hpp&quot;</span>
<span class="cp">#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span>
<span class="cp">#include &quot;opencv2/highgui/highgui.hpp&quot;</span>

<span class="c1">/// C++ Standard Libraries</span>
<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;stdexcept&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">/// define the corner points</span>
<span class="c1">///    Note that GDAL can natively determine this</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">tl</span><span class="p">(</span> <span class="o">-</span><span class="mf">122.441017</span><span class="p">,</span> <span class="mf">37.815664</span> <span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">tr</span><span class="p">(</span> <span class="o">-</span><span class="mf">122.370919</span><span class="p">,</span> <span class="mf">37.815311</span> <span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">bl</span><span class="p">(</span> <span class="o">-</span><span class="mf">122.441533</span><span class="p">,</span> <span class="mf">37.747167</span> <span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">br</span><span class="p">(</span> <span class="o">-</span><span class="mf">122.3715</span><span class="p">,</span>   <span class="mf">37.746814</span> <span class="p">);</span>

<span class="c1">/// determine dem corners</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">dem_bl</span><span class="p">(</span> <span class="o">-</span><span class="mf">122.0</span><span class="p">,</span> <span class="mi">38</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">dem_tr</span><span class="p">(</span> <span class="o">-</span><span class="mf">123.0</span><span class="p">,</span> <span class="mi">37</span><span class="p">);</span>

<span class="c1">/// range of the heat map colors</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">color_range</span><span class="p">;</span>


<span class="c1">/// List of all function prototypes</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">lerp</span><span class="p">(</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="p">);</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span> <span class="n">get_dem_color</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="p">);</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">world2dem</span><span class="p">(</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="o">&amp;</span><span class="p">);</span>

<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">pixel2world</span><span class="p">(</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="o">&amp;</span> <span class="p">);</span>

<span class="kt">void</span> <span class="nf">add_color</span><span class="p">(</span> <span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&amp;</span> <span class="n">pix</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">);</span>



<span class="cm">/**</span>
<span class="cm"> * Linear Interpolation</span>
<span class="cm"> * p1 - Point 1</span>
<span class="cm"> * p2 - Point 2</span>
<span class="cm"> * t  - Ratio from Point 1 to Point 2</span>
<span class="cm">*/</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">lerp</span><span class="p">(</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">t</span> <span class="p">){</span>
    <span class="k">return</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span><span class="p">(</span> <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">),</span>
                        <span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Interpolate Colors</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">DATATYPE</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">DATATYPE</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">lerp</span><span class="p">(</span> <span class="n">cv</span><span class="o">::</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">DATATYPE</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">minColor</span><span class="p">,</span>
                          <span class="n">cv</span><span class="o">::</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">DATATYPE</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">maxColor</span><span class="p">,</span>
                          <span class="kt">double</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span> <span class="p">){</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">DATATYPE</span><span class="p">,</span><span class="n">N</span><span class="o">&gt;</span> <span class="n">output</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">){</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="p">)(((</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">minColor</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">maxColor</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Compute the dem color</span>
<span class="cm">*/</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span> <span class="n">get_dem_color</span><span class="p">(</span> <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">elevation</span> <span class="p">){</span>

    <span class="c1">// if the elevation is below the minimum, return the minimum</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">elevation</span> <span class="o">&lt;</span> <span class="n">color_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span> <span class="p">){</span>
        <span class="k">return</span> <span class="n">color_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// if the elevation is above the maximum, return the maximum</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">elevation</span> <span class="o">&gt;</span> <span class="n">color_range</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">second</span> <span class="p">){</span>
        <span class="k">return</span> <span class="n">color_range</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// otherwise, find the proper starting index</span>
    <span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">color_range</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="n">x</span><span class="o">++</span> <span class="p">){</span>

        <span class="c1">// if the current elevation is below the next item, then use the current</span>
        <span class="c1">// two colors as our range</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">elevation</span> <span class="o">&lt;</span> <span class="n">color_range</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">second</span> <span class="p">){</span>
            <span class="n">idx</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">color_range</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">second</span> <span class="o">-</span> <span class="n">elevation</span><span class="p">)</span><span class="o">/</span>
                <span class="p">(</span><span class="n">color_range</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">second</span> <span class="o">-</span> <span class="n">color_range</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// interpolate the color</span>
    <span class="k">return</span> <span class="n">lerp</span><span class="p">(</span> <span class="n">color_range</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">color_range</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Given a pixel coordinate and the size of the input image, compute the pixel location</span>
<span class="cm"> * on the DEM image.</span>
<span class="cm">*/</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">world2dem</span><span class="p">(</span> <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">coordinate</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="o">&amp;</span> <span class="n">dem_size</span>   <span class="p">){</span>


    <span class="c1">// relate this to the dem points</span>
    <span class="c1">// ASSUMING THAT DEM DATA IS ORTHORECTIFIED</span>
    <span class="kt">double</span> <span class="n">demRatioX</span> <span class="o">=</span> <span class="p">((</span><span class="n">dem_tr</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">coordinate</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dem_tr</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">dem_bl</span><span class="p">.</span><span class="n">x</span><span class="p">));</span>
    <span class="kt">double</span> <span class="n">demRatioY</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">((</span><span class="n">dem_tr</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">coordinate</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">dem_tr</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">dem_bl</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>

    <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">output</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">demRatioX</span> <span class="o">*</span> <span class="n">dem_size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="n">output</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">demRatioY</span> <span class="o">*</span> <span class="n">dem_size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Convert a pixel coordinate to world coordinates</span>
<span class="cm">*/</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">pixel2world</span><span class="p">(</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="o">&amp;</span> <span class="n">size</span> <span class="p">){</span>

    <span class="c1">// compute the ratio of the pixel location to its dimension</span>
    <span class="kt">double</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">x</span> <span class="o">/</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">ry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">y</span> <span class="o">/</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>

    <span class="c1">// compute LERP of each coordinate</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">rightSide</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">ry</span><span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">leftSide</span>  <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="n">ry</span><span class="p">);</span>

    <span class="c1">// compute the actual Lat/Lon coordinate of the interpolated coordinate</span>
    <span class="k">return</span> <span class="nf">lerp</span><span class="p">(</span> <span class="n">leftSide</span><span class="p">,</span> <span class="n">rightSide</span><span class="p">,</span> <span class="n">rx</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Add color to a specific pixel color value</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="n">add_color</span><span class="p">(</span> <span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&amp;</span> <span class="n">pix</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="k">const</span> <span class="n">uchar</span><span class="o">&amp;</span> <span class="n">r</span> <span class="p">){</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">){</span> <span class="n">pix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span> <span class="o">&lt;</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">){</span> <span class="n">pix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">g</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">pix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">255</span> <span class="o">&amp;&amp;</span> <span class="n">pix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">){</span> <span class="n">pix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Main Function</span>
<span class="cm">*/</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span> <span class="p">){</span>

    <span class="cm">/**</span>
<span class="cm">     * Check input arguments</span>
<span class="cm">    */</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;usage: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &lt;image&gt; &lt;dem&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// load the image (note that we don&#39;t have the projection information.  You will</span>
    <span class="c1">/// need to load that yourself or use the full GDAL driver.  The values are pre-defined</span>
    <span class="c1">/// at the top of this file</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_LOAD_GDAL</span> <span class="o">|</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_COLOR</span> <span class="p">);</span>

    <span class="c1">/// load the dem model</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">dem</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_LOAD_GDAL</span> <span class="o">|</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_ANYDEPTH</span> <span class="p">);</span>

    <span class="c1">/// create our output products</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">output_dem</span><span class="p">(</span>   <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">CV_8UC3</span> <span class="p">);</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">output_dem_flood</span><span class="p">(</span>   <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">CV_8UC3</span> <span class="p">);</span>

    <span class="c1">/// for sanity sake, make sure GDAL Loads it as a signed short</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">dem</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">CV_16SC1</span> <span class="p">){</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;DEM image type must be CV_16SC1&quot;</span><span class="p">);</span> <span class="p">}</span>

    <span class="c1">/// define the color range to create our output DEM heat map</span>
    <span class="c1">//  Pair format ( Color, elevation );  Push from low to high</span>
    <span class="c1">//  Note:  This would be perfect for a configuration file, but is here for a working demo.</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">188</span><span class="p">,</span> <span class="mi">154</span><span class="p">,</span>  <span class="mi">46</span><span class="p">),</span>   <span class="o">-</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">110</span><span class="p">),</span> <span class="mf">0.25</span><span class="p">));</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">230</span><span class="p">),</span>   <span class="mi">20</span><span class="p">));</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>   <span class="mi">75</span><span class="p">));</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">220</span><span class="p">,</span> <span class="mi">190</span><span class="p">,</span> <span class="mi">170</span><span class="p">),</span>  <span class="mi">100</span><span class="p">));</span>
    <span class="n">color_range</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="p">(</span> <span class="mi">250</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">140</span><span class="p">),</span>  <span class="mi">200</span><span class="p">));</span>

    <span class="c1">// define a minimum elevation</span>
    <span class="kt">double</span> <span class="n">minElevation</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span><span class="p">;</span>

    <span class="c1">// iterate over each pixel in the image, computing the dem point</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="n">image</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span> <span class="p">){</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">image</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span> <span class="p">){</span>

        <span class="c1">// convert the pixel coordinate to lat/lon coordinates</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">coordinate</span> <span class="o">=</span> <span class="n">pixel2world</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

        <span class="c1">// compute the dem image pixel coordinate from lat/lon</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Point2d</span> <span class="n">dem_coordinate</span> <span class="o">=</span> <span class="n">world2dem</span><span class="p">(</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">dem</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

        <span class="c1">// extract the elevation</span>
        <span class="kt">double</span> <span class="n">dz</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">dem_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span>    <span class="mi">0</span>    <span class="o">&amp;&amp;</span> <span class="n">dem_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span>    <span class="mi">0</span>     <span class="o">&amp;&amp;</span>
            <span class="n">dem_coordinate</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">dem</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;&amp;</span> <span class="n">dem_coordinate</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">dem</span><span class="p">.</span><span class="n">rows</span> <span class="p">){</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">dem</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dem_coordinate</span><span class="p">);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">minElevation</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// write the pixel value to the file</span>
        <span class="n">output_dem_flood</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">image</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>

        <span class="c1">// compute the color for the heat map output</span>
        <span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span> <span class="n">actualColor</span> <span class="o">=</span> <span class="n">get_dem_color</span><span class="p">(</span><span class="n">dz</span><span class="p">);</span>
        <span class="n">output_dem</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">actualColor</span><span class="p">;</span>

        <span class="c1">// show effect of a 10 meter increase in ocean levels</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">){</span>
            <span class="n">add_color</span><span class="p">(</span> <span class="n">output_dem_flood</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// show effect of a 50 meter increase in ocean levels</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="p">){</span>
            <span class="n">add_color</span><span class="p">(</span> <span class="n">output_dem_flood</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">// show effect of a 100 meter increase in ocean levels</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">dz</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="p">){</span>
            <span class="n">add_color</span><span class="p">(</span> <span class="n">output_dem_flood</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3b</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">90</span> <span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}}</span>

    <span class="c1">// print our heat map</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">imwrite</span><span class="p">(</span> <span class="s">&quot;heat-map.jpg&quot;</span>   <span class="p">,</span>  <span class="n">output_dem</span> <span class="p">);</span>

    <span class="c1">// print the flooding effect image</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">imwrite</span><span class="p">(</span> <span class="s">&quot;flooded.jpg&quot;</span><span class="p">,</span>  <span class="n">output_dem_flood</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="how-to-read-raster-data-using-gdal">
<h2>How to Read Raster Data using GDAL<a class="headerlink" href="#how-to-read-raster-data-using-gdal" title="Permalink to this headline">¶</a></h2>
<p>This demonstration uses the default OpenCV <a class="reference internal" href="../../../../modules/imgcodecs/doc/reading_and_writing_images.html#Mat imread(const String&amp; filename, int flags)" title="Mat imread(const String&amp; filename, int flags)"><tt class="xref ocv ocv-func docutils literal"><span class="pre">imread()</span></tt></a> function.  The primary difference is that in order to force GDAL to load the
image, you must use the appropriate flag.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_LOAD_GDAL</span> <span class="p">);</span>
</pre></div>
</div>
<p>When loading digital elevation models, the actual numeric value of each pixel is essential
and cannot be scaled or truncated.  For example, with image data a pixel represented as a double with a value of 1 has
an equal appearance to a pixel which is represented as an unsigned character with a value of 255.
With terrain data, the pixel value represents the elevation in meters.  In order to ensure that OpenCV preserves the native value,
use the GDAL flag in imread with the ANYDEPTH flag.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">dem</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_LOAD_GDAL</span> <span class="o">|</span> <span class="n">cv</span><span class="o">::</span><span class="n">IMREAD_ANYDEPTH</span> <span class="p">);</span>
</pre></div>
</div>
<p>If you know beforehand the type of DEM model you are loading, then it may be a safe bet to test the <tt class="docutils literal"><span class="pre">Mat::type()</span></tt> or <tt class="docutils literal"><span class="pre">Mat::depth()</span></tt>
using an assert or other mechanism. NASA or DOD specification documents can provide the input types for various
elevation models.  The major types, SRTM and DTED,  are both signed shorts.</p>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lat-lon-geodetic-coordinates-should-normally-be-avoided">
<h3>Lat/Lon (Geodetic) Coordinates should normally be avoided<a class="headerlink" href="#lat-lon-geodetic-coordinates-should-normally-be-avoided" title="Permalink to this headline">¶</a></h3>
<p>The Geodetic Coordinate System is a spherical coordinate system, meaning that using them with Cartesian mathematics is technically incorrect.  This
demo uses them to increase the readability and is accurate enough to make the point.  A better coordinate system would be Universal Transverse Mercator.</p>
</div>
<div class="section" id="finding-the-corner-coordinates">
<h3>Finding the corner coordinates<a class="headerlink" href="#finding-the-corner-coordinates" title="Permalink to this headline">¶</a></h3>
<p>One easy method to find the corner coordinates of an image is to use the command-line tool <tt class="docutils literal"><span class="pre">gdalinfo</span></tt>.  For imagery which is ortho-rectified and contains
the projection information, you can use the <a class="reference external" href="http://earthexplorer.usgs.gov/">USGS EarthExplorer</a>.</p>
<div class="highlight-bash"><div class="highlight"><pre>$&gt; gdalinfo N37W123.hgt

   Driver: SRTMHGT/SRTMHGT File Format
   Files: N37W123.hgt
   Size is 3601, 3601
   Coordinate System is:
   GEOGCS[&quot;WGS 84&quot;,
   DATUM[&quot;WGS_1984&quot;,

   ... more output ...

   Corner Coordinates:
   Upper Left  (-123.0001389,  38.0001389) (123d 0&#39; 0.50&quot;W, 38d 0&#39; 0.50&quot;N)
   Lower Left  (-123.0001389,  36.9998611) (123d 0&#39; 0.50&quot;W, 36d59&#39;59.50&quot;N)
   Upper Right (-121.9998611,  38.0001389) (121d59&#39;59.50&quot;W, 38d 0&#39; 0.50&quot;N)
   Lower Right (-121.9998611,  36.9998611) (121d59&#39;59.50&quot;W, 36d59&#39;59.50&quot;N)
   Center      (-122.5000000,  37.5000000) (122d30&#39; 0.00&quot;W, 37d30&#39; 0.00&quot;N)

    ... more output ...
</pre></div>
</div>
</div>
</div>
<div class="section" id="results">
<h2>Results<a class="headerlink" href="#results" title="Permalink to this headline">¶</a></h2>
<p>Below is the output of the program.  Use the first image as the input.  For the DEM model, download the SRTM file located at the USGS here. <a class="reference external" href="http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/Region_04/N37W123.hgt.zip">http://dds.cr.usgs.gov/srtm/version2_1/SRTM1/Region_04/N37W123.hgt.zip</a></p>
<img alt="../../../../_images/gdal_output.jpg" src="../../../../_images/gdal_output.jpg" />
<img alt="../../../../_images/gdal_heat-map.jpg" src="../../../../_images/gdal_heat-map.jpg" />
<img alt="../../../../_images/gdal_flood-zone.jpg" src="../../../../_images/gdal_flood-zone.jpg" />
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question on the <a href="http://answers.opencv.org/">Q&A forum</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="http://code.opencv.org/">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../calib3d/table_of_content_calib3d/table_of_content_calib3d.html" title="calib3d module. Camera calibration and 3D reconstruction"
             >next</a> |</li>
        <li class="right" >
          <a href="../video-write/video-write.html" title="Creating a video with OpenCV"
             >previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 3.0.0-dev documentation</a> &raquo;</li>
          <li><a href="../../tutorials.html" >OpenCV Tutorials</a> &raquo;</li>
          <li><a href="../table_of_content_highgui/table_of_content_highgui.html" ><em>highgui</em> module. High Level GUI and Media</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014, opencv dev team.
      Last updated on Dec 30, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
      <a href="../../../../_sources/doc/tutorials/highgui/raster-gdal/raster_io_gdal.txt" rel="nofollow">Show this page source.</a>
    </div>
  </body>

<!-- Mirrored from docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/raster-gdal/raster_io_gdal.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 23 Dec 2015 07:06:01 GMT -->
</html>